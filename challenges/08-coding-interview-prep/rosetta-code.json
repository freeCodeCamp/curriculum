{
  "name": "Rosetta Code",
  "order": 5,
  "time": "",
  "helpRoom": "",
  "nChallenges": 437,
  "challenges": [
    {
      "title": "100 doors",
      "description": [
        "<p>There are 100 doors in a row that are all initially closed. You make 100 passes by the doors. The first time through, visit every door and 'toggle' the door (if the door is closed, open it; if it is open, close it). The second time, only visit every 2nd door (i.e., door #2, #4, #6, ...) and toggle it. The third time, visit every 3rd door (i.e., door #3, #6, #9, ...), etc., until you only visit the 100th door.</p>",
        "<p>Implement a function to determine the state of the doors after the last pass. Return the final result in an array, with only the door number included in the array if it is open.</p>"
      ],
      "solutions": [
        "function getFinalOpenedDoors (numDoors) {\n  // this is the final pattern (always squares).\n  // thus, the most efficient solution simply returns an array of squares up to numDoors).\n  const finalState = [];\n  let i = 1;\n  while (Math.pow(i, 2) <= numDoors) {\n    finalState.push(Math.pow(i, 2));\n    i++;\n  }\n  return finalState;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>getFinalOpenedDoors</code> is a function.",
          "testString":
            "assert(typeof getFinalOpenedDoors === 'function', '<code>getFinalOpenedDoors</code> is a function.');"
        },
        {
          "text": "<code>getFinalOpenedDoors</code> should return an array.",
          "testString":
            "assert(Array.isArray(getFinalOpenedDoors(100)), '<code>getFinalOpenedDoors</code> should return an array.');"
        },
        {
          "text":
            "<code>getFinalOpenedDoors</code> did not produce the correct results.",
          "testString":
            "assert.deepEqual(getFinalOpenedDoors(100), solution, '<code>getFinalOpenedDoors</code> did not produce the correct results.');"
        }
      ],
      "id": "594810f028c0303b75339acb",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function getFinalOpenedDoors (numDoors) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": ["const solution = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100];"]
        }
      }
    },
    {
      "title": "24 game",
      "description": [
        "<p>Implement a function that takes a string of four digits as its argument, with each digit from 1 ──► 9 (inclusive) with repetitions allowed, and returns an arithmetic expression that evaluates to the number 24. If no such solution exists, return \"no solution exists.\"</p>",
        "<p>Rules:</p>",
        " Only the following operators/functions are allowed: multiplication, division, addition, subtraction",
        " Division should use floating point or rational arithmetic, etc, to preserve remainders.",
        " Forming multiple digit numbers from the supplied digits is disallowed. (So an answer of 12+12 when given 1, 2, 2, and 1 is wrong).",
        " The order of the digits when given does not have to be preserved.",
        "<p>Example inputs:</p>",
        "<code>solve24(\"4878\");</code>",
        "<code>solve24(\"1234\");</code>",
        "<code>solve24(\"6789\");</code>",
        "<code>solve24(\"1127\");</code>",
        "<p>Example outputs (strings):</p>",
        "<code>(7-8/8)*4</code>",
        "<code>3*1*4*2</code>",
        "<code>(6*8)/(9-7)</code>",
        "<code>(1+7)*(2+1)</code>"
      ],
      "solutions": [
        "// noprotect\n\nfunction solve24 (numStr) {\n  const digitsArr = numStr.split('');\n  const answers = [];\n\n  const digitPermutations = [];\n  const operatorPermutations = [];\n\n  function generateDigitPermutations (digits, permutations = []) {\n    if (digits.length === 0) {\n      digitPermutations.push(permutations);\n    }\n    else {\n      for (let i = 0; i < digits.length; i++) {\n        const curr = digits.slice();\n        const next = curr.splice(i, 1);\n        generateDigitPermutations(curr.slice(), permutations.concat(next));\n      }\n    }\n  }\n\n  function generateOperatorPermutations (permutations = []) {\n    const operators = ['+', '-', '*', '/'];\n    if (permutations.length === 3) {\n      operatorPermutations.push(permutations);\n    }\n    else {\n      for (let i = 0; i < operators.length; i++) {\n        const curr = permutations.slice();\n        curr.push(operators[i]);\n        generateOperatorPermutations(curr);\n      }\n    }\n  }\n\n  generateDigitPermutations(digitsArr);\n  generateOperatorPermutations();\n\n  interleave();\n\n  return answers[0];\n\n  function interleave () {\n    for (let i = 0; i < digitPermutations.length; i++) {\n      for (let j = 0; j < operatorPermutations.length; j++) {\n        const d = digitPermutations[i];\n        const o = operatorPermutations[j];\n        const perm = [\n          `${d[0]}${o[0]}${d[1]}${o[1]}${d[2]}${o[2]}${d[3]}`,\n          `(${d[0]}${o[0]}${d[1]})${o[1]}${d[2]}${o[2]}${d[3]}`,\n          `${d[0]}${o[0]}(${d[1]}${o[1]}${d[2]})${o[2]}${d[3]}`,\n          `${d[0]}${o[0]}${d[1]}${o[1]}(${d[2]}${o[2]}${d[3]})`,\n          `${d[0]}${o[0]}(${d[1]}${o[1]}${d[2]}${o[2]}${d[3]})`,\n          `(${d[0]}${o[0]}${d[1]}${o[1]}${d[2]})${o[2]}${d[3]}`,\n          `(${d[0]}${o[0]}${d[1]})${o[1]}(${d[2]}${o[2]}${d[3]})`\n        ];\n\n        perm.forEach(combination => {\n          const res = eval(combination);\n\n          if (res === 24) {\n            return answers.push(combination);\n          }\n        });\n      }\n    }\n  }\n}\n"
      ],
      "tests": [
        {
          "text": "<code>solve24</code> is a function.",
          "testString":
            "assert(typeof solve24 === 'function', '<code>solve24</code> is a function.');"
        },
        {
          "text":
            "<code>solve24(\"4878\")</code> should return <code>(7-8/8)*4</code> or <code>4*(7-8/8)</code>",
          "testString":
            "assert(include(answers[0], solve24(testCases[0])), '<code>solve24(\"4878\")</code> should return <code>(7-8/8)*4</code> or <code>4*(7-8/8)</code>');"
        },
        {
          "text":
            "<code>solve24(\"1234\")</code> should return any arrangement of <code>1*2*3*4</code>",
          "testString":
            "assert(include(answers[1], solve24(testCases[1])), '<code>solve24(\"1234\")</code> should return any arrangement of <code>1*2*3*4</code>');"
        },
        {
          "text":
            "<code>solve24(\"6789\")</code> should return <code>(6*8)/(9-7)</code> or <code>(8*6)/(9-7)</code>",
          "testString":
            "assert(include(answers[2], solve24(testCases[2])), '<code>solve24(\"6789\")</code> should return <code>(6*8)/(9-7)</code> or <code>(8*6)/(9-7)</code>');"
        },
        {
          "text":
            "<code>solve24(\"1127\")</code> should return a permutation of <code>(1+7)*(1*2)</code>",
          "testString":
            "assert(include(answers[3], solve24(testCases[3])), '<code>solve24(\"1127\")</code> should return a permutation of <code>(1+7)*(1*2)</code>');"
        }
      ],
      "id": "5951e88f64ebf159166a1176",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function solve24 (numStr) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const testCases = [",
            "  '4878',",
            "  '1234',",
            "  '6789',",
            "  '1127'",
            "];",
            "",
            "const answers = [",
            "  ['(7-8/8)*4', '4*(7-8/8)', '(4-8+7)*8', '(4+7-8)*8', '(7+4-8)*8', '(7-8+4)*8', '8*(4-8+7)', '8*(4+7-8)', '8*(7+4-8)', '8*(7-8+4)'],",
            "  ['1*2*3*4', '1*2*4*3', '1*3*2*4', '1*3*4*2', '1*4*2*3', '1*4*3*2', '2*1*3*4', '2*1*4*3', '2*3*1*4', '2*3*4*1', '2*4*3*1', '2*4*1*3', '3*1*2*4', '3*1*4*2', '3*2*1*4', '3*2*4*1', '3*4*1*2', '3*4*2*1', '4*1*2*3', '4*1*3*2', '4*2*1*3', '4*2*3*1', '4*3*1*2', '4*3*2*1', '(1+2+3)*4', '(1+3+2)*4', '(2+1+3)*4', '(2+3+1)*4', '(3+1+2)*4', '(3+2+1)*4', '4*(1+2+3)', '4*(2+1+3)', '4*(2+3+1)', '4*(3+1+2)', '4*(3+2+1)'],",
            "  ['(6*8)/(9-7)', '(8*6)/(9-7)', '6*8/(9-7)', '8*6/(9-7)'],",
            "  ['(1+7)*(2+1)', '(1+7)*(1+2)', '(1+2)*(1+7)', '(1+2)*(7+1)', '(2+1)*(1+7)', '(7+1)*(2+1)']",
            "];",
            "",
            "function include(ansArr, res) {",
            "  const index = ansArr.indexOf(res);",
            "  return index >= 0;",
            "}"
          ]
        }
      }
    },
    {
      "title": "9 billion names of God the integer",
      "description": [
        "<p>This task is a variation of the <a href=\"https://en.wikipedia.org/wiki/The Nine Billion Names of God#Plot_summary\" title=\"wp: The Nine Billion Names of God#Plot_summary\">short story by Arthur C. Clarke</a>.</p>",
        "<p>(Solvers should be aware of the consequences of completing this task.)</p>",
        "<p>In detail, to specify what is meant by a  “name”:</p>",
        "<p>The integer 1 has 1 name “1”.</p>",
        "<p>The integer 2 has 2 names “1+1”, and “2”.</p>",
        "<p>The integer 3 has 3 names “1+1+1”, “2+1”,  and “3”.</p>",
        "<p>The integer 4 has 5 names “1+1+1+1”, “2+1+1”, “2+2”, “3+1”, “4”.</p>",
        "<p>The integer 5 has 7 names “1+1+1+1+1”, “2+1+1+1”, “2+2+1”, “3+1+1”, “3+2”, “4+1”, “5”.</p>",
        "<p>This can be visualized in the following form:</p>",
        "<pre>",
        "          1",
        "        1   1",
        "      1   1   1",
        "    1   2   1   1",
        "  1   2   2   1   1",
        "1   3   3   2   1   1",
        "</pre>",
        "<p>Where row  $n$  corresponds to integer  $n$,  and each column  $C$  in row  $m$  from left to right corresponds to the number of names beginning with $C$.</p>",
        "<p>Optionally note that the sum of the  $n$-th  row  $P(n)$  is the   <a href=\"http://mathworld.wolfram.com/PartitionFunctionP.html\" title=\"link: http://mathworld.wolfram.com/PartitionFunctionP.html\">integer partition function</a>.</p>",
        "Task",
        "<p>Implement a function that returns the sum of the  $n$-th  row.</p>"
      ],
      "solutions": [
        "function numberOfNames (num) {\n  const cache = [\n    [1]\n  ];\n  for (let l = cache.length; l < num + 1; l++) {\n    let Aa;\n    let Mi;\n    const r = [0];\n    for (let x = 1; x < l + 1; x++) {\n      r.push(r[r.length - 1] + (Aa = cache[l - x < 0 ? cache.length - (l - x) : l - x])[(Mi = Math.min(x, l - x)) < 0 ? Aa.length - Mi : Mi]);\n    }\n    cache.push(r);\n  }\n  return cache[num][cache[num].length - 1];\n}\n"
      ],
      "tests": [
        {
          "text": "<code>numberOfNames</code> is a function.",
          "testString":
            "assert(typeof numberOfNames === 'function', '<code>numberOfNames</code> is a function.');"
        },
        {
          "text": "<code>numberOfNames(5)</code> should equal 7.",
          "testString":
            "assert.equal(numberOfNames(5), 7, '<code>numberOfNames(5)</code> should equal 7.');"
        },
        {
          "text": "<code>numberOfNames(12)</code> should equal 77.",
          "testString":
            "assert.equal(numberOfNames(12), 77, '<code>numberOfNames(12)</code> should equal 77.');"
        },
        {
          "text": "<code>numberOfNames(18)</code> should equal 385.",
          "testString":
            "assert.equal(numberOfNames(18), 385, '<code>numberOfNames(18)</code> should equal 385.');"
        },
        {
          "text": "<code>numberOfNames(23)</code> should equal 1255.",
          "testString":
            "assert.equal(numberOfNames(23), 1255, '<code>numberOfNames(23)</code> should equal 1255.');"
        },
        {
          "text": "<code>numberOfNames(42)</code> should equal 53174.",
          "testString":
            "assert.equal(numberOfNames(42), 53174, '<code>numberOfNames(42)</code> should equal 53174.');"
        },
        {
          "text": "<code>numberOfNames(123)</code> should equal 2552338241.",
          "testString":
            "assert.equal(numberOfNames(123), 2552338241, '<code>numberOfNames(123)</code> should equal 2552338241.');"
        }
      ],
      "id": "5949b579404977fbaefcd736",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function numberOfNames (num) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "ABC Problem",
      "description": [
        "<p>You are given a collection of ABC blocks (e.g., childhood alphabet blocks). There are 20 blocks with two letters on each block. A complete alphabet is guaranteed amongst all sides of the blocks. The sample collection of blocks:</p>",
        "<p>(B O)</p>",
        "<p>(X K)</p>",
        "<p>(D Q)</p>",
        "<p>(C P)</p>",
        "<p>(N A)</p>",
        "<p>(G T)</p>",
        "<p>(R E)</p>",
        "<p>(T G)</p>",
        "<p>(Q D)</p>",
        "<p>(F S)</p>",
        "<p>(J W)</p>",
        "<p>(H U)</p>",
        "<p>(V I)</p>",
        "<p>(A N)</p>",
        "<p>(O B)</p>",
        "<p>(E R)</p>",
        "<p>(F S)</p>",
        "<p>(L Y)</p>",
        "<p>(P C)</p>",
        "<p>(Z M)</p>",
        "<p>Some rules to keep in mind:</p>",
        "Once a letter on a block is used, that block cannot be used again.",
        "The function should be case-insensitive.",
        "<p>Implement a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks.</p>"
      ],
      "solutions": [
        "function canMakeWord (word) {\n  const characters = 'BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM';\n  const blocks = characters.split(' ').map(pair => pair.split(''));\n\n  const letters = [...word.toUpperCase()];\n  let length = letters.length;\n  const copy = new Set(blocks);\n\n  letters.forEach(letter => {\n    for (let block of copy) {\n      const index = block.indexOf(letter);\n\n      if (index !== -1) {\n        length--;\n        copy.delete(block);\n        break;\n      }\n    }\n  });\n  return !length;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>canMakeWord</code> is a function.",
          "testString":
            "assert(typeof canMakeWord === 'function', '<code>canMakeWord</code> is a function.');"
        },
        {
          "text": "<code>canMakeWord</code> should return a boolean.",
          "testString":
            "assert(typeof canMakeWord('hi') === 'boolean', '<code>canMakeWord</code> should return a boolean.');"
        },
        {
          "text": "<code>canMakeWord(\"bark\")</code> should return true.",
          "testString":
            "assert(canMakeWord(words[0]), '<code>canMakeWord(\"bark\")</code> should return true.');"
        },
        {
          "text": "<code>canMakeWord(\"BooK\")</code> should return false.",
          "testString":
            "assert(!canMakeWord(words[1]), '<code>canMakeWord(\"BooK\")</code> should return false.');"
        },
        {
          "text": "<code>canMakeWord(\"TReAT\")</code> should return true.",
          "testString":
            "assert(canMakeWord(words[2]), '<code>canMakeWord(\"TReAT\")</code> should return true.');"
        },
        {
          "text": "<code>canMakeWord(\"COMMON\")</code> should return false.",
          "testString":
            "assert(!canMakeWord(words[3]), '<code>canMakeWord(\"COMMON\")</code> should return false.');"
        },
        {
          "text": "<code>canMakeWord(\"squAD\")</code> should return true.",
          "testString":
            "assert(canMakeWord(words[4]), '<code>canMakeWord(\"squAD\")</code> should return true.');"
        },
        {
          "text": "<code>canMakeWord(\"conFUSE\")</code> should return true.",
          "testString":
            "assert(canMakeWord(words[5]), '<code>canMakeWord(\"conFUSE\")</code> should return true.');"
        }
      ],
      "id": "594810f028c0303b75339acc",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function canMakeWord (word) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "const words = ['bark', 'BooK', 'TReAT', 'COMMON', 'squAD', 'conFUSE'];"
          ]
        }
      }
    },
    {
      "title": "Abundant, deficient and perfect number classifications",
      "description": [
        "<p>These define three classifications of positive integers based on their <a href=\"http://rosettacode.org/wiki/Proper divisors\" title=\"Proper divisors\">proper divisors</a>.</p>",
        "<p>Let $P(n)$ be the sum of the proper divisors of n where proper divisors are all positive integers n other than n itself.</p>",
        "<p>If <code>P(n) < n</code> then n is classed as \"deficient\"</p>",
        "<p>If <code>P(n) === n</code> then n is classed as \"perfect\"</p>",
        "<p>If <code>P(n) > n</code> then n is classed as \"abundant\"</p>",
        "<p>Example:</p>",
        "<p>6 has proper divisors of 1, 2, and 3.</p>",
        "<p>1 + 2 + 3 = 6, so 6 is classed as a perfect number.</p>",
        "<p>Implement a function that calculates how many of the integers from 1 to 20,000 (inclusive) are in each of the three classes. Output the result as an array in the following format <code>[deficient, perfect, abundant]</code>.</p>"
      ],
      "solutions": [
        "function getDPA (num) {\n  const dpa = [1, 0, 0];\n  for (let n = 2; n <= num; n += 1) {\n    let ds = 1;\n    const e = Math.sqrt(n);\n    for (let d = 2; d < e; d += 1) {\n      if (n % d === 0) {\n        ds += d + (n / d);\n      }\n    }\n    if (n % e === 0) {\n      ds += e;\n    }\n    dpa[ds < n ? 0 : ds === n ? 1 : 2] += 1;\n  }\n  return dpa;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>getDPA</code> is a function.",
          "testString":
            "assert(typeof getDPA === 'function', '<code>getDPA</code> is a function.');"
        },
        {
          "text": "<code>getDPA</code> should return an array.",
          "testString":
            "assert(Array.isArray(getDPA(100)), '<code>getDPA</code> should return an array.');"
        },
        {
          "text": "<code>getDPA</code> return value should have a length of 3.",
          "testString":
            "assert(getDPA(100).length === 3, '<code>getDPA</code> return value should have a length of 3.');"
        },
        {
          "text": "<code>getDPA(20000)</code> should equal [15043, 4, 4953]",
          "testString":
            "assert.deepEqual(getDPA(20000), solution, '<code>getDPA(20000)</code> should equal [15043, 4, 4953]');"
        }
      ],
      "id": "594810f028c0303b75339acd",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function getDPA (num) {", "  // Good luck!", "}"],
          "head": [],
          "tail": ["const solution = [15043, 4, 4953];"]
        }
      }
    },
    {
      "title": "Accumulator factory",
      "description": [
        "<p>Create a function that takes a single (numeric) argument and returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).</p>",
        "<p>Rules:</p>",
        "<p>Do not use global variables.</p>",
        "<p>Hint:</p>",
        "<p>Closures save outer state.</p>"
      ],
      "solutions": [
        "function accumulator (sum) {\n  return function (n) {\n    return sum += n;\n  };\n}\n"
      ],
      "tests": [
        {
          "text": "<code>accumulator</code> is a function.",
          "testString":
            "assert(typeof accumulator === 'function', '<code>accumulator</code> is a function.');"
        },
        {
          "text": "<code>accumulator(0)</code> should return a function.",
          "testString":
            "assert(typeof accumulator(0) === 'function', '<code>accumulator(0)</code> should return a function.');"
        },
        {
          "text": "<code>accumulator(0)(2)</code> should return a number.",
          "testString":
            "assert(typeof accumulator(0)(2) === 'number', '<code>accumulator(0)(2)</code> should return a number.');"
        },
        {
          "text": "Passing in the values 3, -4, 1.5, and 5 should return 5.5.",
          "testString":
            "assert(testFn(5) === 5.5, 'Passing in the values 3, -4, 1.5, and 5 should return 5.5.');"
        }
      ],
      "id": "594810f028c0303b75339ace",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function accumulator (sum) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "const testFn = typeof accumulator(3) === 'function' && accumulator(3);",
            "if (testFn) {",
            "  testFn(-4);",
            "  testFn(1.5);",
            "}"
          ]
        }
      }
    },
    {
      "title": "Ackermann function",
      "description": [
        "<p>The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.</p>",
        "<p>The Ackermann function is usually defined as follows:</p>",
        "$$A(m, n) =",
        " \\begin{cases}",
        " n+1 & \\mbox{if } m = 0 \\\\",
        " A(m-1, 1) & \\mbox{if } m > 0 \\mbox{ and } n = 0 \\\\",
        " A(m-1, A(m, n-1)) & \\mbox{if } m > 0 \\mbox{ and } n > 0.",
        " \\end{cases}$$",
        "<p>Its arguments are never negative and it always terminates. Write a function which returns the value of $A(m, n)$. Arbitrary precision is preferred (since the function grows so quickly), but not required.</p>"
      ],
      "solutions": [
        "function ack (m, n) {\n  return m === 0 ? n + 1 : ack(m - 1, n === 0 ? 1 : ack(m, n - 1));\n}\n"
      ],
      "tests": [
        {
          "text": "<code>ack</code> is a function.",
          "testString":
            "assert(typeof ack === 'function', '<code>ack</code> is a function.');"
        },
        {
          "text": "<code>ack(0, 0)</code> should return 1.",
          "testString":
            "assert(ack(0, 0) === 1, '<code>ack(0, 0)</code> should return 1.');"
        },
        {
          "text": "<code>ack(1, 1)</code> should return 3.",
          "testString":
            "assert(ack(1, 1) === 3, '<code>ack(1, 1)</code> should return 3.');"
        },
        {
          "text": "<code>ack(2, 5)</code> should return 13.",
          "testString":
            "assert(ack(2, 5) === 13, '<code>ack(2, 5)</code> should return 13.');"
        },
        {
          "text": "<code>ack(3, 3)</code> should return 61.",
          "testString":
            "assert(ack(3, 3) === 61, '<code>ack(3, 3)</code> should return 61.');"
        }
      ],
      "id": "594810f028c0303b75339acf",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function ack (m, n) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Align columns",
      "description": [
        "<p>Given a text file of many lines, where fields within a line are delineated by a single <code>$</code> character, write a program that aligns each column of fields by ensuring that words in each column are separated by at least one space. Further, allow for each word in a column to be either left justified, right justified, or center justified within its column.</p>",
        "<p>Use the following text to test your programs:</p>",
        "<pre>",
        "Given$a$text$file$of$many$lines",
        "where$fields$within$a$line$",
        "are$delineated$by$a$single$'dollar'$character",
        "write$a$program",
        "that$aligns$each$column$of$fields",
        "by$ensuring$that$words$in$each$",
        "column$are$separated$by$at$least$one$space.",
        "Further,$allow$for$each$word$in$a$column$to$be$either$left$",
        "justified,$right$justified",
        "or$center$justified$within$its$column.",
        "</pre>",
        "<p>Note that:</p>",
        "The example input texts lines may, or may not, have trailing dollar characters.",
        "All columns should share the same alignment.",
        "Consecutive space characters produced adjacent to the end of lines are insignificant for the purposes of the task.",
        "Output text will be viewed in a mono-spaced font on a plain text editor or basic terminal.",
        "The minimum space between columns should be computed from the text and not hard-coded.",
        "It is not a requirement to add separating characters between or around columns."
      ],
      "solutions": [
        "const testArr = [\n  'Given$a$text$file$of$many$lines',\n  'where$fields$within$a$line$',\n  'are$delineated$by$a$single$\"dollar\"$character',\n  'write$a$program',\n  'that$aligns$each$column$of$fields$',\n  'by$ensuring$that$words$in$each$',\n  'column$are$separated$by$at$least$one$space.',\n  'Further,$allow$for$each$word$in$a$column$to$be$either$left$',\n  'justified,$right$justified',\n  'or$center$justified$within$its$column.'\n];\n\nString.prototype.repeat = function (n) { return new Array(1 + parseInt(n)).join(this); };\n\nfunction formatText (input, justification) {\n  let x, y, max, cols = 0, diff, left, right;\n  for (x = 0; x < input.length; x++) {\n    input[x] = input[x].split('$');\n    if (input[x].length > cols) {\n      cols = input[x].length;\n    }\n  }\n  for (x = 0; x < cols; x++) {\n    max = 0;\n    for (y = 0; y < input.length; y++) {\n      if (input[y][x] && max < input[y][x].length) {\n        max = input[y][x].length;\n      }\n    }\n    for (y = 0; y < input.length; y++) {\n      if (input[y][x]) {\n        diff = (max - input[y][x].length) / 2;\n        left = ' '.repeat(Math.floor(diff));\n        right = ' '.repeat(Math.ceil(diff));\n        if (justification === 'left') {\n          right += left; left = '';\n        }\n        if (justification === 'right') {\n          left += right; right = '';\n        }\n        input[y][x] = left + input[y][x] + right;\n      }\n    }\n  }\n  for (x = 0; x < input.length; x++) {\n    input[x] = input[x].join(' ');\n  }\n  input = input.join('\\n');\n  return input;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>formatText</code> is a function.",
          "testString":
            "assert(typeof formatText === 'function', '<code>formatText</code> is a function.');"
        },
        {
          "text":
            "<code>formatText</code> with the above input and \"right\" justification should produce the following: ",
          "testString":
            "assert.strictEqual(formatText(testInput, 'right'), rightAligned, '<code>formatText</code> with the above input and \"right\" justification should produce the following: ');"
        },
        {
          "text":
            "<code>formatText</code> with the above input and \"left\" justification should produce the following: ",
          "testString":
            "assert.strictEqual(formatText(testInput, 'left'), leftAligned, '<code>formatText</code> with the above input and \"left\" justification should produce the following: ');"
        },
        {
          "text":
            "<code>formatText</code> with the above input and \"center\" justification should produce the following: ",
          "testString":
            "assert.strictEqual(formatText(testInput, 'center'), centerAligned, '<code>formatText</code> with the above input and \"center\" justification should produce the following: ');"
        }
      ],
      "id": "594810f028c0303b75339ad0",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "const testArr = [",
            "  'Given$a$text$file$of$many$lines',",
            "  'where$fields$within$a$line$',",
            "  'are$delineated$by$a$single$\"dollar\"$character',",
            "  'write$a$program',",
            "  'that$aligns$each$column$of$fields$',",
            "  'by$ensuring$that$words$in$each$',",
            "  'column$are$separated$by$at$least$one$space.',",
            "  'Further,$allow$for$each$word$in$a$column$to$be$either$left$',",
            "  'justified,$right$justified',",
            "  'or$center$justified$within$its$column.'",
            "];",
            "",
            "function formatText (input, justification) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "const testInput = [",
            "  'Given$a$text$file$of$many$lines',",
            "  'where$fields$within$a$line$',",
            "  'are$delineated$by$a$single$\"dollar\"$character',",
            "  'write$a$program',",
            "  'that$aligns$each$column$of$fields$',",
            "  'by$ensuring$that$words$in$each$',",
            "  'column$are$separated$by$at$least$one$space.',",
            "  'Further,$allow$for$each$word$in$a$column$to$be$either$left$',",
            "  'justified,$right$justified',",
            "  'or$center$justified$within$its$column.'",
            "];",
            "",
            "const rightAligned = `     Given          a      text   file     of     many     lines",
            "     where     fields    within      a   line ",
            "       are delineated        by      a single \"dollar\" character",
            "     write          a   program",
            "      that     aligns      each column     of   fields ",
            "        by   ensuring      that  words     in     each ",
            "    column        are separated     by     at    least       one space.",
            "  Further,      allow       for   each   word       in         a column to be either left ",
            "justified,      right justified",
            "        or     center justified within    its  column.`;",
            "",
            "const leftAligned = `Given      a          text      file   of     many     lines    ",
            "where      fields     within    a      line   ",
            "are        delineated by        a      single \"dollar\" character",
            "write      a          program  ",
            "that       aligns     each      column of     fields   ",
            "by         ensuring   that      words  in     each     ",
            "column     are        separated by     at     least    one       space.",
            "Further,   allow      for       each   word   in       a         column to be either left ",
            "justified, right      justified",
            "or         center     justified within its    column. `;",
            "",
            "const centerAligned = `  Given        a        text     file    of     many     lines  ",
            "  where      fields    within     a     line  ",
            "   are     delineated    by       a    single \"dollar\" character",
            "  write        a       program ",
            "   that      aligns     each    column   of    fields  ",
            "    by      ensuring    that    words    in     each   ",
            "  column      are     separated   by     at    least      one    space.",
            " Further,    allow       for     each   word     in        a     column to be either left ",
            "justified,   right    justified",
            "    or       center   justified within  its   column. `;"
          ]
        }
      }
    },
    {
      "title": "Amicable pairs",
      "description": [
        "Two integers $N$ and $M$ are said to be <a href=\"https://en.wikipedia.org/wiki/Amicable numbers\" title=\"wp: Amicable numbers\">amicable pairs</a> if $N \\neq M$ and the sum of the <a href=\"http://rosettacode.org/wiki/Proper divisors\" title=\"Proper divisors\">proper divisors</a> of $N$ ($\\mathrm{sum}(\\mathrm{propDivs}(N))$) $= M$ as well as $\\mathrm{sum}(\\mathrm{propDivs}(M)) = N$.",
        "Example:",
        "1184 and 1210 are an amicable pair, with proper divisors:",
        " 1, 2, 4, 8, 16, 32, 37, 74, 148, 296, 592  and ",
        " 1, 2, 5, 10, 11, 22, 55, 110, 121, 242, 605   respectively.",
        "Task:",
        "Calculate and show here the Amicable pairs below 20,000 (there are eight).",
        "Related tasks",
        "<a href=\"http://rosettacode.org/wiki/Proper divisors\" title=\"Proper divisors\">Proper divisors</a>",
        "<a href=\"http://rosettacode.org/wiki/Abundant, deficient and perfect number classifications\" title=\"Abundant, deficient and perfect number classifications\">Abundant, deficient and perfect number classifications</a>",
        "<a href=\"http://rosettacode.org/wiki/Aliquot sequence classifications\" title=\"Aliquot sequence classifications\">Aliquot sequence classifications</a> and its amicable classification."
      ],
      "solutions": [
        "// amicablePairsUpTo :: Int -> [(Int, Int)]\nfunction amicablePairsUpTo (maxNum) {\n  return range(1, maxNum)\n    .map(x => properDivisors(x)\n      .reduce((a, b) => a + b, 0))\n    .reduce((a, m, i, lst) => {\n      const n = i + 1;\n\n      return (m > n) && lst[m - 1] === n ?\n        a.concat([\n          [n, m]\n        ]) : a;\n    }, []);\n}\n\n// properDivisors :: Int -> [Int]\nfunction properDivisors (n) {\n  if (n < 2) return [];\n\n  const rRoot = Math.sqrt(n);\n  const intRoot = Math.floor(rRoot);\n  const blnPerfectSquare = rRoot === intRoot;\n  const lows = range(1, intRoot)\n  .filter(x => (n % x) === 0);\n\n  return lows.concat(lows.slice(1)\n    .map(x => n / x)\n    .reverse()\n    .slice(blnPerfectSquare | 0));\n}\n\n// Int -> Int -> Maybe Int -> [Int]\nfunction range (m, n, step) {\n  const d = (step || 1) * (n >= m ? 1 : -1);\n\n  return Array.from({\n    length: Math.floor((n - m) / d) + 1\n  }, (_, i) => m + (i * d));\n}\n"
      ],
      "tests": [
        {
          "text": "<code>amicablePairsUpTo</code> is a function.",
          "testString":
            "assert(typeof amicablePairsUpTo === 'function', '<code>amicablePairsUpTo</code> is a function.');"
        },
        {
          "text":
            "<code>amicablePairsUpTo(300)</code> should return <code>[[220,284]]</code>.",
          "testString":
            "assert.deepEqual(amicablePairsUpTo(300), answer300, '<code>amicablePairsUpTo(300)</code> should return <code>[[220,284]]</code>.');"
        },
        {
          "text":
            "<code>amicablePairsUpTo(3000)</code> should return <code>[[220,284],[1184,1210],[2620,2924]]</code>.",
          "testString":
            "assert.deepEqual(amicablePairsUpTo(3000), answer3000, '<code>amicablePairsUpTo(3000)</code> should return <code>[[220,284],[1184,1210],[2620,2924]]</code>.');"
        },
        {
          "text":
            "<code>amicablePairsUpTo(20000)</code> should return <code>[[220,284],[1184,1210],[2620,2924],[5020,5564],[6232,6368],[10744,10856],[12285,14595],[17296,18416]]</code>.",
          "testString":
            "assert.deepEqual(amicablePairsUpTo(20000), answer20000, '<code>amicablePairsUpTo(20000)</code> should return <code>[[220,284],[1184,1210],[2620,2924],[5020,5564],[6232,6368],[10744,10856],[12285,14595],[17296,18416]]</code>.');"
        }
      ],
      "id": "5949b579404977fbaefcd737",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function amicablePairsUpTo (maxNum) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const answer300 = [[220, 284]];",
            "const answer3000 = [",
            "  [220, 284],",
            "  [1184, 1210],",
            "  [2620, 2924]",
            "];",
            "const answer20000 = [",
            "  [220, 284],",
            "  [1184, 1210],",
            "  [2620, 2924],",
            "  [5020, 5564],",
            "  [6232, 6368],",
            "  [10744, 10856],",
            "  [12285, 14595],",
            "  [17296, 18416]",
            "];"
          ]
        }
      }
    },
    {
      "title": "Averages/Mode",
      "description": [
        "<p>Write a program to find the <a href=\"https://en.wikipedia.org/wiki/Mode (statistics)\" title=\"wp: Mode (statistics)\">mode</a> value of a collection.</p><p>The case where the collection is empty may be ignored. Care must be taken to handle the case where the mode is non-unique.</p><p>If it is not appropriate or possible to support a general collection, use a vector (array), if possible. If it is not appropriate or possible to support an unspecified value type, use integers.</p>"
      ],
      "solutions": [
        "function mode(arr) {\n  const counter = {};\n  let result = [];\n  let max = 0;\n  // for (const i in arr) {\n  arr.forEach(el => {\n    if (!(el in counter)) {\n      counter[el] = 0;\n    }\n    counter[el]++;\n\n    if (counter[el] === max) {\n      result.push(el);\n    }\n    else if (counter[el] > max) {\n      max = counter[el];\n      result = [el];\n    }\n  });\n  return result;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>mode</code> is a function.",
          "testString":
            "assert(typeof mode === 'function', '<code>mode</code> is a function.');"
        },
        {
          "text":
            "<code>mode([1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17])</code> should equal <code>[6]</code>",
          "testString":
            "assert.deepEqual(mode(arr1), [6], '<code>mode([1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17])</code> should equal <code>[6]</code>');"
        },
        {
          "text":
            "<code>mode([1, 2, 4, 4, 1])</code> should equal <code>[1, 4]</code>.",
          "testString":
            "assert.deepEqual(mode(arr2).sort(), [1, 4], '<code>mode([1, 2, 4, 4, 1])</code> should equal <code>[1, 4]</code>.');"
        }
      ],
      "id": "594d8d0ab97724821379b1e6",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function mode (arr) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const arr1 = [1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17];",
            "const arr2 = [1, 2, 4, 4, 1];"
          ]
        }
      }
    },
    {
      "title": "Averages/Pythagorean means",
      "description": [
        "<p class='rosetta__paragraph'>Compute all three of the <a class='rosetta__link--wiki' href='https://en.wikipedia.org/wiki/Pythagorean means' title='wp: Pythagorean means'>Pythagorean means</a> of the set of integers <big>1</big> through <big>10</big> (inclusive).</p><p class='rosetta__paragraph'>Show that <big>$A(x_1,\\ldots,x_n) \\geq G(x_1,\\ldots,x_n) \\geq H(x_1,\\ldots,x_n)$</big> for this set of positive integers.</p> The most common of the three means, the <a class='rosetta__link--rosetta' href='http://rosettacode.org/wiki/Averages/Arithmetic mean' title='Averages/Arithmetic mean'>arithmetic mean</a>, is the sum of the list divided by its length: <big>$ A(x_1, \\ldots, x_n) = \\frac{x_1 + \\cdots + x_n}{n}$</big>The <a class='rosetta__link--wiki' href='https://en.wikipedia.org/wiki/Geometric mean' title='wp: Geometric mean'>geometric mean</a> is the $n$th root of the product of the list: <big>$ G(x_1, \\ldots, x_n) = \\sqrt[n]{x_1 \\cdots x_n} $</big>The <a class='rosetta__link--wiki' href='https://en.wikipedia.org/wiki/Harmonic mean' title='wp: Harmonic mean'>harmonic mean</a> is $n$ divided by the sum of the reciprocal of each item in the list: <big>$ H(x_1, \\ldots, x_n) = \\frac{n}{\\frac{1}{x_1} + \\cdots + \\frac{1}{x_n}} $</big>",
        "<p class='rosetta__paragraph'>Assume the input is an ordered array of all inclusive numbers.</p>",
        "<p class='rosetta__paragraph'>For the answer, please output an object in the following format:</p>",
        "<pre class='rosetta__pre'>",
        "{",
        "  values: {",
        "    Arithmetic: 5.5,",
        "    Geometric: 4.528728688116765,",
        "    Harmonic: 3.414171521474055",
        "  },",
        "  test: 'is A >= G >= H ? yes'",
        "}",
        "</pre>"
      ],
      "solutions": [
        "function pythagoreanMeans (rangeArr) {\n  // arithmeticMean :: [Number] -> Number\n  const arithmeticMean = xs =>\n    foldl((sum, n) => sum + n, 0, xs) / length(xs);\n\n  // geometricMean :: [Number] -> Number\n  const geometricMean = xs =>\n    raise(foldl((product, x) => product * x, 1, xs), 1 / length(xs));\n\n  // harmonicMean :: [Number] -> Number\n  const harmonicMean = xs =>\n    length(xs) / foldl((invSum, n) => invSum + (1 / n), 0, xs);\n\n  // GENERIC FUNCTIONS ------------------------------------------------------\n\n  // A list of functions applied to a list of arguments\n  // <*> :: [(a -> b)] -> [a] -> [b]\n  const ap = (fs, xs) => //\n    Array.prototype.concat(...fs.map(f => //\n      Array.prototype.concat(...xs.map(x => [f(x)]))));\n\n  // foldl :: (b -> a -> b) -> b -> [a] -> b\n  const foldl = (f, a, xs) => xs.reduce(f, a);\n\n  // length :: [a] -> Int\n  const length = xs => xs.length;\n\n  // mapFromList :: [(k, v)] -> Dictionary\n  const mapFromList = kvs =>\n    foldl((a, [k, v]) =>\n      (a[(typeof k === 'string' && k)] = v, a), {}, kvs);\n\n  // raise :: Num -> Int -> Num\n  const raise = (n, e) => Math.pow(n, e);\n/*\n  // show :: a -> String\n  // show :: a -> Int -> String\n  const show = (...x) =>\n    JSON.stringify.apply(\n      null, x.length > 1 ? [x[0], null, x[1]] : x\n    );\n*/\n  // zip :: [a] -> [b] -> [(a,b)]\n  const zip = (xs, ys) =>\n    xs.slice(0, Math.min(xs.length, ys.length))\n      .map((x, i) => [x, ys[i]]);\n\n  // TEST -------------------------------------------------------------------\n  // mean :: Dictionary\n  const mean = mapFromList(zip(\n    ['Arithmetic', 'Geometric', 'Harmonic'],\n    ap([arithmeticMean, geometricMean, harmonicMean], [\n      rangeArr\n    ])\n  ));\n\n  return {\n    values: mean,\n    test: `is A >= G >= H ? ${mean.Arithmetic >= mean.Geometric &&\n      mean.Geometric >= mean.Harmonic ? 'yes' : 'no'}`\n  };\n}\n"
      ],
      "tests": [
        {
          "text": "<code>pythagoreanMeans</code> is a function.",
          "testString":
            "assert(typeof pythagoreanMeans === 'function', '<code>pythagoreanMeans</code> is a function.');"
        },
        {
          "text":
            "<code>pythagoreanMeans([1, 2, ..., 10])</code> should equal the same output above.",
          "testString":
            "assert.deepEqual(pythagoreanMeans(range1), answer1, '<code>pythagoreanMeans([1, 2, ..., 10])</code> should equal the same output above.');"
        }
      ],
      "id": "594d966a1467eb84194f0086",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function pythagoreanMeans (rangeArr) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "const range1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
            "const answer1 = {",
            "  values: {",
            "    Arithmetic: 5.5,",
            "    Geometric: 4.528728688116765,",
            "    Harmonic: 3.414171521474055",
            "  },",
            "  test: 'is A >= G >= H ? yes'",
            "};",
            ""
          ]
        }
      }
    },
    {
      "title": "Averages/Root mean square",
      "description": [
        "<p>Compute the  <a href=\"https://en.wikipedia.org/wiki/Root mean square\" title=\"wp: Root mean square\">Root mean square</a>  of the numbers 1 through 10 inclusive.</p>",
        "<p>The  root mean square  is also known by its initials RMS (or rms), and as the quadratic mean.</p><p>The RMS is calculated as the mean of the squares of the numbers, square-rooted:</p>",
        "<p><big>$$x_{\\mathrm{rms}} = \\sqrt {{{x_1}^2 + {x_2}^2 + \\cdots + {x_n}^2} \\over n}. $$</big></p>"
      ],
      "solutions": [
        "function rms (arr) {\n  const sumOfSquares = arr.reduce((s, x) => s + x * x, 0);\n  return Math.sqrt(sumOfSquares / arr.length);\n}\n"
      ],
      "tests": [
        {
          "text": "<code>rms</code> is a function.",
          "testString":
            "assert(typeof rms === 'function', '<code>rms</code> is a function.');"
        },
        {
          "text":
            "<code>rms([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])</code> should equal <code>6.2048368229954285</code>.",
          "testString":
            "assert.equal(rms(arr1), answer1, '<code>rms([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])</code> should equal <code>6.2048368229954285</code>.');"
        }
      ],
      "id": "594da033de4190850b893874",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function rms (arr) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "const arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
            "const answer1 = 6.2048368229954285;"
          ]
        }
      }
    },
    {
      "title": "Babbage problem",
      "description": [
        "<p><a href=\"https://en.wikipedia.org/wiki/Charles_Babbage\" title=\"wp: Charles_Babbage\">Charles Babbage</a>, looking ahead to the sorts of problems his Analytical Engine would be able to solve, gave this example:</p>",
        "<blockquote>What is the smallest positive integer whose square ends in the digits 269,696?</blockquote>",
        " <p> - Babbage, letter to Lord Bowden, 1837; see Hollingdale and Tootill, <i>Electronic Computers</i>, second edition, 1970, p. 125.</p>",
        "<p>He thought the answer might be 99,736, whose square is 9,947,269,696; but he couldn't be certain.</p>",
        "<p>The task is to find out if Babbage had the right answer.</p>",
        "<p>Implement a function to return the lowest integer that satisfies the Babbage problem. If Babbage was right, return Babbage's number.</p>"
      ],
      "solutions": [
        "function babbage (babbageAns, endDigits) {\n  const babbageNum = Math.pow(babbageAns, 2);\n  const babbageStartDigits = parseInt(babbageNum.toString().replace('269696', ''));\n  let answer = 99736;\n\n  // count down from this answer and save any sqrt int result. return lowest one\n  for (let i = babbageStartDigits; i >= 0; i--) {\n    const num = parseInt(i.toString().concat('269696'));\n    const result = Math.sqrt(num);\n    if (result === Math.floor(Math.sqrt(num))) {\n      answer = result;\n    }\n  }\n\n  return answer;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>babbage</code> is a function.",
          "testString":
            "assert(typeof babbage === 'function', '<code>babbage</code> is a function.');"
        },
        {
          "text":
            "<code>babbage(99736, 269696)</code> should not return 99736 (there is a smaller answer).",
          "testString":
            "assert.equal(babbage(babbageAns, endDigits), answer, '<code>babbage(99736, 269696)</code> should not return 99736 (there is a smaller answer).');"
        }
      ],
      "id": "594db4d0dedb4c06a2a4cefd",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function babbage (babbageNum, endDigits) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const babbageAns = 99736;",
            "const endDigits = 269696;",
            "const answer = 25264;"
          ]
        }
      }
    },
    {
      "title": "Balanced brackets",
      "description": [
        "<p>Determine whether a generated string of brackets is balanced; that is, whether it consists entirely of pairs of opening/closing brackets (in that order), none of which mis-nest.</p>",
        "Examples:",
        "<p class='rosetta__paragraph'>(empty) true</p>",
        "<p class='rosetta__paragraph'><code>[]</code> true</p>",
        "<p class='rosetta__paragraph'><code>][</code> false</p>",
        "<p class='rosetta__paragraph'><code>[][]</code> true</p>",
        "<p class='rosetta__paragraph'><code>][][</code> false</p>",
        "<p class='rosetta__paragraph'><code>[]][[]</code> false</p>",
        "<p class='rosetta__paragraph'><code>[[[[]]]]</code> true</p>"
      ],
      "solutions": [
        "function isBalanced (str) {\n  if (str === '') return true;\n  let a = str;\n  let b;\n  do {\n    b = a;\n    a = a.replace(/\\[\\]/g, '');\n  } while (a !== b);\n  return !a;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>isBalanced</code> is a function.",
          "testString":
            "assert(typeof isBalanced === 'function', '<code>isBalanced</code> is a function.');"
        },
        {
          "text": "<code>isBalanced(\"[]\")</code> should return true.",
          "testString":
            "assert(isBalanced(testCases[0]), '<code>isBalanced(\"[]\")</code> should return true.');"
        },
        {
          "text":
            "<code>isBalanced(\"]][[[][][][]][\")</code> should return false.",
          "testString":
            "assert(!isBalanced(testCases[1]), '<code>isBalanced(\"]][[[][][][]][\")</code> should return false.');"
        },
        {
          "text":
            "<code>isBalanced(\"[][[[[][][[[]]]]]]\")</code> should return true.",
          "testString":
            "assert(isBalanced(testCases[2]), '<code>isBalanced(\"[][[[[][][[[]]]]]]\")</code> should return true.');"
        },
        {
          "text": "<code>isBalanced(\"][\")</code> should return true.",
          "testString":
            "assert(!isBalanced(testCases[3]), '<code>isBalanced(\"][\")</code> should return true.');"
        },
        {
          "text": "<code>isBalanced(\"[[[]]]][[]\")</code> should return true.",
          "testString":
            "assert(!isBalanced(testCases[4]), '<code>isBalanced(\"[[[]]]][[]\")</code> should return true.');"
        },
        {
          "text": "<code>isBalanced(\"][[]\")</code> should return true.",
          "testString":
            "assert(!isBalanced(testCases[5]), '<code>isBalanced(\"][[]\")</code> should return true.');"
        },
        {
          "text":
            "<code>isBalanced(\"][[][]][[[]]\")</code> should return true.",
          "testString":
            "assert(!isBalanced(testCases[6]), '<code>isBalanced(\"][[][]][[[]]\")</code> should return true.');"
        },
        {
          "text": "<code>isBalanced(\"[[][]]][\")</code> should return true.",
          "testString":
            "assert(!isBalanced(testCases[7]), '<code>isBalanced(\"[[][]]][\")</code> should return true.');"
        },
        {
          "text":
            "<code>isBalanced(\"[[[]]][[]]]][][[\")</code> should return true.",
          "testString":
            "assert(!isBalanced(testCases[8]), '<code>isBalanced(\"[[[]]][[]]]][][[\")</code> should return true.');"
        },
        {
          "text":
            "<code>isBalanced(\"[]][[]]][[[[][]]\")</code> should return true.",
          "testString":
            "assert(!isBalanced(testCases[9]), '<code>isBalanced(\"[]][[]]][[[[][]]\")</code> should return true.');"
        },
        {
          "text": "<code>isBalanced(\"][]][[][\")</code> should return true.",
          "testString":
            "assert(!isBalanced(testCases[10]), '<code>isBalanced(\"][]][[][\")</code> should return true.');"
        },
        {
          "text": "<code>isBalanced(\"[[]][[][]]\")</code> should return true.",
          "testString":
            "assert(isBalanced(testCases[11]), '<code>isBalanced(\"[[]][[][]]\")</code> should return true.');"
        },
        {
          "text": "<code>isBalanced(\"[[]]\")</code> should return true.",
          "testString":
            "assert(isBalanced(testCases[12]), '<code>isBalanced(\"[[]]\")</code> should return true.');"
        },
        {
          "text":
            "<code>isBalanced(\"]][]][[]][[[\")</code> should return true.",
          "testString":
            "assert(!isBalanced(testCases[13]), '<code>isBalanced(\"]][]][[]][[[\")</code> should return true.');"
        },
        {
          "text": "<code>isBalanced(\"][]][][[\")</code> should return true.",
          "testString":
            "assert(!isBalanced(testCases[14]), '<code>isBalanced(\"][]][][[\")</code> should return true.');"
        },
        {
          "text": "<code>isBalanced(\"][][\")</code> should return true.",
          "testString":
            "assert(!isBalanced(testCases[15]), '<code>isBalanced(\"][][\")</code> should return true.');"
        },
        {
          "text":
            "<code>isBalanced(\"[[]]][][][[]][\")</code> should return true.",
          "testString":
            "assert(!isBalanced(testCases[16]), '<code>isBalanced(\"[[]]][][][[]][\")</code> should return true.');"
        },
        {
          "text": "<code>isBalanced(\"\")</code> should return true.",
          "testString":
            "assert(isBalanced(testCases[17]), '<code>isBalanced(\"\")</code> should return true.');"
        }
      ],
      "id": "594dc6c729e5700999302b45",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function isBalanced (str) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const testCases = [",
            "  '[]',",
            "  ']][[[][][][]][',",
            "  '[][[[[][][[[]]]]]]',",
            "  '][',",
            "  '[[[]]]][[]',",
            "  '][[]',",
            "  '][[][]][[[]]',",
            "  '[[][]]][',",
            "  '[[[]]][[]]]][][[',",
            "  '[]][[]]][[[[][]]',",
            "  '][]][[][',",
            "  '[[]][[][]]',",
            "  '[[]]',",
            "  ']][]][[]][[[',",
            "  '][]][][[',",
            "  '][][',",
            "  '[[]]][][][[]][',",
            "  ''",
            "];"
          ]
        }
      }
    },
    {
      "title": "CUSIP",
      "description": [
        "A  <b>CUSIP</b>  is a nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades. The CUSIP was adopted as an American National Standard under Accredited Standards X9.6.",
        "Write a function that takes a string as a parameter and checks if the string is valid CUSIP."
      ],
      "solutions": [
        "function isCusip (s) {\n  if (s.length != 9) return false;\n  var sum = 0;\n  var ASCII = x => x.charCodeAt(0);\n  for (var i = 0; i < 7; i++) {\n    var c = s.charCodeAt(i);\n\n    var v;\n    if (c >= ASCII('0') && c <= ASCII('9')) {\n      v = c - 48;\n    } else if (c >= ASCII('A') && c <= ASCII('Z')) {\n      v = c - 64; // lower case letters apparently invalid\n    } else if (c == ASCII('*')) {\n      v = 36;\n    } else if (c == ASCII('@')) {\n      v = 37;\n    } else if (c == ASCII('#')) {\n      v = 38;\n    } else {\n      return false;\n    }\n    if (i % 2 == 1) v *= 2; // check if odd as using 0-based indexing\n    sum += Math.floor(v / 10) + v % 10;\n  }\n  return s.charCodeAt(8) - 48 == (10 - (sum % 10)) % 10;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>isCusip</code> should be a function.'",
          "testString":
            "assert(typeof isCusip=='function','<code>isCusip</code> should be a function.');"
        },
        {
          "text":
            "'<code>isCusip(\"037833100\")</code> should return a boolean.'",
          "testString":
            "assert(typeof isCusip(\"037833100\") == 'boolean','<code>isCusip(\"037833100\")</code> should return a boolean.');"
        },
        {
          "text":
            "'<code>isCusip(\"037833100\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isCusip(\"037833100\"),true,'<code>isCusip(\"037833100\")</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isCusip(\"17275R102\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isCusip(\"17275R102\"),true,'<code>isCusip(\"17275R102\")</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isCusip(\"38259P50a\")</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isCusip(\"38259P50a\"),false,'<code>isCusip(\"38259P50a\")</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>isCusip(\"38259P508\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isCusip(\"38259P508\"),true,'<code>isCusip(\"38259P508\")</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isCusip(\"38259P50#\")</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isCusip(\"38259P50#\"),false,'<code>isCusip(\"38259P50#\")</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>isCusip(\"68389X105\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isCusip(\"68389X105\"),true,'<code>isCusip(\"68389X105\")</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isCusip(\"68389X106\")</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isCusip(\"68389X106\"),false,'<code>isCusip(\"68389X106\")</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>isCusip(\"5949181\")</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isCusip(\"5949181\"),false,'<code>isCusip(\"5949181\")</code> should return <code>false</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7e05",
      "challengeType": 5,
      "releasedOn": "September 1, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function isCusip (s) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Circles of given radius through two points",
      "description": [
        "<p>Given two points on a plane and a radius, usually two circles of given radius can be drawn through the points.</p>",
        "Exceptions:",
        "A radius of zero should be treated as never describing circles (except in the case where the points are coincident).",
        "If the points are coincident then an infinite number of circles with the point on their circumference can be drawn, unless the radius is equal to zero as well which then collapses the circles to a point.",
        "If the points form a diameter then return a single circle.",
        "If the points are too far apart then no circles can be drawn.Task:",
        "Implement a function that takes two points and a radius and returns the two circles through those points. For each resulting circle, provide the coordinates for the center of each circle rounded to four decimal digits. Return each coordinate as an array, and coordinates as an array of arrays.",
        "For edge cases, return the following:",
        "If points are on the diameter, return one point. If the radius is also zero however, return <code>\"Radius Zero\"</code>.",
        "If points are coincident, return <code>\"Coincident point. Infinite solutions\"</code>.",
        "If points are farther apart than the diameter, return <code>\"No intersection. Points further apart than circle diameter\"</code>.",
        "Sample inputs:",
        "<pre>",
        "      p1                p2           r",
        "0.1234, 0.9876    0.8765, 0.2345    2.0",
        "0.0000, 2.0000    0.0000, 0.0000    1.0",
        "0.1234, 0.9876    0.1234, 0.9876    2.0",
        "0.1234, 0.9876    0.8765, 0.2345    0.5",
        "0.1234, 0.9876    0.1234, 0.9876    0.0",
        "</pre>",
        "Ref:",
        "<a href=\"http://mathforum.org/library/drmath/view/53027.html\" title=\"link: http://mathforum.org/library/drmath/view/53027.html\">Finding the Center of a Circle from 2 Points and Radius</a> from Math forum @ Drexel"
      ],
      "solutions": [
        "const hDist = (p1, p2) => Math.hypot(...p1.map((e, i) => e - p2[i])) / 2;\nconst pAng = (p1, p2) => Math.atan(p1.map((e, i) => e - p2[i]).reduce((p, c) => c / p, 1));\nconst solveF = (p, r) => t => [parseFloat((r * Math.cos(t) + p[0]).toFixed(4)), parseFloat((r * Math.sin(t) + p[1]).toFixed(4))];\nconst diamPoints = (p1, p2) => p1.map((e, i) => parseFloat((e + (p2[i] - e) / 2).toFixed(4)));\n\nfunction getCircles (...args) {\n  const [p1, p2, s] = args;\n  const solve = solveF(p1, s);\n  const halfDist = hDist(p1, p2);\n\n  let msg = [];\n  switch (Math.sign(s - halfDist)) {\n    case 0:\n      msg = s ? diamPoints(p1, p2) :\n        'Radius Zero';\n      break;\n    case 1:\n      if (!halfDist) {\n        msg = 'Coincident point. Infinite solutions';\n      }\n      else {\n        const theta = pAng(p1, p2);\n        const theta2 = Math.acos(halfDist / s);\n        [1, -1].map(e => solve(theta + e * theta2)).forEach(\n          e => msg.push(e));\n      }\n      break;\n    case -1:\n      msg = 'No intersection. Points further apart than circle diameter';\n      break;\n    default:\n      msg = 'Reached the default';\n  }\n  return msg;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>getCircles</code> is a function.",
          "testString":
            "assert(typeof getCircles === 'function', '<code>getCircles</code> is a function.');"
        },
        {
          "text":
            "<code>getCircles([0.1234, 0.9876], [0.8765, 0.2345], 2.0)</code> should return <code>[[1.8631, 1.9742], [-0.8632, -0.7521]]</code>.",
          "testString":
            "assert.deepEqual(getCircles(...testCases[0]), answers[0], '<code>getCircles([0.1234, 0.9876], [0.8765, 0.2345], 2.0)</code> should return <code>[[1.8631, 1.9742], [-0.8632, -0.7521]]</code>.');"
        },
        {
          "text":
            "<code>getCircles([0.0000, 2.0000], [0.0000, 0.0000], 1.0)</code> should return <code>[0, 1]</code>",
          "testString":
            "assert.deepEqual(getCircles(...testCases[1]), answers[1], '<code>getCircles([0.0000, 2.0000], [0.0000, 0.0000], 1.0)</code> should return <code>[0, 1]</code>');"
        },
        {
          "text":
            "<code>getCircles([0.1234, 0.9876], [0.1234, 0.9876], 2.0)</code> should return <code>Coincident point. Infinite solutions</code>",
          "testString":
            "assert.deepEqual(getCircles(...testCases[2]), answers[2], '<code>getCircles([0.1234, 0.9876], [0.1234, 0.9876], 2.0)</code> should return <code>Coincident point. Infinite solutions</code>');"
        },
        {
          "text":
            "<code>getCircles([0.1234, 0.9876], [0.8765, 0.2345], 0.5)</code> should return <code>No intersection. Points further apart than circle diameter</code>",
          "testString":
            "assert.deepEqual(getCircles(...testCases[3]), answers[3], '<code>getCircles([0.1234, 0.9876], [0.8765, 0.2345], 0.5)</code> should return <code>No intersection. Points further apart than circle diameter</code>');"
        },
        {
          "text":
            "<code>getCircles([0.1234, 0.9876], [0.1234, 0.9876], 0.0)</code> should return <code>Radius Zero</code>",
          "testString":
            "assert.deepEqual(getCircles(...testCases[4]), answers[4], '<code>getCircles([0.1234, 0.9876], [0.1234, 0.9876], 0.0)</code> should return <code>Radius Zero</code>');"
        }
      ],
      "id": "5951815dd895584b06884620",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function getCircles (...args) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const testCases = [",
            "  [[0.1234, 0.9876], [0.8765, 0.2345], 2.0],",
            "  [[0.0000, 2.0000], [0.0000, 0.0000], 1.0],",
            "  [[0.1234, 0.9876], [0.1234, 0.9876], 2.0],",
            "  [[0.1234, 0.9876], [0.8765, 0.2345], 0.5],",
            "  [[0.1234, 0.9876], [0.1234, 0.9876], 0.0]",
            "];",
            "const answers = [",
            "  [[1.8631, 1.9742], [-0.8632, -0.7521]],",
            "  [0, 1],",
            "  'Coincident point. Infinite solutions',",
            "  'No intersection. Points further apart than circle diameter',",
            "  'Radius Zero'",
            "];"
          ]
        }
      }
    },
    {
      "title": "Closest-pair problem",
      "description": [
        "Task:",
        "<p>Provide a function to find the closest two points among a set of given points in two dimensions,  i.e. to solve the  <a href=\"https://en.wikipedia.org/wiki/Closest pair of points problem\" title=\"wp: Closest pair of points problem\">Closest pair of points problem</a>  in the  planar  case.</p><p>The straightforward solution is a  O(n<sup>2</sup>)  algorithm  (which we can call brute-force algorithm);  the pseudo-code (using indexes) could be simply:</p>",
        "<pre>",
        "bruteForceClosestPair of P(1), P(2), ... P(N)",
        "if N &lt; 2 then",
        "  return ∞",
        "else",
        "  minDistance ← |P(1) - P(2)|",
        "  minPoints ← { P(1), P(2) }",
        "  foreach i ∈ [1, N-1]",
        "    foreach j ∈ [i+1, N]",
        "      if |P(i) - P(j)| < minDistance then",
        "        minDistance ← |P(i) - P(j)|",
        "        minPoints ← { P(i), P(j) }",
        "      endif",
        "    endfor",
        "  endfor",
        "  return minDistance, minPoints",
        "endif",
        "</pre>",
        "<p>A better algorithm is based on the recursive divide&amp;conquer approach, as explained also at  <a href=\"https://en.wikipedia.org/wiki/Closest pair of points problem#Planar_case\" title=\"wp: Closest pair of points problem#Planar_case\">Wikipedia's Closest pair of points problem</a>,  which is  O(n log n);  a pseudo-code could be:</p>",
        "<pre>",
        "closestPair of (xP, yP)",
        "  where xP is P(1) .. P(N) sorted by x coordinate, and",
        "  yP is P(1) .. P(N) sorted by y coordinate (ascending order)",
        "if N ≤ 3 then",
        "  return closest points of xP using brute-force algorithm",
        "else",
        "  xL ← points of xP from 1 to ⌈N/2⌉",
        "  xR ← points of xP from ⌈N/2⌉+1 to N",
        "  xm ← xP(⌈N/2⌉)<sub>x</sub>",
        "  yL ← { p ∈ yP : p<sub>x</sub> ≤ xm }",
        "  yR ← { p ∈ yP : p<sub>x</sub> &gt; xm }",
        "  (dL, pairL) ← closestPair of (xL, yL)",
        "  (dR, pairR) ← closestPair of (xR, yR)",
        "  (dmin, pairMin) ← (dR, pairR)",
        "  if dL &lt; dR then",
        "    (dmin, pairMin) ← (dL, pairL)",
        "  endif",
        "  yS ← { p ∈ yP : |xm - p<sub>x</sub>| &lt; dmin }",
        "  nS ← number of points in yS",
        "  (closest, closestPair) ← (dmin, pairMin)",
        "  for i from 1 to nS - 1",
        "    k ← i + 1",
        "    while k ≤ nS and yS(k)<sub>y</sub> - yS(i)<sub>y</sub> &lt; dmin",
        "      if |yS(k) - yS(i)| &lt; closest then",
        "        (closest, closestPair) ← (|yS(k) - yS(i)|, {yS(k), yS(i)})",
        "      endif",
        "      k ← k + 1",
        "    endwhile",
        "  endfor",
        "  return closest, closestPair",
        "endif",
        "</pre>",
        "References and further readings:",
        " <a href=\"https://en.wikipedia.org/wiki/Closest pair of points problem\" title=\"wp: Closest pair of points problem\">Closest pair of points problem</a>",
        " <a href=\"http://www.cs.mcgill.ca/~cs251/ClosestPair/ClosestPairDQ.html\" title=\"link: http://www.cs.mcgill.ca/~cs251/ClosestPair/ClosestPairDQ.html\">Closest Pair (McGill)</a>",
        " <a href=\"http://www.cs.ucsb.edu/~suri/cs235/ClosestPair.pdf\" title=\"link: http://www.cs.ucsb.edu/~suri/cs235/ClosestPair.pdf\">Closest Pair (UCSB)</a>",
        " <a href=\"http://classes.cec.wustl.edu/~cse241/handouts/closestpair.pdf\" title=\"link: http://classes.cec.wustl.edu/~cse241/handouts/closestpair.pdf\">Closest pair (WUStL)</a>",
        " <a href=\"http://www.cs.iupui.edu/~xkzou/teaching/CS580/Divide-and-conquer-closestPair.ppt\" title=\"link: http://www.cs.iupui.edu/~xkzou/teaching/CS580/Divide-and-conquer-closestPair.ppt\">Closest pair (IUPUI)</a> ",
        "<p>For the input, expect the argument to be an array of objects (points) with <code>x</code> and <code>y</code> members set to numbers. For the output, return an object containing the key:value pairs for  <code>distance</code> and <code>pair</code> (i.e., the pair of two closest points).</p>"
      ],
      "solutions": [
        "const Point = function (x, y) {\n  this.x = x;\n  this.y = y;\n};\nPoint.prototype.getX = function () {\n  return this.x;\n};\nPoint.prototype.getY = function () {\n  return this.y;\n};\n\nconst mergeSort = function mergeSort(points, comp) {\n\tif(points.length < 2) return points;\n\n\tvar n = points.length,\n\t\ti = 0,\n\t\tj = 0,\n\t\tleftN = Math.floor(n / 2),\n\t\trightN = leftN;\n\n\tvar leftPart = mergeSort( points.slice(0, leftN), comp),\n\t\trightPart = mergeSort( points.slice(rightN), comp );\n\n\tvar sortedPart = [];\n\n\twhile((i < leftPart.length) && (j < rightPart.length)) {\n\t\tif(comp(leftPart[i], rightPart[j]) < 0) {\n\t\t\tsortedPart.push(leftPart[i]);\n\t\t\ti += 1;\n\t\t}\n\t\telse {\n\t\t\tsortedPart.push(rightPart[j]);\n\t\t\tj += 1;\n\t\t}\n\t}\n\twhile(i < leftPart.length) {\n\t\tsortedPart.push(leftPart[i]);\n\t\ti += 1;\n\t}\n\twhile(j < rightPart.length) {\n\t\tsortedPart.push(rightPart[j]);\n\t\tj += 1;\n\t}\n\treturn sortedPart;\n};\n\nconst closestPair = function _closestPair(Px, Py) {\n\tif(Px.length < 2) return { distance: Infinity, pair: [ new Point(0, 0), new Point(0, 0) ] };\n\tif(Px.length < 3) {\n\t\t//find euclid distance\n\t\tvar d = Math.sqrt( Math.pow(Math.abs(Px[1].x - Px[0].x), 2) + Math.pow(Math.abs(Px[1].y - Px[0].y), 2) );\n\t\treturn {\n\t\t\tdistance: d,\n\t\t\tpair: [ Px[0], Px[1] ]\n\t\t};\n\t}\n\n\tvar\tn = Px.length,\n\t\tleftN = Math.floor(n / 2),\n\t\trightN = leftN;\n\n\tvar Xl = Px.slice(0, leftN),\n\t\tXr = Px.slice(rightN),\n\t\tXm = Xl[leftN - 1],\n\t\tYl = [],\n\t\tYr = [];\n\t//separate Py\n\tfor(var i = 0; i < Py.length; i += 1) {\n\t\tif(Py[i].x <= Xm.x)\n\t\t\tYl.push(Py[i]);\n\t\telse\n\t\t\tYr.push(Py[i]);\n\t}\n\n\tvar dLeft = _closestPair(Xl, Yl),\n\t\tdRight = _closestPair(Xr, Yr);\n\n\tvar minDelta = dLeft.distance,\n\t\tclosestPair = dLeft.pair;\n\tif(dLeft.distance > dRight.distance) {\n\t\tminDelta = dRight.distance;\n\t\tclosestPair = dRight.pair;\n\t}\n\n\t//filter points around Xm within delta (minDelta)\n\tvar closeY = [];\n\tfor(i = 0; i < Py.length; i += 1) {\n\t\tif(Math.abs(Py[i].x - Xm.x) < minDelta) closeY.push(Py[i]);\n\t}\n\t//find min within delta. 8 steps max\n\tfor(i = 0; i < closeY.length; i += 1) {\n\t\tfor(var j = i + 1; j < Math.min( (i + 8), closeY.length ); j += 1) {\n\t\t\tvar d = Math.sqrt( Math.pow(Math.abs(closeY[j].x - closeY[i].x), 2) + Math.pow(Math.abs(closeY[j].y - closeY[i].y), 2) );\n\t\t\tif(d < minDelta) {\n\t\t\t\tminDelta = d;\n\t\t\t\tclosestPair = [ closeY[i], closeY[j] ]\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tdistance: minDelta,\n\t\tpair: closestPair\n\t};\n};\n\nfunction getClosestPair (points) {\n  const sortX = function (a, b) { return (a.x < b.x) ? -1 : ((a.x > b.x) ? 1 : 0); }\n  const sortY = function (a, b) { return (a.y < b.y) ? -1 : ((a.y > b.y) ? 1 : 0); }\n\n  const Px = mergeSort(points, sortX);\n  const Py = mergeSort(points, sortY);\n\n  return closestPair(Px, Py);\n}\n"
      ],
      "tests": [
        {
          "text": "<code>getClosestPair</code> is a function.",
          "testString":
            "assert(typeof getClosestPair === 'function', '<code>getClosestPair</code> is a function.');"
        },
        {
          "text": "Distance should be the following.",
          "testString":
            "assert.equal(getClosestPair(points1).distance, answer1.distance, 'Distance should be the following.');"
        },
        {
          "text": "Points should be the following.",
          "testString":
            "assert.deepEqual(JSON.parse(JSON.stringify(getClosestPair(points1))).pair, answer1.pair, 'Points should be the following.');"
        },
        {
          "text": "Distance should be the following.",
          "testString":
            "assert.equal(getClosestPair(points2).distance, answer2.distance, 'Distance should be the following.');"
        },
        {
          "text": "Points should be the following.",
          "testString":
            "assert.deepEqual(JSON.parse(JSON.stringify(getClosestPair(points2))).pair, answer2.pair, 'Points should be the following.');"
        }
      ],
      "id": "5951a53863c8a34f02bf1bdc",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "const Point = function (x, y) {",
            "  this.x = x;",
            "  this.y = y;",
            "};",
            "Point.prototype.getX = function () {",
            "  return this.x;",
            "};",
            "Point.prototype.getY = function () {",
            "  return this.y;",
            "};",
            "",
            "function getClosestPair (pointsArr) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const points1 = [",
            "\tnew Point(0.748501, 4.09624),",
            "\tnew Point(3.00302, 5.26164),",
            "\tnew Point(3.61878,  9.52232),",
            "\tnew Point(7.46911,  4.71611),",
            "\tnew Point(5.7819,   2.69367),",
            "\tnew Point(2.34709,  8.74782),",
            "\tnew Point(2.87169,  5.97774),",
            "\tnew Point(6.33101,  0.463131),",
            "\tnew Point(7.46489,  4.6268),",
            "\tnew Point(1.45428,  0.087596)",
            "];",
            "",
            "const points2 = [",
            "  new Point(37100, 13118),",
            "  new Point(37134, 1963),",
            "  new Point(37181, 2008),",
            "  new Point(37276, 21611),",
            "  new Point(37307, 9320)",
            "];",
            "",
            "const answer1 = {",
            "  distance: 0.0894096443343775,",
            "  pair: [",
            "    {",
            "      x: 7.46489,",
            "      y: 4.6268",
            "    },",
            "    {",
            "      x: 7.46911,",
            "      y: 4.71611",
            "    }",
            "  ]",
            "};",
            "",
            "const answer2 = {",
            "  distance: 65.06919393998976,",
            "  pair: [",
            "    {",
            "      x: 37134,",
            "      y: 1963",
            "    },",
            "    {",
            "      x: 37181,",
            "      y: 2008",
            "    }",
            "  ]",
            "};",
            "",
            "const benchmarkPoints = [",
            "  new Point(16909, 54699),",
            "  new Point(14773, 61107),",
            "  new Point(95547, 45344),",
            "  new Point(95951, 17573),",
            "  new Point(5824, 41072),",
            "  new Point(8769, 52562),",
            "  new Point(21182, 41881),",
            "  new Point(53226, 45749),",
            "  new Point(68180, 887),",
            "  new Point(29322, 44017),",
            "  new Point(46817, 64975),",
            "  new Point(10501, 483),",
            "  new Point(57094, 60703),",
            "  new Point(23318, 35472),",
            "  new Point(72452, 88070),",
            "  new Point(67775, 28659),",
            "  new Point(19450, 20518),",
            "  new Point(17314, 26927),",
            "  new Point(98088, 11164),",
            "  new Point(25050, 56835),",
            "  new Point(8364, 6892),",
            "  new Point(37868, 18382),",
            "  new Point(23723, 7701),",
            "  new Point(55767, 11569),",
            "  new Point(70721, 66707),",
            "  new Point(31863, 9837),",
            "  new Point(49358, 30795),",
            "  new Point(13041, 39745),",
            "  new Point(59635, 26523),",
            "  new Point(25859, 1292),",
            "  new Point(1551, 53890),",
            "  new Point(70316, 94479),",
            "  new Point(48549, 86338),",
            "  new Point(46413, 92747),",
            "  new Point(27186, 50426),",
            "  new Point(27591, 22655),",
            "  new Point(10905, 46153),",
            "  new Point(40408, 84202),",
            "  new Point(52821, 73520),",
            "  new Point(84865, 77388),",
            "  new Point(99819, 32527),",
            "  new Point(34404, 75657),",
            "  new Point(78457, 96615),",
            "  new Point(42140, 5564),",
            "  new Point(62175, 92342),",
            "  new Point(54958, 67112),",
            "  new Point(4092, 19709),",
            "  new Point(99415, 60298),",
            "  new Point(51090, 52158),",
            "  new Point(48953, 58567)",
            "];"
          ]
        }
      }
    },
    {
      "title": "Combinations",
      "description": [
        "Task:",
        "<p>Given non-negative integers  <big> m </big>  and  <big> n</big>,  generate all size  <big> m </big>  <a href=\"http://mathworld.wolfram.com/Combination.html\" title=\"link: http://mathworld.wolfram.com/Combination.html\">combinations</a>  of the integers from  <big> 0</big>  (zero)  to  <big> n-1 </big>  in sorted order  (each combination is sorted and the entire table is sorted).</p>",
        "Example:",
        "<p><big>3</big>  comb  <big> 5 </big>is:</p>",
        "<pre>",
        "0 1 2",
        "0 1 3",
        "0 1 4",
        "0 2 3",
        "0 2 4",
        "0 3 4",
        "1 2 3",
        "1 2 4",
        "1 3 4",
        "2 3 4",
        "</pre>"
      ],
      "solutions": [
        "function combinations (m, n) {\n  const nArr = [...Array(n).keys()];\n\n  return (function generateCombinations (size, numArr) {\n    const ret = [];\n\n    for (let i = 0; i < numArr.length; i++) {\n      if (size === 1) {\n        ret.push([numArr[i]]);\n      }\n      else {\n        const sub = generateCombinations(size - 1, numArr.slice(i + 1, numArr.length));\n        for (let subI = 0; subI < sub.length; subI++) {\n          const next = sub[subI];\n          next.unshift(numArr[i]);\n          ret.push(next);\n        }\n      }\n    }\n    return ret;\n  }(m, nArr));\n}\n"
      ],
      "tests": [
        {
          "text": "<code>combinations</code> is a function.",
          "testString":
            "assert(typeof combinations === 'function', '<code>combinations</code> is a function.');"
        },
        {
          "text":
            "<code>combinations(3, 5)</code> should return <code>[[0, 1, 2], [0, 1, 3], [0, 1, 4], [0, 2, 3], [0, 2, 4], [0, 3, 4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]</code>.",
          "testString":
            "assert.deepEqual(combinations(testInput1[0], testInput1[1]), testOutput1, '<code>combinations(3, 5)</code> should return <code>[[0, 1, 2], [0, 1, 3], [0, 1, 4], [0, 2, 3], [0, 2, 4], [0, 3, 4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]</code>.');"
        },
        {
          "text":
            "<code>combinations(4, 6)</code> should return <code>[[0,1,2,3],  [0,1,2,4],  [0,1,2,5],  [0,1,3,4],  [0,1,3,5],  [0,1,4,5],  [0,2,3,4],  [0,2,3,5],  [0,2,4,5],  [0,3,4,5],  [1,2,3,4],  [1,2,3,5],  [1,2,4,5],  [1,3,4,5],  [2,3,4,5]]</code>",
          "testString":
            "assert.deepEqual(combinations(testInput2[0], testInput2[1]), testOutput2, '<code>combinations(4, 6)</code> should return <code>[[0,1,2,3],  [0,1,2,4],  [0,1,2,5],  [0,1,3,4],  [0,1,3,5],  [0,1,4,5],  [0,2,3,4],  [0,2,3,5],  [0,2,4,5],  [0,3,4,5],  [1,2,3,4],  [1,2,3,5],  [1,2,4,5],  [1,3,4,5],  [2,3,4,5]]</code>');"
        }
      ],
      "id": "5958469238c0d8d2632f46db",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function combinations (m, n) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const testInput1 = [3, 5];",
            "const testOutput1 = [[0, 1, 2], [0, 1, 3], [0, 1, 4], [0, 2, 3], [0, 2, 4], [0, 3, 4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]];",
            "",
            "const testInput2 = [4, 6];",
            "const testOutput2 = [[0, 1, 2, 3], [0, 1, 2, 4], [0, 1, 2, 5], [0, 1, 3, 4], [0, 1, 3, 5], [0, 1, 4, 5], [0, 2, 3, 4], [0, 2, 3, 5], [0, 2, 4, 5], [0, 3, 4, 5], [1, 2, 3, 4], [1, 2, 3, 5], [1, 2, 4, 5], [1, 3, 4, 5], [2, 3, 4, 5]];"
          ]
        }
      }
    },
    {
      "title": "Comma quibbling",
      "description": [
        "<p>Comma quibbling is a task originally set by Eric Lippert in his <a href=\"http://blogs.msdn.com/b/ericlippert/archive/2009/04/15/comma-quibbling.aspx\" title=\"link: http://blogs.msdn.com/b/ericlippert/archive/2009/04/15/comma-quibbling.aspx\">blog</a>.</p>",
        "Task:<p>Write a function to generate a string output which is the concatenation of input words from a list/sequence where:</p>",
        "An input of no words produces the output string of just the two brace characters \"{}\".",
        "An input of just one word, e.g. [\"ABC\"], produces the output string of the word inside the two braces, e.g. \"{ABC}\".",
        "An input of two words, e.g. [\"ABC\", \"DEF\"], produces the output string of the two words inside the two braces with the words separated by the string \" and \", e.g. \"{ABC and DEF}\".",
        "An input of three or more words, e.g. [\"ABC\", \"DEF\", \"G\", \"H\"], produces the output string of all but the last word separated by \", \" with the last word separated by \" and \" and all within braces; e.g. \"{ABC, DEF, G and H}\".",
        "<p>Test your function with the following series of inputs showing your output here on this page:</p>",
        "[]                       # (No input words).",
        "[\"ABC\"]",
        "[\"ABC\", \"DEF\"]",
        "[\"ABC\", \"DEF\", \"G\", \"H\"]",
        "<p>Note: Assume words are non-empty strings of uppercase characters for this task.</p>"
      ],
      "solutions": [
        "function quibble (words) {\n  return \"{\" +\n    words.slice(0, words.length - 1).join(\",\") +\n   (words.length > 1 ? \" and \" : \"\") +\n   (words[words.length - 1] || '') +\n  \"}\";\n}\n"
      ],
      "tests": [
        {
          "text": "<code>quibble</code> is a function.",
          "testString":
            "assert(typeof quibble === 'function', '<code>quibble</code> is a function.');"
        },
        {
          "text": "<code>quibble([\"ABC\"])</code> should return a string.",
          "testString":
            "assert(typeof quibble([\"ABC\"]) === 'string', '<code>quibble([\"ABC\"])</code> should return a string.');"
        },
        {
          "text": "<code>quibble([])</code> should return \"{}\".",
          "testString":
            "assert.equal(quibble(testCases[0]), results[0], '<code>quibble([])</code> should return \"{}\".');"
        },
        {
          "text": "<code>quibble([\"ABC\"])</code> should return \"{ABC}\".",
          "testString":
            "assert.equal(quibble(testCases[1]), results[1], '<code>quibble([\"ABC\"])</code> should return \"{ABC}\".');"
        },
        {
          "text":
            "<code>quibble([\"ABC\", \"DEF\"])</code> should return \"{ABC and DEF}\".",
          "testString":
            "assert.equal(quibble(testCases[2]), results[2], '<code>quibble([\"ABC\", \"DEF\"])</code> should return \"{ABC and DEF}\".');"
        },
        {
          "text":
            "<code>quibble([\"ABC\", \"DEF\", \"G\", \"H\"])</code> should return \"{ABC,DEF,G and H}\".",
          "testString":
            "assert.equal(quibble(testCases[3]), results[3], '<code>quibble([\"ABC\", \"DEF\", \"G\", \"H\"])</code> should return \"{ABC,DEF,G and H}\".');"
        }
      ],
      "id": "596e414344c3b2872167f0fe",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function quibble (words) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const testCases = [[], [\"ABC\"], [\"ABC\", \"DEF\"], [\"ABC\", \"DEF\", \"G\", \"H\"]];",
            "const results = [\"{}\", \"{ABC}\", \"{ABC and DEF}\", \"{ABC,DEF,G and H}\"];"
          ]
        }
      }
    },
    {
      "title": "Compare a list of strings",
      "description": [
        "<p>Given a  <a href=\"https://en.wikipedia.org/wiki/List_(abstract_data_type)\" title=\"wp: List_(abstract_data_type)\">list</a>  of arbitrarily many strings, implement a function for each of the following conditions:</p> test if they are all lexically equal",
        " test if every string is lexically less than the one after it  (i.e. whether the list is in strict ascending order)"
      ],
      "solutions": [
        "function allEqual(a) {\n  let out = true;\n  let i = 0;\n  while (++i < a.length) {\n    out = out && (a[i - 1] === a[i]);\n  } return out;\n}\n\nfunction azSorted(a) {\n  let out = true;\n  let i = 0;\n  while (++i < a.length) {\n    out = out && (a[i - 1] < a[i]);\n  } return out;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>allEqual</code> is a function.",
          "testString":
            "assert(typeof allEqual === 'function', '<code>allEqual</code> is a function.');"
        },
        {
          "text": "<code>azSorted</code> is a function.",
          "testString":
            "assert(typeof azSorted === 'function', '<code>azSorted</code> is a function.');"
        },
        {
          "text":
            "<code>allEqual([\"AA\", \"AA\", \"AA\", \"AA\"])</code> returns true.",
          "testString":
            "assert(allEqual(testCases[0]), '<code>allEqual([\"AA\", \"AA\", \"AA\", \"AA\"])</code> returns true.');"
        },
        {
          "text":
            "<code>azSorted([\"AA\", \"AA\", \"AA\", \"AA\"])</code> returns false.",
          "testString":
            "assert(!azSorted(testCases[0]), '<code>azSorted([\"AA\", \"AA\", \"AA\", \"AA\"])</code> returns false.');"
        },
        {
          "text":
            "<code>allEqual([\"AA\", \"ACB\", \"BB\", \"CC\"])</code> returns false.",
          "testString":
            "assert(!allEqual(testCases[1]), '<code>allEqual([\"AA\", \"ACB\", \"BB\", \"CC\"])</code> returns false.');"
        },
        {
          "text":
            "<code>azSorted([\"AA\", \"ACB\", \"BB\", \"CC\"])</code> returns true.",
          "testString":
            "assert(azSorted(testCases[1]), '<code>azSorted([\"AA\", \"ACB\", \"BB\", \"CC\"])</code> returns true.');"
        },
        {
          "text": "<code>allEqual([])</code> returns true.",
          "testString":
            "assert(allEqual(testCases[2]), '<code>allEqual([])</code> returns true.');"
        },
        {
          "text": "<code>azSorted([])</code> returns true.",
          "testString":
            "assert(azSorted(testCases[2]), '<code>azSorted([])</code> returns true.');"
        },
        {
          "text": "<code>allEqual([\"AA\"])</code> returns true.",
          "testString":
            "assert(allEqual(testCases[3]), '<code>allEqual([\"AA\"])</code> returns true.');"
        },
        {
          "text": "<code>azSorted([\"AA\"])</code> returns true.",
          "testString":
            "assert(azSorted(testCases[3]), '<code>azSorted([\"AA\"])</code> returns true.');"
        },
        {
          "text": "<code>allEqual([\"BB\", \"AA\"])</code> returns false.",
          "testString":
            "assert(!allEqual(testCases[4]), '<code>allEqual([\"BB\", \"AA\"])</code> returns false.');"
        },
        {
          "text": "<code>azSorted([\"BB\", \"AA\"])</code> returns false.",
          "testString":
            "assert(!azSorted(testCases[4]), '<code>azSorted([\"BB\", \"AA\"])</code> returns false.');"
        }
      ],
      "id": "596e457071c35c882915b3e4",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function allEqual (arr) {",
            "  // Good luck!",
            "  return true;",
            "}",
            "",
            "function azSorted (arr) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const testCases = [['AA', 'AA', 'AA', 'AA'], ['AA', 'ACB', 'BB', 'CC'], [], ['AA'], ['BB', 'AA']];"
          ]
        }
      }
    },
    {
      "title": "Convert seconds to compound duration",
      "description": [
        "Task:",
        "<p>Implement a function which:</p>",
        "takes a positive integer representing a duration in seconds as input (e.g., <code>100</code>), and",
        "returns a string which shows the same duration decomposed into weeks, days, hours, minutes, and seconds as detailed below (e.g., \"<code>1 min, 40 sec</code>\").",
        "<p>Demonstrate that it passes the following three test-cases:</p><p style=\"font-size:115%; margin:1em 0 0 0\">Test Cases</p>",
        "<table>",
        "<tbody>",
        "<tr>",
        "<th>input number</th>",
        "<th>output number</th>",
        "</tr>",
        "<tr>",
        "<td>7259</td>",
        "<td><code>2 hr, 59 sec</code></td>",
        "</tr>",
        "<tr>",
        "<td>86400</td>",
        "<td><code>1 d</code></td>",
        "</tr>",
        "<tr>",
        "<td>6000000</td>",
        "<td><code>9 wk, 6 d, 10 hr, 40 min</code></td>",
        "</tr>",
        "</tbody>",
        "</table>",
        "<p style=\"font-size:115%; margin:1em 0 0 0\">Details</p>",
        "The following five units should be used:",
        "<table>",
        "<tbody>",
        "<tr>",
        "<th>unit</th>",
        "<th>suffix used in output</th>",
        "<th>conversion</th>",
        "</tr>",
        "<tr>",
        "<td>week</td>",
        "<td><code>wk</code></td>",
        "<td>1 week = 7 days</td>",
        "</tr>",
        "<tr>",
        "<td>day</td>",
        "<td><code>d</code></td>",
        "<td>1 day = 24 hours</td>",
        "</tr>",
        "<tr>",
        "<td>hour</td>",
        "<td><code>hr</code></td>",
        "<td>1 hour = 60 minutes</td>",
        "</tr>",
        "<tr>",
        "<td>minute</td>",
        "<td><code>min</code></td>",
        "<td>1 minute = 60 seconds</td>",
        "</tr>",
        "<tr>",
        "<td>second</td>",
        "<td><code>sec</code></td>",
        "<td></td>",
        "</tr>",
        "</tbody>",
        "</table>",
        "However, only include quantities with non-zero values in the output (e.g., return \"<code>1 d</code>\" and not \"<code>0 wk, 1 d, 0 hr, 0 min, 0 sec</code>\").Give larger units precedence over smaller ones as much as possible (e.g., return <code>2 min, 10 sec</code> and not <code>1 min, 70 sec</code> or <code>130 sec</code>)Mimic the formatting shown in the test-cases (quantities sorted from largest unit to smallest and separated by comma+space; value and unit of each quantity separated by space).",
        "<p><hr style=\"margin:1em 0;\"/></p>"
      ],
      "solutions": [
        "function convertSeconds (sec) {\n  const localNames = ['wk', 'd', 'hr', 'min', 'sec'];\n  // compoundDuration :: [String] -> Int -> String\n  const compoundDuration = (labels, intSeconds) =>\n    weekParts(intSeconds)\n    .map((v, i) => [v, labels[i]])\n    .reduce((a, x) =>\n      a.concat(x[0] ? [`${x[0]} ${x[1] || '?'}`] : []), []\n    )\n    .join(', ');\n\n    // weekParts :: Int -> [Int]\n  const weekParts = intSeconds => [0, 7, 24, 60, 60]\n    .reduceRight((a, x) => {\n      const r = a.rem;\n      const mod = x !== 0 ? r % x : r;\n\n      return {\n        rem: (r - mod) / (x || 1),\n        parts: [mod].concat(a.parts)\n      };\n    }, {\n      rem: intSeconds,\n      parts: []\n    })\n    .parts;\n\n  return compoundDuration(localNames, sec);\n}\n"
      ],
      "tests": [
        {
          "text": "<code>convertSeconds</code> is a function.",
          "testString":
            "assert(typeof convertSeconds === 'function', '<code>convertSeconds</code> is a function.');"
        },
        {
          "text":
            "<code>convertSeconds(7259)</code> should return <code>2 hr, 59 sec</code>.",
          "testString":
            "assert.equal(convertSeconds(testCases[0]), results[0], '<code>convertSeconds(7259)</code> should return <code>2 hr, 59 sec</code>.');"
        },
        {
          "text":
            "<code>convertSeconds(86400)</code> should return <code>1 d</code>.",
          "testString":
            "assert.equal(convertSeconds(testCases[1]), results[1], '<code>convertSeconds(86400)</code> should return <code>1 d</code>.');"
        },
        {
          "text":
            "<code>convertSeconds(6000000)</code> should return <code>9 wk, 6 d, 10 hr, 40 min</code>.",
          "testString":
            "assert.equal(convertSeconds(testCases[2]), results[2], '<code>convertSeconds(6000000)</code> should return <code>9 wk, 6 d, 10 hr, 40 min</code>.');"
        }
      ],
      "id": "596fd036dc1ab896c5db98b1",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function convertSeconds (sec) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const testCases = [7259, 86400, 6000000];",
            "const results = ['2 hr, 59 sec', '1 d', '9 wk, 6 d, 10 hr, 40 min'];"
          ]
        }
      }
    },
    {
      "title": "Count occurrences of a substring",
      "description": [
        "Task:",
        "<p>Create a function,  or show a built-in function,  to count the number of non-overlapping occurrences of a substring inside a string.</p><p>The function should take two arguments:</p>",
        "the first argument being the string to search,  and",
        "the second a substring to be searched for.",
        "<p>It should return an integer count.</p>",
        "<p>The matching should yield the highest number of non-overlapping matches.</p><p>In general, this essentially means matching from left-to-right or right-to-left.</p>"
      ],
      "solutions": [
        "function countSubstring(str, subStr) {\n  const escapedSubStr = subStr.replace(/[.+*?^$[\\]{}()|/]/g, '\\\\$&');\n  const matches = str.match(new RegExp(escapedSubStr, 'g'));\n  return matches ? matches.length : 0;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>countSubstring</code> is a function.",
          "testString":
            "assert(typeof countSubstring === 'function', '<code>countSubstring</code> is a function.');"
        },
        {
          "text":
            "<code>countSubstring(\"the three truths\", \"th\")</code> should return <code>3</code>.",
          "testString":
            "assert.equal(countSubstring(testCases[0], searchString[0]), results[0], '<code>countSubstring(\"the three truths\", \"th\")</code> should return <code>3</code>.');"
        },
        {
          "text":
            "<code>countSubstring(\"ababababab\", \"abab\")</code> should return <code>2</code>.",
          "testString":
            "assert.equal(countSubstring(testCases[1], searchString[1]), results[1], '<code>countSubstring(\"ababababab\", \"abab\")</code> should return <code>2</code>.');"
        },
        {
          "text":
            "<code>countSubstring(\"abaabba*bbaba*bbab\", \"a*b\")</code> should return <code>2</code>.",
          "testString":
            "assert.equal(countSubstring(testCases[2], searchString[2]), results[2], '<code>countSubstring(\"abaabba*bbaba*bbab\", \"a*b\")</code> should return <code>2</code>.');"
        }
      ],
      "id": "596fda99c69f779975a1b67d",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function countSubstring (str, subStr) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const testCases = ['the three truths', 'ababababab', 'abaabba*bbaba*bbab'];",
            "const searchString = ['th', 'abab', 'a*b'];",
            "const results = [3, 2, 2];"
          ]
        }
      }
    },
    {
      "title": "Count the coins",
      "description": [
        "<p>There are four types of common coins in <a href=\"https://en.wikipedia.org/wiki/United_States\" title=\"link: https://en.wikipedia.org/wiki/United_States\">US</a> currency:</p>",
        "quarters (25 cents)",
        "dimes (10 cents)",
        "nickels (5 cents),  and ",
        "pennies (1 cent)  ",
        "<p>There are six ways to make change for 15 cents:</p>",
        "A dime and a nickel ",
        "A dime and 5 pennies",
        "3 nickels",
        "2 nickels and 5 pennies",
        "A nickel and 10 pennies",
        "15 pennies",
        "Task:",
        "<p>Implement a function to determine how many ways there are to make change for a dollar using these common coins? (1 dollar = 100 cents).</p>",
        "Reference:",
        " <a href=\"http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_Temp_52\" title=\"link: http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_Temp_52\">an algorithm from MIT Press</a>. "
      ],
      "solutions": [
        "function countCoins () {\n  let t = 100;\n  const operands = [1, 5, 10, 25];\n  const targetsLength = t + 1;\n  const operandsLength = operands.length;\n  t = [1];\n\n  for (let a = 0; a < operandsLength; a++) {\n    for (let b = 1; b < targetsLength; b++) {\n      // initialise undefined target\n      t[b] = t[b] ? t[b] : 0;\n\n      // accumulate target + operand ways\n      t[b] += (b < operands[a]) ? 0 : t[b - operands[a]];\n    }\n  }\n\n  return t[targetsLength - 1];\n}\n"
      ],
      "tests": [
        {
          "text": "<code>countCoins</code> is a function.",
          "testString":
            "assert(typeof countCoins === 'function', '<code>countCoins</code> is a function.');"
        },
        {
          "text": "<code>countCoints()</code> should return 242.",
          "testString":
            "assert.equal(countCoins(), 242, '<code>countCoints()</code> should return 242.');"
        }
      ],
      "id": "59713bd26bdeb8a594fb9413",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function countCoins () {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Cramer's rule",
      "description": [
        "<p>In <a href=\"https://en.wikipedia.org/wiki/linear algebra\" title=\"wp: linear algebra\">linear algebra</a>, <a href=\"https://en.wikipedia.org/wiki/Cramer's rule\" title=\"wp: Cramer's rule\">Cramer's rule</a> is an explicit formula for the solution of a <a href=\"https://en.wikipedia.org/wiki/system of linear equations\" title=\"wp: system of linear equations\">system of linear equations</a> with as many equations as unknowns, valid whenever the system has a unique solution. It expresses the solution in terms of the determinants of the (square) coefficient matrix and of matrices obtained from it by replacing one column by the vector of right hand sides of the equations.</p>",
        "<p>Given</p>",
        "<p><big></p>",
        "<p> $\\left\\{\\begin{matrix}a_1x + b_1y + c_1z&= {\\color{red}d_1}\\\\a_2x + b_2y + c_2z&= {\\color{red}d_2}\\\\a_3x + b_3y + c_3z&= {\\color{red}d_3}\\end{matrix}\\right.$</p>",
        "</big><p>which in matrix format is</p><p><big></p>",
        "<p> $\\begin{bmatrix} a_1 & b_1 & c_1 \\\\ a_2 & b_2 & c_2 \\\\ a_3 & b_3 & c_3 \\end{bmatrix}\\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix}=\\begin{bmatrix} {\\color{red}d_1} \\\\ {\\color{red}d_2} \\\\ {\\color{red}d_3} \\end{bmatrix}.$</p>",
        "</big><p>Then the values of $x, y$ and $z$ can be found as follows:</p><p><big></p>",
        "<p>$x = \\frac{\\begin{vmatrix} {\\color{red}d_1} & b_1 & c_1 \\\\ {\\color{red}d_2} & b_2 & c_2 \\\\ {\\color{red}d_3} & b_3 & c_3 \\end{vmatrix} } { \\begin{vmatrix} a_1 & b_1 & c_1 \\\\ a_2 & b_2 & c_2 \\\\ a_3 & b_3 & c_3 \\end{vmatrix}}, \\quad y = \\frac {\\begin{vmatrix} a_1 & {\\color{red}d_1} & c_1 \\\\ a_2 & {\\color{red}d_2} & c_2 \\\\ a_3 & {\\color{red}d_3} & c_3 \\end{vmatrix}} {\\begin{vmatrix} a_1 & b_1 & c_1 \\\\ a_2 & b_2 & c_2 \\\\ a_3 & b_3 & c_3 \\end{vmatrix}}, \\text{ and }z = \\frac { \\begin{vmatrix} a_1 & b_1 & {\\color{red}d_1} \\\\ a_2 & b_2 & {\\color{red}d_2} \\\\ a_3 & b_3 & {\\color{red}d_3} \\end{vmatrix}} {\\begin{vmatrix} a_1 & b_1 & c_1 \\\\ a_2 & b_2 & c_2 \\\\ a_3 & b_3 & c_3 \\end{vmatrix} }.$</p>",
        "</big>",
        "Task",
        "<p>Given the following system of equations:</p><p><big>",
        "$\\begin{cases}",
        "2w-x+5y+z=-3 \\\\",
        "3w+2x+2y-6z=-32 \\\\",
        "w+3x+3y-z=-47 \\\\",
        "5w-2x-3y+3z=49 \\\\",
        "\\end{cases}$",
        "</big></p>",
        "<p>solve for <big>$w$, $x$, $y$</big> and <big>$z$</big>, using Cramer's rule.</p>"
      ],
      "solutions": [
        "/**\n * Compute Cramer's Rule\n * @param  {array} matrix    x,y,z, etc. terms\n * @param  {array} freeTerms\n * @return {array}           solution for x,y,z, etc.\n */\nfunction cramersRule(matrix, freeTerms) {\n  const det = detr(matrix);\n  const returnArray = [];\n  let i;\n\n  for (i = 0; i < matrix[0].length; i++) {\n    const tmpMatrix = insertInTerms(matrix, freeTerms, i);\n    returnArray.push(detr(tmpMatrix) / det);\n  }\n  return returnArray;\n}\n\n/**\n * Inserts single dimensional array into\n * @param  {array} matrix multidimensional array to have ins inserted into\n * @param  {array} ins single dimensional array to be inserted vertically into matrix\n * @param  {array} at  zero based offset for ins to be inserted into matrix\n * @return {array}     New multidimensional array with ins replacing the at column in matrix\n */\nfunction insertInTerms(matrix, ins, at) {\n  const tmpMatrix = clone(matrix);\n  let i;\n  for (i = 0; i < matrix.length; i++) {\n    tmpMatrix[i][at] = ins[i];\n  }\n  return tmpMatrix;\n}\n/**\n * Compute the determinate of a matrix.  No protection, assumes square matrix\n * function borrowed, and adapted from MIT Licensed numericjs library (www.numericjs.com)\n * @param  {array} m Input Matrix (multidimensional array)\n * @return {number}   result rounded to 2 decimal\n */\nfunction detr(m) {\n  let ret = 1;\n  let j;\n  let k;\n  const A = clone(m);\n  const n = m[0].length;\n  let alpha;\n\n  for (j = 0; j < n - 1; j++) {\n    k = j;\n    for (let i = j + 1; i < n; i++) { if (Math.abs(A[i][j]) > Math.abs(A[k][j])) { k = i; } }\n    if (k !== j) {\n      const temp = A[k]; A[k] = A[j]; A[j] = temp;\n      ret *= -1;\n    }\n    const Aj = A[j];\n    for (let i = j + 1; i < n; i++) {\n      const Ai = A[i];\n      alpha = Ai[j] / Aj[j];\n      for (k = j + 1; k < n - 1; k += 2) {\n        const k1 = k + 1;\n        Ai[k] -= Aj[k] * alpha;\n        Ai[k1] -= Aj[k1] * alpha;\n      }\n      if (k !== n) { Ai[k] -= Aj[k] * alpha; }\n    }\n    if (Aj[j] === 0) { return 0; }\n    ret *= Aj[j];\n  }\n  return Math.round(ret * A[j][j] * 100) / 100;\n}\n\n/**\n * Clone two dimensional Array using ECMAScript 5 map function and EcmaScript 3 slice\n * @param  {array} m Input matrix (multidimensional array) to clone\n * @return {array}   New matrix copy\n */\nfunction clone(m) {\n  return m.map(a => a.slice());\n}\n"
      ],
      "tests": [
        {
          "text": "<code>cramersRule</code> is a function.",
          "testString":
            "assert(typeof cramersRule === 'function', '<code>cramersRule</code> is a function.');"
        },
        {
          "text":
            "<code>cramersRule([[2, -1, 5, 1], [3, 2, 2, -6], [1, 3, 3, -1], [5, -2, -3, 3]], [-3, -32, -47, 49])</code> should return <code>[2, -12, -4, 1]</code>.",
          "testString":
            "assert.deepEqual(cramersRule(matrices[0], freeTerms[0]), answers[0], '<code>cramersRule([[2, -1, 5, 1], [3, 2, 2, -6], [1, 3, 3, -1], [5, -2, -3, 3]], [-3, -32, -47, 49])</code> should return <code>[2, -12, -4, 1]</code>.');"
        },
        {
          "text":
            "<code>cramersRule([[3, 1, 1], [2, 2, 5], [1, -3, -4]], [3, -1, 2])</code> should return <code>[1, 1, -1]</code>.",
          "testString":
            "assert.deepEqual(cramersRule(matrices[1], freeTerms[1]), answers[1], '<code>cramersRule([[3, 1, 1], [2, 2, 5], [1, -3, -4]], [3, -1, 2])</code> should return <code>[1, 1, -1]</code>.');"
        }
      ],
      "id": "59713da0a428c1a62d7db430",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function cramersRule (matrix, freeTerms) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const matrices = [",
            "  [",
            "    [2, -1, 5, 1],",
            "    [3, 2, 2, -6],",
            "    [1, 3, 3, -1],",
            "    [5, -2, -3, 3]",
            "  ],",
            "  [",
            "    [3, 1, 1],",
            "    [2, 2, 5],",
            "    [1, -3, -4]",
            "  ]",
            "];",
            "const freeTerms = [[-3, -32, -47, 49], [3, -1, 2]];",
            "",
            "const answers = [[2, -12, -4, 1], [1, 1, -1]];"
          ]
        }
      }
    },
    {
      "title": "Cumulative standard deviation",
      "description": [
        "Write a function that takes an array of numbers as parameter and returns the <a href=\"https://en.wikipedia.org/wiki/Standard Deviation\">standard deviation</a> of the series."
      ],
      "solutions": [
        "function standardDeviation (arr) {\n  var sum = 0,\n    sum_sq = 0,\n    n = arr.length;\n  arr.forEach(function(e) {\n    sum += e;\n    sum_sq += e * e;\n  })\n\n  var std_dev=Math.sqrt((sum_sq / n) - Math.pow(sum / n, 2))\n  return Math.round(std_dev*1000)/1000;\n}\n\n"
      ],
      "tests": [
        {
          "text": "'<code>standardDeviation</code> should be a function.'",
          "testString":
            "assert(typeof standardDeviation=='function','<code>standardDeviation</code> should be a function.');"
        },
        {
          "text":
            "'<code>standardDeviation('+JSON.stringify(stdDevTests[0])+')</code> should return a number.'",
          "testString":
            "assert(typeof standardDeviation(stdDevTests[0]) == 'number','<code>standardDeviation('+JSON.stringify(stdDevTests[0])+')</code> should return a number.');"
        },
        {
          "text":
            "'<code>standardDeviation('+JSON.stringify(stdDevTests[0])+')</code> should return <code>2</code>.'",
          "testString":
            "assert.equal(standardDeviation(stdDevTests[0]),2,'<code>standardDeviation('+JSON.stringify(stdDevTests[0])+')</code> should return <code>2</code>.');"
        },
        {
          "text":
            "'<code>standardDeviation('+JSON.stringify(stdDevTests[1])+')</code> should return <code>147.323</code>.'",
          "testString":
            "assert.equal(standardDeviation(stdDevTests[1]),147.323,'<code>standardDeviation('+JSON.stringify(stdDevTests[1])+')</code> should return <code>147.323</code>.');"
        },
        {
          "text":
            "'<code>standardDeviation('+JSON.stringify(stdDevTests[2])+')</code> should return <code>18.239</code>.'",
          "testString":
            "assert.equal(standardDeviation(stdDevTests[2]),18.239,'<code>standardDeviation('+JSON.stringify(stdDevTests[2])+')</code> should return <code>18.239</code>.');"
        },
        {
          "text":
            "'<code>standardDeviation('+JSON.stringify(stdDevTests[3])+')</code> should return <code>16.87</code>.'",
          "testString":
            "assert.equal(standardDeviation(stdDevTests[3]),16.87,'<code>standardDeviation('+JSON.stringify(stdDevTests[3])+')</code> should return <code>16.87</code>.');"
        },
        {
          "text":
            "'<code>standardDeviation('+JSON.stringify(stdDevTests[4])+')</code> should return <code>22.631</code>.'",
          "testString":
            "assert.equal(standardDeviation(stdDevTests[4]),22.631,'<code>standardDeviation('+JSON.stringify(stdDevTests[4])+')</code> should return <code>22.631</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7e03",
      "challengeType": 5,
      "releasedOn": "September 1, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function standardDeviation (arr) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var stdDevTests=[",
            "[2,4,4,4,5,5,7,9],",
            "[600,470,170,430,300],",
            "[75,83,96,100,121,125],",
            "[23,37,45,49,56,63,63,70,72,82],",
            "[271,354,296,301,333,326,285,298,327,316,287,314]]"
          ]
        }
      }
    },
    {
      "title": "Cut a rectangle",
      "description": [
        "A given rectangle is made from <i>m</i> × <i>n</i> squares. If <i>m</i> and <i>n</i> are not both odd, then it is possible to cut a path through the rectangle along the square edges such that the rectangle splits into two connected pieces with the same shape (after rotating one of the pieces by 180°). All such paths for 2 × 2 and 4 × 3 rectangles are shown below.",
        "<a href=\"http://rosettacode.org/wiki/file:rect-cut.svg\">file:rect-cut.svg</a>",
        "Write a function that calculates the number of different ways to cut an <i>m</i> × <i>n</i> rectangle."
      ],
      "solutions": [
        "function cutRectangle (w, h) {\n  if (w % 2 == 1 && h % 2 == 1)\n    return;\n\n  var dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]];\n\n  var grid = new Array(h); for (var i = 0; i < grid.length; i++) grid[i]=new Array(w);\n  var stack = [];\n\n  var half = Math.floor((w * h) / 2);\n  var bits = Math.pow(2, half) - 1;\n  var result=0;\n  for (; bits > 0; bits -= 2) {\n\n    for (var i = 0; i < half; i++) {\n      var r = Math.floor(i / w);\n      var c = i % w;\n      grid[r][c] = (bits & (1 << i)) != 0 ? 1 : 0;\n      grid[h - r - 1][w - c - 1] = 1 - grid[r][c];\n    }\n\n    stack.push(0);\n    grid[0][0] = 2;\n    var count = 1;\n    while (stack.length!=0) {\n\n      var pos = stack.pop();\n      var r = Math.floor(pos / w);\n      var c = pos % w;\n\n      for (var dir of dirs) {\n        var nextR = r + dir[0];\n        var nextC = c + dir[1];\n\n        if (nextR >= 0 && nextR < h && nextC >= 0 && nextC < w) {\n\n          if (grid[nextR][nextC] == 1) {\n            stack.push(nextR * w + nextC);\n            grid[nextR][nextC] = 2;\n            count++;\n          }\n        }\n      }\n    }\n\n    if (count == half) {\n      result++;\n    }\n  }\n\n  return result;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>cutRectangle</code> should be a function.'",
          "testString":
            "assert(typeof cutRectangle=='function','<code>cutRectangle</code> should be a function.');"
        },
        {
          "text": "'<code>cutRectangle(2,2)</code> should return a number.'",
          "testString":
            "assert(typeof cutRectangle(2,2) == 'number','<code>cutRectangle(2,2)</code> should return a number.');"
        },
        {
          "text":
            "'<code>cutRectangle(2,2)</code> should return <code>2</code>.'",
          "testString":
            "assert.equal(cutRectangle(2,2),2,'<code>cutRectangle(2,2)</code> should return <code>2</code>.');"
        },
        {
          "text":
            "'<code>cutRectangle(4,3)</code> should return <code>9</code>.'",
          "testString":
            "assert.equal(cutRectangle(4,3),9,'<code>cutRectangle(4,3)</code> should return <code>9</code>.');"
        },
        {
          "text":
            "'<code>cutRectangle(4,4)</code> should return <code>22</code>.'",
          "testString":
            "assert.equal(cutRectangle(4,4),22,'<code>cutRectangle(4,4)</code> should return <code>22</code>.');"
        },
        {
          "text":
            "'<code>cutRectangle(8,3)</code> should return <code>53</code>.'",
          "testString":
            "assert.equal(cutRectangle(8,3),53,'<code>cutRectangle(8,3)</code> should return <code>53</code>.');"
        },
        {
          "text":
            "'<code>cutRectangle(7,4)</code> should return <code>151</code>.'",
          "testString":
            "assert.equal(cutRectangle(7,4),151,'<code>cutRectangle(7,4)</code> should return <code>151</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7e06",
      "challengeType": 5,
      "releasedOn": "September 1, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function cutRectangle (w, h) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Date format",
      "description": [
        "Task:",
        "<p>Return an array with the current date in the formats:</p>",
        "<p>-   2007-11-23   and </p>",
        "<p>-   Sunday, November 23, 2007</p>",
        "<p>Example output: <code>['2007-11-23', 'Sunday, November 23, 2007']</code></p>"
      ],
      "solutions": [
        "function getDateFormats () {\n  const date = new Date();\n  const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n  const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\n  const fmt1 = `${date.getFullYear()}-${(1 + date.getMonth())}-${date.getDate()}`;\n  const fmt2 = `${weekdays[date.getDay()]}, ${months[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;\n  return [fmt1, fmt2];\n}\n"
      ],
      "tests": [
        {
          "text": "<code>getDateFormats</code> is a function.",
          "testString":
            "assert(typeof getDateFormats === 'function', '<code>getDateFormats</code> is a function.');"
        },
        {
          "text": "Should return an object.",
          "testString":
            "assert(typeof getDateFormats() === 'object', 'Should return an object.');"
        },
        {
          "text": "Should returned an array with 2 elements.",
          "testString":
            "assert(getDateFormats().length === 2, 'Should returned an array with 2 elements.');"
        },
        {
          "text": "Should return the correct date in the right format",
          "testString":
            "assert.deepEqual(getDateFormats(), dates, equalsMessage);"
        }
      ],
      "id": "59669d08d75b60482359409f",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function getDateFormats () {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const getDateSolution = () => {",
            "  const date = new Date();",
            "  const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];",
            "  const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];",
            "  const fmt1 = `${date.getFullYear()}-${(1 + date.getMonth())}-${date.getDate()}`;",
            "  const fmt2 = `${weekdays[date.getDay()]}, ${months[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;",
            "  return [fmt1, fmt2];",
            "};",
            "",
            "const dates = getDateSolution();",
            "const equalsMessage = `message: <code>getDataFormats()</code> should return <code>[\"${dates[0]}\", \"${dates[1]}\"]</code>.`;"
          ]
        }
      }
    },
    {
      "title": "Date manipulation",
      "description": [
        "Task:",
        "<p>Given a date string in EST, output the given date as a string with 12 hours added to the time. </p>",
        "<p>Time zone should be preserved.</p>",
        "<p>Example input: </p>",
        "<p><code>\"March 7 2009 7:30pm EST\"</code></p>",
        "<p>Example output: </p>",
        "<p><code>\"March 8 2009 7:30am EST\"</code></p>"
      ],
      "solutions": [
        "function add12Hours (dateString) {\n  const months = ['January', 'February', 'March', 'April', 'May', 'June',\n    'July', 'August', 'September', 'October', 'November', 'December'];\n  // Get the parts of the string\n  const parts = dateString.split(' ');\n  const month = months.indexOf(parts[0]);\n  const day = parseInt(parts[1], 10);\n  const year = parseInt(parts[2], 10);\n  const time = parts[3].split(':');\n  let hours = parseInt(time[0], 10);\n  if (time[1].slice(-2) === 'pm') {\n    hours += 12;\n  }\n  const minutes = parseInt(time[1].slice(0, -2), 10);\n\n  // Create a date with given parts, and updated hours\n  const date = new Date();\n  date.setFullYear(year, month, day);\n  date.setHours(hours + 12);  // Add 12 hours\n  date.setMinutes(minutes);\n\n  let hoursOutput = date.getHours();\n  let abbreviation = 'am';\n  if (hoursOutput > 12) {\n    hoursOutput -= 12;\n    abbreviation = 'pm';\n  }\n\n  return `${months[date.getMonth()]} ${date.getDate()} ${date.getFullYear()} ${hoursOutput}:${date.getMinutes()}${abbreviation} EST`;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>add12Hours</code> is a function.",
          "testString":
            "assert(typeof add12Hours === 'function', '<code>add12Hours</code> is a function.');"
        },
        {
          "text": "<code>add12Hours(dateString)</code> should return a string.",
          "testString":
            "assert(typeof add12Hours(tests[0]) === 'string', '<code>add12Hours(dateString)</code> should return a string.');"
        },
        {
          "text":
            "<code>add12Hours(\"' + tests[0] + '\")</code> should return <code>\"' + answers[0] + '\"</code>",
          "testString":
            "assert(add12Hours(tests[0]) === answers[0], '<code>add12Hours(\"' + tests[0] + '\")</code> should return <code>\"' + answers[0] + '\"</code>');"
        },
        {
          "text":
            "Should handel day change. <code>add12Hours(\"' + tests[1] + '\")</code> should return <code>\"' + answers[1] + '\"</code>",
          "testString":
            "assert(add12Hours(tests[1]) === answers[1], 'Should handel day change. <code>add12Hours(\"' + tests[1] + '\")</code> should return <code>\"' + answers[1] + '\"</code>');"
        },
        {
          "text":
            "Should handel month change in a leap years. <code>add12Hours(\"' + tests[2] + '\")</code> should return <code>\"' + answers[2] + '\"</code>",
          "testString":
            "assert(add12Hours(tests[2]) === answers[2], 'Should handel month change in a leap years. <code>add12Hours(\"' + tests[2] + '\")</code> should return <code>\"' + answers[2] + '\"</code>');"
        },
        {
          "text":
            "Should handel month change in a common years. <code>add12Hours(\"' + tests[3] + '\")</code> should return <code>\"' + answers[3] + '\"</code>",
          "testString":
            "assert(add12Hours(tests[3]) === answers[3], 'Should handel month change in a common years. <code>add12Hours(\"' + tests[3] + '\")</code> should return <code>\"' + answers[3] + '\"</code>');"
        },
        {
          "text":
            "Should handel year change. <code>add12Hours(\"' + tests[4] + '\")</code> should return <code>\"' + answers[4] + '\"</code>",
          "testString":
            "assert(add12Hours(tests[4]) === answers[4], 'Should handel year change. <code>add12Hours(\"' + tests[4] + '\")</code> should return <code>\"' + answers[4] + '\"</code>');"
        }
      ],
      "id": "5966c21cf732a95f1b67dd28",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function add12Hours (dateString) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const tests = [",
            "  'January 17 2017 11:43am EST',",
            "  'March 7 2009 7:30pm EST',",
            "  'February 29 2004 9:15pm EST',",
            "  'February 28 1999 3:15pm EST',",
            "  'December 31 2020 1:45pm EST'",
            "];",
            "const answers = [",
            "  'January 17 2017 11:43pm EST',",
            "  'March 8 2009 7:30am EST',",
            "  'March 1 2004 9:15am EST',",
            "  'March 1 1999 3:15am EST',",
            "  'January 1 2021 1:45am EST'",
            "];"
          ]
        }
      }
    },
    {
      "title": "Day of the week",
      "description": [
        "<p>A company decides that whenever Xmas falls on a Sunday they will give their workers all extra paid holidays so that, together with any public holidays, workers will not have to work the following week (between the 25th of December and the first of January).</p>",
        "<p>Task:</p>",
        "<p>Write a function that takes a start year and an end year and return an array of all the years where the 25th of December will be a Sunday.</p>"
      ],
      "solutions": [
        "function findXmasSunday (start, end) {\n  const xmasSunday = [];\n  for (let year = start; year <= end; year++) {\n    const xmas = new Date(year, 11, 25);\n    if (xmas.getDay() === 0) {\n      xmasSunday.push(year);\n    }\n  }\n  return xmasSunday;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>findXmasSunday</code> is a function.",
          "testString":
            "assert(typeof findXmasSunday === 'function', '<code>findXmasSunday</code> is a function.');"
        },
        {
          "text":
            "<code>findChristmasSunday(2000, 2100)</code> should return an array.",
          "testString":
            "assert(typeof findXmasSunday(2000, 2100) === 'object', '<code>findChristmasSunday(2000, 2100)</code> should return an array.');"
        },
        {
          "text":
            "<code>findChristmasSunday(2008, 2121</code> should return [1977, 1983, 1988, 1994, 2005, 2011, 2016]",
          "testString":
            "assert.deepEqual(findXmasSunday(1970, 2017), firstSolution, '<code>findChristmasSunday(2008, 2121</code> should return [1977, 1983, 1988, 1994, 2005, 2011, 2016]');"
        },
        {
          "text":
            "<code>findChristmasSunday(2008, 2121</code> should return [2011, 2016, 2022, 2033, 2039, 2044, 2050, 2061, 2067, 2072, 2078, 2089, 2095, 2101, 2107, 2112, 2118]",
          "testString":
            "assert.deepEqual(findXmasSunday(2008, 2121), secondSolution, '<code>findChristmasSunday(2008, 2121</code> should return [2011, 2016, 2022, 2033, 2039, 2044, 2050, 2061, 2067, 2072, 2078, 2089, 2095, 2101, 2107, 2112, 2118]');"
        }
      ],
      "id": "5966f99c45e8976909a85575",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function findXmasSunday (start, end) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const firstSolution = [1977, 1983, 1988, 1994, 2005, 2011, 2016];",
            "const secondSolution = [2011, 2016, 2022, 2033, 2039, 2044, 2050, 2061, 2067, 2072, 2078, 2089, 2095, 2101, 2107, 2112, 2118];"
          ]
        }
      }
    },
    {
      "title": "Deal cards for FreeCell",
      "description": [
        "<p>Free Cell is the solitaire card game that Paul Alfille introduced to the PLATO system in 1978. Jim Horne, at Microsoft, changed the name to FreeCell and reimplemented the game for <a href=\"http://rosettacode.org/wiki/DOS\" title=\"DOS\">DOS</a>, then <a href=\"http://rosettacode.org/wiki/Windows\" title=\"Windows\">Windows</a>. </p>",
        "<p>This version introduced 32000 numbered deals. (The <a href=\"http://www.solitairelaboratory.com/fcfaq.html\" title=\"link: http://www.solitairelaboratory.com/fcfaq.html\">FreeCell FAQ</a> tells this history.)</p><p>As the game became popular, Jim Horne disclosed <a href=\"http://www.solitairelaboratory.com/mshuffle.txt\" title=\"link: http://www.solitairelaboratory.com/mshuffle.txt\">the algorithm</a>, and other implementations of FreeCell began to reproduce the Microsoft deals. </p>",
        "<p>These deals are numbered from 1 to 32000.</p>",
        "<p>Newer versions from Microsoft have 1 million deals, numbered from 1 to 1000000; some implementations allow numbers outside that range.</p><p>The algorithm uses this <a href=\"http://rosettacode.org/wiki/linear congruential generator\" title=\"linear congruential generator\">linear congruential generator</a> from Microsoft C:</p>$state_{n + 1} \\equiv 214013 \\times state_n + 2531011 \\pmod{2^{31}}$",
        "$rand_n = state_n \\div 2^{16}$",
        "$rand_n$ is in range 0 to 32767.",
        "<p>The algorithm follows:</p>Seed the RNG with the number of the deal.",
        "Create an <a href=\"http://rosettacode.org/wiki/array\" title=\"array\">array</a> of 52 cards: Ace of Clubs, Ace of Diamonds, Ace of Hearts, Ace of Spades, 2 of Clubs, 2 of Diamonds, and so on through the ranks: Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King. The array indexes are 0 to 51, with Ace of Clubs at 0, and King of Spades at 51.",
        "Until the array is empty:",
        " Choose a random card at index &equiv; next random number (mod array length). ",
        " Swap this random card with the last card of the array.",
        " Remove this random card from the array. (Array length goes down by 1.)",
        " Deal this random card.",
        "Deal all 52 cards, face up, across 8 columns. The first 8 cards go in 8 columns, the next 8 cards go on the first 8 cards, and so on.",
        "Example:",
        "<p>Order to deal cards</p>",
        "<p><pre> 1  2  3  4  5  6  7  8",
        " 9 10 11 12 13 14 15 16",
        "17 18 19 20 21 22 23 24",
        "25 26 27 28 29 30 31 32",
        "33 34 35 36 37 38 39 40",
        "41 42 43 44 45 46 47 48",
        "49 50 51 52</pre></p>",
        "<p>Game #1</p>",
        "<p><pre>[",
        "['JD', '2D', '9H', 'JC', '5D', '7H', '7C', '5H'],",
        "['KD', 'KC', '9S', '5S', 'AD', 'QC', 'KH', '3H'],",
        "['2S', 'KS', '9D', 'QD', 'JS', 'AS', 'AH', '3C'],",
        "['4C', '5C', 'TS', 'QH', '4H', 'AC', '4D', '7S'],",
        "['3S', 'TD', '4S', 'TH', '8H', '2C', 'JH', '7D'],",
        "['6D', '8S', '8D', 'QS', '6C', '3D', '8C', 'TC'],",
        "['6S', '9C', '2H', '6H']",
        "]</pre></p>",
        "<p>Game #617</p>",
        "<p><pre>[",
        "['7D', 'AD', '5C', '3S', '5S', '8C', '2D', 'AH'],",
        "['TD', '7S', 'QD', 'AC', '6D', '8H', 'AS', 'KH'],",
        "['TH', 'QC', '3H', '9D', '6S', '8D', '3D', 'TC'],",
        "['KD', '5H', '9S', '3C', '8S', '7H', '4D', 'JS'],",
        "['4C', 'QS', '9C', '9H', '7C', '6H', '2C', '2S'],",
        "['4S', 'TS', '2H', '5D', 'JC', '6C', 'JH', 'QH'],",
        "['JD', 'KS', 'KC', '4H']",
        "]</pre></p>",
        "Task:",
        "<p>Write a function to take a deal number and deal cards in the same order as this algorithm.</p>",
        "<p>The function must return a two dimensional array representing the FreeCell board.</p>",
        "<p>Deals can also be checked against <a href=\"http://freecellgamesolutions.com/\" title=\"link: http://freecellgamesolutions.com/\">FreeCell solutions to 1000000 games</a>.</p>",
        "<p>(Summon a video solution, and it displays the initial deal.)</p>"
      ],
      "solutions": [
        "// RNG\nfunction FreeCellRNG (seed) {\n  return {\n    lastNum: seed,\n    next() {\n      this.lastNum = ((214013 * this.lastNum) + 2531011) % (Math.pow(2, 31));\n      return this.lastNum >> 16;\n    }\n  };\n}\n// Get cards\nfunction getDeck() {\n  const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K'];\n  const suits = ['C', 'D', 'H', 'S'];\n  const cards = [];\n  for (let i = 0; i < ranks.length; i += 1) {\n    for (let j = 0; j < suits.length; j += 1) {\n      cards.push(`${ranks[i]}${suits[j]}`);\n    }\n  }\n  return cards;\n}\nfunction dealFreeCell(seed) {\n  const rng = FreeCellRNG(seed);\n  const deck = getDeck();\n\n  const deltCards = [[], [], [], [], [], [], []];\n  let currentColumn = 0;\n  let currentRow = 0;\n\n  let rand;\n  let temp;\n  let card;\n  while (deck.length > 0) {\n    // Choose a random card\n    rand = rng.next() % deck.length;\n\n    // Swap this random card with the last card in the array\n    temp = deck[deck.length - 1];\n    deck[deck.length - 1] = deck[rand];\n    deck[rand] = temp;\n\n    // Remove this card from the array\n    card = deck.pop();\n\n    // Deal this card\n    deltCards[currentRow].push(card);\n    currentColumn += 1;\n    if (currentColumn === 8) {\n      currentColumn = 0;\n      currentRow += 1;\n    }\n  }\n\n  return deltCards;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>dealFreeCell</code> is a function.",
          "testString":
            "assert(typeof dealFreeCell === 'function', '<code>dealFreeCell</code> is a function.');"
        },
        {
          "text": "<code>dealFreeCell(seed)</code> should return an object.",
          "testString":
            "assert(typeof dealFreeCell(1) === 'object', '<code>dealFreeCell(seed)</code> should return an object.');"
        },
        {
          "text":
            "<code>dealFreeCell(seed)</code> should return an array of length 7.",
          "testString":
            "assert(dealFreeCell(1).length === 7, '<code>dealFreeCell(seed)</code> should return an array of length 7.');"
        },
        {
          "text":
            "<code>dealFreeCell(1)</code> should return an array identical to example \"Game #1\"",
          "testString":
            "assert.deepEqual(dealFreeCell(1), game1, '<code>dealFreeCell(1)</code> should return an array identical to example \"Game #1\"');"
        },
        {
          "text":
            "<code>dealFreeCell(617)</code> should return an array identical to example \"Game #617\"",
          "testString":
            "assert.deepEqual(dealFreeCell(617), game617, '<code>dealFreeCell(617)</code> should return an array identical to example \"Game #617\"');"
        }
      ],
      "id": "59694356a6e7011f7f1c5f4e",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function dealFreeCell (seed) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const replaceThis = 3;",
            "const game1 = [",
            "  ['JD', '2D', '9H', 'JC', '5D', '7H', '7C', '5H'],",
            "  ['KD', 'KC', '9S', '5S', 'AD', 'QC', 'KH', '3H'],",
            "  ['2S', 'KS', '9D', 'QD', 'JS', 'AS', 'AH', '3C'],",
            "  ['4C', '5C', 'TS', 'QH', '4H', 'AC', '4D', '7S'],",
            "  ['3S', 'TD', '4S', 'TH', '8H', '2C', 'JH', '7D'],",
            "  ['6D', '8S', '8D', 'QS', '6C', '3D', '8C', 'TC'],",
            "  ['6S', '9C', '2H', '6H']",
            "];",
            "const game617 = [",
            "  ['7D', 'AD', '5C', '3S', '5S', '8C', '2D', 'AH'],",
            "  ['TD', '7S', 'QD', 'AC', '6D', '8H', 'AS', 'KH'],",
            "  ['TH', 'QC', '3H', '9D', '6S', '8D', '3D', 'TC'],",
            "  ['KD', '5H', '9S', '3C', '8S', '7H', '4D', 'JS'],",
            "  ['4C', 'QS', '9C', '9H', '7C', '6H', '2C', '2S'],",
            "  ['4S', 'TS', '2H', '5D', 'JC', '6C', 'JH', 'QH'],",
            "  ['JD', 'KS', 'KC', '4H']",
            "];"
          ]
        }
      }
    },
    {
      "title": "Deepcopy",
      "description": [
        "Task:",
        "<p>Write a function that returns a deep copy of a given object.</p>",
        "<p>The copy must not be the same object that was given.</p>",
        "<p>This task will not test for: </p>",
        "Objects with properties that are functions",
        "Date objects or object with properties that are Date objects",
        "RegEx or object with properties that are RegEx objects",
        "Prototype copying"
      ],
      "null": [],
      "solutions": [
        "function deepcopy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\n"
      ],
      "tests": [
        {
          "text": "<code>deepcopy</code> should be a function.",
          "testString":
            "assert(typeof deepcopy === 'function', '<code>deepcopy</code> should be a function.');"
        },
        {
          "text":
            "<code>deepcopy({test: \"test\"})</code> should return an object.",
          "testString":
            "assert(typeof deepcopy(obj1) === 'object', '<code>deepcopy({test: \"test\"})</code> should return an object.');"
        },
        {
          "text": "Should not return the same object that was provided.",
          "testString":
            "assert(deepcopy(obj2) != obj2, 'Should not return the same object that was provided.');"
        },
        {
          "text":
            "When passed an object containing an array, should return a deep copy of the object.",
          "testString":
            "assert.deepEqual(deepcopy(obj2), obj2, 'When passed an object containing an array, should return a deep copy of the object.');"
        },
        {
          "text":
            "When passed an object containing another object, should return a deep copy of the object.",
          "testString":
            "assert.deepEqual(deepcopy(obj3), obj3, 'When passed an object containing another object, should return a deep copy of the object.');"
        }
      ],
      "id": "596a8888ab7c01048de257d5",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function deepcopy (obj) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const obj1 = { test: 'test' };",
            "const obj2 = {",
            "  t: 'test',",
            "  a: ['an', 'array']",
            "};",
            "const obj3 = {",
            "  t: 'try',",
            "  o: obj2",
            "};"
          ]
        }
      }
    },
    {
      "title": "Define a primitive data type",
      "description": [
        "Task:",
        "<p>Define a type that behaves like an integer but has a lowest valid value of 1 and a highest valid value of 10.</p>",
        "Errors:",
        "If you try to instantiate a <code>Num</code> with a value outside of 1 - 10",
        "it should throw a <code>TypeError</code> with an error message of <code>'Out of range'</code>.",
        "If you try to instantiate a <code>Num</code> with a value that is not a number",
        "it should throw a <code>TypeError</code> with an error message of <code>'Not a Number'</code>."
      ],
      "solutions": [
        "function Num(n) {\n  const num = Math.floor(n);\n  if (isNaN(num)) {\n    throw new TypeError('Not a Number');\n  }\n  if (num < 1 || num > 10) {\n    throw new TypeError('Out of range');\n  }\n\n  this._value = num;\n}\nNum.prototype.valueOf = function() { return this._value; };\nNum.prototype.toString = function () { return this._value.toString(); };\n\nfunction throws(func, errorType, msg) {\n  let hasThrown = false;\n  let errorMsg = '';\n  let correctType = false;\n  try {\n    func();\n  }\n  catch (e) {\n    hasThrown = true;\n    errorMsg = e.message;\n    if (e instanceof errorType) {\n      correctType = true;\n    }\n  }\n  return hasThrown && correctType && msg === errorMsg;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>Num</code> should be a function.",
          "testString":
            "assert(typeof Num === 'function', '<code>Num</code> should be a function.');"
        },
        {
          "text": "<code>new Num(4)</code> should return an object.",
          "testString":
            "assert(typeof (new Num(4)) === 'object', '<code>new Num(4)</code> should return an object.');"
        },
        {
          "text":
            "<code>new Num(\\'test\\')</code> should throw a TypeError with message \\'Not a Number\\'.",
          "testString":
            "assert(throws(() => new Num('test'), TypeError, 'Not a Number'), '<code>new Num(\\'test\\')</code> should throw a TypeError with message \\'Not a Number\\'.');"
        },
        {
          "text":
            "<code>new Num(0)</code> should throw a TypeError with message \\'Out of range\\'.",
          "testString":
            "assert(throws(() => new Num(0), TypeError, 'Out of range'), '<code>new Num(0)</code> should throw a TypeError with message \\'Out of range\\'.');"
        },
        {
          "text":
            "<code>new Num(-5)</code> should throw a TypeError with message \\'Out of range\\'.",
          "testString":
            "assert(throws(() => new Num(-5), TypeError, 'Out of range'), '<code>new Num(-5)</code> should throw a TypeError with message \\'Out of range\\'.');"
        },
        {
          "text":
            "<code>new Num(10)</code> should throw a TypeError with message \\'Out of range\\'.",
          "testString":
            "assert(throws(() => new Num(11), TypeError, 'Out of range'), '<code>new Num(10)</code> should throw a TypeError with message \\'Out of range\\'.');"
        },
        {
          "text":
            "<code>new Num(20)</code> should throw a TypeError with message \\'Out of range\\'.",
          "testString":
            "assert(throws(() => new Num(20), TypeError, 'Out of range'), '<code>new Num(20)</code> should throw a TypeError with message \\'Out of range\\'.');"
        },
        {
          "text": "<code>new Num(3) + new Num(4)</code> should equal 7.",
          "testString":
            "assert.equal(new Num(3) + new Num(4), 7, '<code>new Num(3) + new Num(4)</code> should equal 7.');"
        },
        {
          "text": "<code>new Num(3) - new Num(4)</code> should equal -1.",
          "testString":
            "assert.equal(new Num(3) - new Num(4), -1, '<code>new Num(3) - new Num(4)</code> should equal -1.');"
        },
        {
          "text": "<code>new Num(3) * new Num(4)</code> should equal 12.",
          "testString":
            "assert.equal(new Num(3) * new Num(4), 12, '<code>new Num(3) * new Num(4)</code> should equal 12.');"
        },
        {
          "text": "<code>new Num(3) / new Num(4)</code> should equal 0.75.",
          "testString":
            "assert.equal(new Num(3) / new Num(4), 0.75, '<code>new Num(3) / new Num(4)</code> should equal 0.75.');"
        },
        {
          "text": "<code>new Num(3) < new Num(4)</code> should be true.",
          "testString":
            "assert(new Num(3) < new Num(4), '<code>new Num(3) < new Num(4)</code> should be true.');"
        },
        {
          "text": "<code>new Num(3) > new Num(4)</code> should be false.",
          "testString":
            "assert(!(new Num(3) > new Num(4)), '<code>new Num(3) > new Num(4)</code> should be false.');"
        },
        {
          "text": "<code>(new Num(5)).toString()</code> should return \\'5\\'",
          "testString":
            "assert.equal((new Num(5)).toString(), '5', '<code>(new Num(5)).toString()</code> should return \\'5\\'');"
        }
      ],
      "id": "597089c87eec450c68aa1643",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Num (n) {",
            "  // Good luck!",
            "  return n;",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Department Numbers",
      "description": [
        "<p>There is a highly organized city that has decided to assign a number to each of their departments:</p>",
        "Police department",
        "Sanitation department",
        "Fire department ",
        "<p>Each department can have a number between 1 and 7  (inclusive).</p><p>The three department numbers are to be unique (different from each other) and must add up to the number 12.</p><p>The Chief of the Police doesn't like odd numbers and wants to have an even number for his department.</p>",
        "Task:",
        "<p>Write a program which outputs all valid combinations:</p>",
        "<p>[2, 3, 7]</p>",
        "<p>[2, 4, 6]</p>",
        "<p>[2, 6, 4]</p>",
        "<p>[2, 7, 3]</p>",
        "<p>[4, 1, 7]</p>",
        "<p>[4, 2, 6]</p>",
        "<p>[4, 3, 5]</p>",
        "<p>[4, 5, 3]</p>",
        "<p>[4, 6, 2]</p>",
        "<p>[4, 7, 1]</p>",
        "<p>[6, 1, 5]</p>",
        "<p>[6, 2, 4]</p>",
        "<p>[6, 4, 2]</p>",
        "<p>[6, 5, 1]</p>"
      ],
      "solutions": [
        "function combinations (possibleNumbers, total) {\n  let firstNumber;\n  let secondNumber;\n  let thridNumber;\n  const allCombinations = [];\n\n  for (let i = 0; i < possibleNumbers.length; i += 1) {\n    firstNumber = possibleNumbers[i];\n\n    if (firstNumber % 2 === 0) {\n      for (let j = 0; j < possibleNumbers.length; j += 1) {\n        secondNumber = possibleNumbers[j];\n\n        if (j !== i && firstNumber + secondNumber <= total) {\n          thridNumber = total - firstNumber - secondNumber;\n\n          if (thridNumber !== firstNumber && thridNumber !== secondNumber && possibleNumbers.includes(thridNumber)) {\n            allCombinations.push([firstNumber, secondNumber, thridNumber]);\n          }\n        }\n      }\n    }\n  }\n  return allCombinations;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>combinations</code> should be a function.",
          "testString":
            "assert(typeof combinations === 'function', '<code>combinations</code> should be a function.');"
        },
        {
          "text":
            "<code>combinations([1, 2, 3], 6)</code> should return an Array.",
          "testString":
            "assert(Array.isArray(combinations([1, 2, 3], 6)), '<code>combinations([1, 2, 3], 6)</code> should return an Array.');"
        },
        {
          "text":
            "<code>combinations([1, 2, 3, 4, 5, 6, 7], 12)</code> should return an array of length 14.",
          "testString":
            "assert(combinations(nums, total).length === len, '<code>combinations([1, 2, 3, 4, 5, 6, 7], 12)</code> should return an array of length 14.');"
        },
        {
          "text":
            "<code>combinations([1, 2, 3, 4, 5, 6, 7], 12)</code> should return all valid combinations.",
          "testString":
            "assert.deepEqual(combinations(nums, total), result, '<code>combinations([1, 2, 3, 4, 5, 6, 7], 12)</code> should return all valid combinations.');"
        }
      ],
      "id": "59f40b17e79dbf1ab720ed7a",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function combinations (possibleNumbers, total) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const nums = [1, 2, 3, 4, 5, 6, 7];",
            "const total = 12;",
            "const len = 14;",
            "const result = [",
            "  [2, 3, 7],",
            "  [2, 4, 6],",
            "  [2, 6, 4],",
            "  [2, 7, 3],",
            "  [4, 1, 7],",
            "  [4, 2, 6],",
            "  [4, 3, 5],",
            "  [4, 5, 3],",
            "  [4, 6, 2],",
            "  [4, 7, 1],",
            "  [6, 1, 5],",
            "  [6, 2, 4],",
            "  [6, 4, 2],",
            "  [6, 5, 1]",
            "];"
          ]
        }
      }
    },
    {
      "title": "Discordian date",
      "description": [
        "Task:",
        "<p>Convert a given date from the  <a href=\"https://en.wikipedia.org/wiki/Gregorian calendar\" title=\"wp: Gregorian calendar\">Gregorian calendar</a>  to the  <a href=\"https://en.wikipedia.org/wiki/Discordian calendar\" title=\"wp: Discordian calendar\">Discordian calendar</a>.</p>"
      ],
      "solutions": [
        "/**\n * All Hail Discordia! - this script prints Discordian date using system date.\n *\n * lang: JavaScript\n * author: jklu\n * contributors: JamesMcGuigan\n *\n * source: https://rosettacode.org/wiki/Discordian_date#JavaScript\n */\nconst seasons = [\n  'Chaos', 'Discord', 'Confusion',\n  'Bureaucracy', 'The Aftermath'\n];\nconst weekday = [\n  'Sweetmorn', 'Boomtime', 'Pungenday',\n  'Prickle-Prickle', 'Setting Orange'\n];\n\nconst apostle = [\n  'Mungday', 'Mojoday', 'Syaday',\n  'Zaraday', 'Maladay'\n];\n\nconst holiday = [\n  'Chaoflux', 'Discoflux', 'Confuflux',\n  'Bureflux', 'Afflux'\n];\n\n\nDate.prototype.isLeapYear = function() {\n  const year = this.getFullYear();\n  if ((year & 3) !== 0) { return false; }\n  return ((year % 100) !== 0 || (year % 400) === 0);\n};\n\n// Get Day of Year\nDate.prototype.getDOY = function() {\n  const dayCount = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n  const mn = this.getMonth();\n  const dn = this.getDate();\n  let dayOfYear = dayCount[mn] + dn;\n  if (mn > 1 && this.isLeapYear()) { dayOfYear += 1; }\n  return dayOfYear;\n};\n\nDate.prototype.isToday = function() {\n  const today = new Date();\n  return this.getDate() === today.getDate()\n      && this.getMonth() === today.getMonth()\n      && this.getFullYear() === today.getFullYear()\n  ;\n};\n\nfunction discordianDate(date) {\n  if (!date) { date = new Date(); }\n\n  const y = date.getFullYear();\n  const yold = y + 1166;\n  let dayOfYear = date.getDOY();\n  let celebrateHoliday = null;\n\n  if (date.isLeapYear()) {\n    if (dayOfYear === 60) {\n      celebrateHoliday = 'St. Tib\\'s Day';\n    }\n    else if (dayOfYear > 60) {\n      dayOfYear--;\n    }\n  }\n  dayOfYear--;\n\n  const divDay = Math.floor(dayOfYear / 73);\n\n  const seasonDay = (dayOfYear % 73) + 1;\n  if (seasonDay === 5) {\n    celebrateHoliday = apostle[divDay];\n  }\n  if (seasonDay === 50) {\n    celebrateHoliday = holiday[divDay];\n  }\n\n  const season = seasons[divDay];\n  const dayOfWeek = weekday[dayOfYear % 5];\n\n  const nth = (seasonDay % 10 === 1) ? 'st'\n          : (seasonDay % 10 === 2) ? 'nd'\n          : (seasonDay % 10 === 3) ? 'rd'\n                                  : 'th';\n\n  return ''\n         + dayOfWeek\n         + ', the ' + seasonDay + nth\n         + ' day of ' + season\n         + ' in the YOLD ' + yold\n         + (celebrateHoliday ? '. Celebrate ' + celebrateHoliday + '!' : '')\n    ;\n}\n\n"
      ],
      "tests": [
        {
          "text": "<code>discordianDate</code> is a function.",
          "testString":
            "assert(typeof discordianDate === 'function', '<code>discordianDate</code> is a function.');"
        },
        {
          "text":
            "<code>discordianDate(new Date(2010, 6, 22))</code> should return <code>\"Pungenday, the 57th day of Confusion in the YOLD 3176\"</code>.",
          "testString":
            "assert(discordianDate(new Date(2010, 6, 22)) === 'Pungenday, the 57th day of Confusion in the YOLD 3176', '<code>discordianDate(new Date(2010, 6, 22))</code> should return <code>\"Pungenday, the 57th day of Confusion in the YOLD 3176\"</code>.');"
        },
        {
          "text":
            "<code>discordianDate(new Date(2012, 1, 28))</code> should return <code>\"Prickle-Prickle, the 59th day of Chaos in the YOLD 3178\"</code>.",
          "testString":
            "assert(discordianDate(new Date(2012, 1, 28)) === 'Prickle-Prickle, the 59th day of Chaos in the YOLD 3178', '<code>discordianDate(new Date(2012, 1, 28))</code> should return <code>\"Prickle-Prickle, the 59th day of Chaos in the YOLD 3178\"</code>.');"
        },
        {
          "text":
            "<code>discordianDate(new Date(2012, 1, 29))</code> should return <code>\"Setting Orange, the 60th day of Chaos in the YOLD 3178. Celebrate St. Tib\\'s Day!\"</code>.",
          "testString":
            "assert(discordianDate(new Date(2012, 1, 29)) === 'Setting Orange, the 60th day of Chaos in the YOLD 3178. Celebrate St. Tib\\'s Day!', '<code>discordianDate(new Date(2012, 1, 29))</code> should return <code>\"Setting Orange, the 60th day of Chaos in the YOLD 3178. Celebrate St. Tib\\'s Day!\"</code>.');"
        },
        {
          "text":
            "<code>discordianDate(new Date(2012, 2, 1))</code> should return <code>\"Setting Orange, the 60th day of Chaos in the YOLD 3178\"</code>.",
          "testString":
            "assert(discordianDate(new Date(2012, 2, 1)) === 'Setting Orange, the 60th day of Chaos in the YOLD 3178', '<code>discordianDate(new Date(2012, 2, 1))</code> should return <code>\"Setting Orange, the 60th day of Chaos in the YOLD 3178\"</code>.');"
        },
        {
          "text":
            "<code>discordianDate(new Date(2010, 0, 5))</code> should return <code>\"Setting Orange, the 5th day of Chaos in the YOLD 3176. Celebrate Mungday!\"</code>.",
          "testString":
            "assert(discordianDate(new Date(2010, 0, 5)) === 'Setting Orange, the 5th day of Chaos in the YOLD 3176. Celebrate Mungday!', '<code>discordianDate(new Date(2010, 0, 5))</code> should return <code>\"Setting Orange, the 5th day of Chaos in the YOLD 3176. Celebrate Mungday!\"</code>.');"
        },
        {
          "text":
            "<code>discordianDate(new Date(2011, 4, 3))</code> should return <code>\"Pungenday, the 50th day of Discord in the YOLD 3177. Celebrate Discoflux!\"</code>.",
          "testString":
            "assert(discordianDate(new Date(2011, 4, 3)) === 'Pungenday, the 50th day of Discord in the YOLD 3177. Celebrate Discoflux!', '<code>discordianDate(new Date(2011, 4, 3))</code> should return <code>\"Pungenday, the 50th day of Discord in the YOLD 3177. Celebrate Discoflux!\"</code>.');"
        },
        {
          "text":
            "<code>discordianDate(new Date(2015, 9, 19))</code> should return <code>\"Boomtime, the 73rd day of Bureaucracy in the YOLD 3181\"</code>.",
          "testString":
            "assert(discordianDate(new Date(2015, 9, 19)) === 'Boomtime, the 73rd day of Bureaucracy in the YOLD 3181', '<code>discordianDate(new Date(2015, 9, 19))</code> should return <code>\"Boomtime, the 73rd day of Bureaucracy in the YOLD 3181\"</code>.');"
        }
      ],
      "id": "59f4eafba0343628bb682785",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function discordianDate (date) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Dot product",
      "description": [
        "Create a function, to compute the  <b><a href=\"https://en.wikipedia.org/wiki/Dot product\">dot product</a></b>,  also known as the  <b>scalar product</b>  of two vectors."
      ],
      "solutions": [
        "function dotProduct (ary1, ary2) {\n    var dotprod = 0;\n    for (var i = 0; i < ary1.length; i++)\n        dotprod += ary1[i] * ary2[i];\n    return dotprod;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>dotProduct</code> should be a function.'",
          "testString":
            "assert(typeof dotProduct=='function','<code>dotProduct</code> should be a function.');"
        },
        {
          "text":
            "'<code>dotProduct([1,3,-5],[4,-2,-1])</code> should return a number.'",
          "testString":
            "assert(typeof dotProduct([1,3,-5],[4,-2,-1]) == 'number','<code>dotProduct([1,3,-5],[4,-2,-1])</code> should return a number.');"
        },
        {
          "text":
            "'<code>dotProduct([1,3,-5],[4,-2,-1])</code> should return <code>3</code>.'",
          "testString":
            "assert.equal(dotProduct([1,3,-5],[4,-2,-1]),3,'<code>dotProduct([1,3,-5],[4,-2,-1])</code> should return <code>3</code>.');"
        },
        {
          "text":
            "'<code>dotProduct([1,2,3,4,5],[6,7,8,9,10])</code> should return <code>130</code>.'",
          "testString":
            "assert.equal(dotProduct([1,2,3,4,5],[6,7,8,9,10]),130,'<code>dotProduct([1,2,3,4,5],[6,7,8,9,10])</code> should return <code>130</code>.');"
        },
        {
          "text":
            "'<code>dotProduct([5,4,3,2],[7,8,9,6])</code> should return <code>106</code>.'",
          "testString":
            "assert.equal(dotProduct([5,4,3,2],[7,8,9,6]),106,'<code>dotProduct([5,4,3,2],[7,8,9,6])</code> should return <code>106</code>.');"
        },
        {
          "text":
            "'<code>dotProduct([-5,4,-3,2],[-7,-8,9,-6])</code> should return <code>-36</code>.'",
          "testString":
            "assert.equal(dotProduct([-5,4,-3,2],[-7,-8,9,-6]),-36,'<code>dotProduct([-5,4,-3,2],[-7,-8,9,-6])</code> should return <code>-36</code>.');"
        },
        {
          "text":
            "'<code>dotProduct([17,27,34,43,15],[62,73,48,95,110])</code> should return <code>10392</code>.'",
          "testString":
            "assert.equal(dotProduct([17,27,34,43,15],[62,73,48,95,110]),10392,'<code>dotProduct([17,27,34,43,15],[62,73,48,95,110])</code> should return <code>10392</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7e1e",
      "challengeType": 5,
      "releasedOn": "September 1, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function dotProduct (ary1, ary2) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Doubly-linked list/Definition",
      "description": [
        "Write a function that takes an array as a parameter. This array contains queries that specify operations to be performed on a doubly linked list. The operations are in the form of <code>[ type, args... ]</code>. The type can be <code>head</code>, <code>tail</code> or <code>after</code>.",
        "If the type is <code>head</code>, insert the second element of the operation to the beginning of the list. If the type is <code>tail</code>, insert at end of list. If it's <code>after</code>, the second and third elements of the operation will be an index and a value. The value should be inserted after the given index.",
        "Return the doubly linked list object after performing the operations."
      ],
      "solutions": [
        "function doublyLinkedList() {\n  this.length = 0;\n  this.head = null;\n  this.tail = null;\n}\n\nfunction Node(val) {\n  this.val = val;\n  this.prev = null;\n  this.next = null;\n}\n\nfunction doubLinkedList (queries) {\n  // Good luck!\n}\nfunction doubLinkedList (queries) {\n  doublyLinkedList.prototype.insertAtHead = function(val) {\n    var node=new Node(val);\n    if(this.head){\n      node.next=this.head;\n      this.head.prev=node;\n      this.head=node;\n    }else{\n      this.head=node;\n      this.tail=node;\n    }\n    this.length++;\n  }\n\n  doublyLinkedList.prototype.insertAfter = function(index,val) {\n    var temp=this.head;\n\n    if(this.length==1){\n      this.insertAtTail(val)\n    }else{\n      for(var i=0;i<index;i++){\n        temp=temp.next;\n      }\n\n      if(temp==this.tail){\n        this.insertAtTail(val)\n      }else{\n        var node=new Node(val);\n        var tempNext=temp.next;\n        temp.next=node;\n        tempNext.prev=node;\n        node.prev=temp;\n        node.next=tempNext;\n      }\n    }\n    this.length++;\n  }\n\n  doublyLinkedList.prototype.insertAtTail = function(val) {\n    if(this.head){\n      var node=new Node(val);\n      node.prev=this.tail;\n      this.tail.next=node;\n      this.tail=node;\n    }else{\n      this.insertAtHead(val)\n    }\n    this.length++;\n  }\n\n  var list = new doublyLinkedList();\n\n  queries.forEach(function(e) {\n    switch (e[0]) {\n      case 'head':\n        list.insertAtHead(e[1]);\n        break;\n      case 'after':\n        list.insertAfter(e[1],e[2]);\n        break;\n      case 'tail':\n        list.insertAtTail(e[1]);\n        break;\n    }\n  })\n\n  return list\n}\n"
      ],
      "tests": [
        {
          "text":
            "'<code>forwardTraverse(doubLinkedList</code> should be a function.'",
          "testString":
            "assert(typeof doubLinkedList=='function','<code>forwardTraverse(doubLinkedList</code> should be a function.');"
        },
        {
          "text":
            "'<code>forwardTraverse(doubLinkedList([[\"head\",1],[\"head\",2],[\"head\",3],[\"head\",4],[\"head\",5]]))</code> should return a array.'",
          "testString":
            "assert(Array.isArray(forwardTraverse(doubLinkedList([[\"head\",1],[\"head\",2],[\"head\",3],[\"head\",4],[\"head\",5]]))),'<code>forwardTraverse(doubLinkedList([[\"head\",1],[\"head\",2],[\"head\",3],[\"head\",4],[\"head\",5]]))</code> should return a array.');"
        },
        {
          "text":
            "'<code>forwardTraverse(doubLinkedList([[\"head\",1],[\"head\",2],[\"head\",3],[\"head\",4],[\"head\",5]]))</code> should return <code>[5,4,3,2,1]</code>.'",
          "testString":
            "assert.deepEqual(forwardTraverse(doubLinkedList([[\"head\",1],[\"head\",2],[\"head\",3],[\"head\",4],[\"head\",5]])),[5,4,3,2,1],'<code>forwardTraverse(doubLinkedList([[\"head\",1],[\"head\",2],[\"head\",3],[\"head\",4],[\"head\",5]]))</code> should return <code>[5,4,3,2,1]</code>.');"
        },
        {
          "text":
            "'<code>forwardTraverse(doubLinkedList([[\"tail\",1],[\"after\",0,2],[\"tail\",3],[\"tail\",5],[\"after\",2,4]]))</code> should return <code>[1,2,3,4,5]</code>.'",
          "testString":
            "assert.deepEqual(forwardTraverse(doubLinkedList([[\"tail\",1],[\"after\",0,2],[\"tail\",3],[\"tail\",5],[\"after\",2,4]])),[1,2,3,4,5],'<code>forwardTraverse(doubLinkedList([[\"tail\",1],[\"after\",0,2],[\"tail\",3],[\"tail\",5],[\"after\",2,4]]))</code> should return <code>[1,2,3,4,5]</code>.');"
        },
        {
          "text":
            "'<code>forwardTraverse(doubLinkedList([[\"head\",31],[\"tail\",26],[\"head\",33],[\"tail\",15],[\"head\",24]]))</code> should return <code>[24,33,31,26,15]</code>.'",
          "testString":
            "assert.deepEqual(forwardTraverse(doubLinkedList([[\"head\",31],[\"tail\",26],[\"head\",33],[\"tail\",15],[\"head\",24]])),[24,33,31,26,15],'<code>forwardTraverse(doubLinkedList([[\"head\",31],[\"tail\",26],[\"head\",33],[\"tail\",15],[\"head\",24]]))</code> should return <code>[24,33,31,26,15]</code>.');"
        },
        {
          "text":
            "'<code>forwardTraverse(doubLinkedList([[\"head\",2],[\"head\",0],[\"after\",0,3],[\"after\",0,4],[\"tail\",12]]))</code> should return <code>[0,4,3,2,12]</code>.'",
          "testString":
            "assert.deepEqual(forwardTraverse(doubLinkedList([[\"head\",2],[\"head\",0],[\"after\",0,3],[\"after\",0,4],[\"tail\",12]])),[0,4,3,2,12],'<code>forwardTraverse(doubLinkedList([[\"head\",2],[\"head\",0],[\"after\",0,3],[\"after\",0,4],[\"tail\",12]]))</code> should return <code>[0,4,3,2,12]</code>.');"
        },
        {
          "text":
            "'<code>forwardTraverse(doubLinkedList([[\"tail\",1],[\"after\",0,2],[\"head\",3],[\"tail\",5],[\"head\",42]]))</code> should return <code>[42,3,1,2,5]</code>.'",
          "testString":
            "assert.deepEqual(forwardTraverse(doubLinkedList([[\"tail\",1],[\"after\",0,2],[\"head\",3],[\"tail\",5],[\"head\",42]])),[42,3,1,2,5],'<code>forwardTraverse(doubLinkedList([[\"tail\",1],[\"after\",0,2],[\"head\",3],[\"tail\",5],[\"head\",42]]))</code> should return <code>[42,3,1,2,5]</code>.');"
        },
        {
          "text":
            "'<code>reverseTraverse(doubLinkedList([[\"head\",1],[\"head\",2],[\"head\",3],[\"head\",4],[\"head\",5]]))</code> should return <code>[1,2,3,4,5]</code>.'",
          "testString":
            "assert.deepEqual(reverseTraverse(doubLinkedList([[\"head\",1],[\"head\",2],[\"head\",3],[\"head\",4],[\"head\",5]])),[1,2,3,4,5],'<code>reverseTraverse(doubLinkedList([[\"head\",1],[\"head\",2],[\"head\",3],[\"head\",4],[\"head\",5]]))</code> should return <code>[1,2,3,4,5]</code>.');"
        },
        {
          "text":
            "'<code>reverseTraverse(doubLinkedList([[\"tail\",1],[\"after\",0,2],[\"tail\",3],[\"tail\",5],[\"after\",2,4]]))</code> should return <code>[5,4,3,2,1]</code>.'",
          "testString":
            "assert.deepEqual(reverseTraverse(doubLinkedList([[\"tail\",1],[\"after\",0,2],[\"tail\",3],[\"tail\",5],[\"after\",2,4]])),[5,4,3,2,1],'<code>reverseTraverse(doubLinkedList([[\"tail\",1],[\"after\",0,2],[\"tail\",3],[\"tail\",5],[\"after\",2,4]]))</code> should return <code>[5,4,3,2,1]</code>.');"
        },
        {
          "text":
            "'<code>reverseTraverse(doubLinkedList([[\"head\",31],[\"tail\",26],[\"head\",33],[\"tail\",15],[\"head\",24]]))</code> should return <code>[15,26,31,33,24]</code>.'",
          "testString":
            "assert.deepEqual(reverseTraverse(doubLinkedList([[\"head\",31],[\"tail\",26],[\"head\",33],[\"tail\",15],[\"head\",24]])),[15,26,31,33,24],'<code>reverseTraverse(doubLinkedList([[\"head\",31],[\"tail\",26],[\"head\",33],[\"tail\",15],[\"head\",24]]))</code> should return <code>[15,26,31,33,24]</code>.');"
        },
        {
          "text":
            "'<code>reverseTraverse(doubLinkedList([[\"head\",2],[\"head\",0],[\"after\",0,3],[\"after\",0,4],[\"tail\",12]]))</code> should return <code>[12,2,3,4,0]</code>.'",
          "testString":
            "assert.deepEqual(reverseTraverse(doubLinkedList([[\"head\",2],[\"head\",0],[\"after\",0,3],[\"after\",0,4],[\"tail\",12]])),[12,2,3,4,0],'<code>reverseTraverse(doubLinkedList([[\"head\",2],[\"head\",0],[\"after\",0,3],[\"after\",0,4],[\"tail\",12]]))</code> should return <code>[12,2,3,4,0]</code>.');"
        },
        {
          "text":
            "'<code>reverseTraverse(doubLinkedList([[\"tail\",1],[\"after\",0,2],[\"head\",3],[\"tail\",5],[\"head\",42]]))</code> should return <code>[5,2,1,3,42]</code>.'",
          "testString":
            "assert.deepEqual(reverseTraverse(doubLinkedList([[\"tail\",1],[\"after\",0,2],[\"head\",3],[\"tail\",5],[\"head\",42]])),[5,2,1,3,42],'<code>reverseTraverse(doubLinkedList([[\"tail\",1],[\"after\",0,2],[\"head\",3],[\"tail\",5],[\"head\",42]]))</code> should return <code>[5,2,1,3,42]</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7e1f",
      "challengeType": 5,
      "releasedOn": "September 1, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function doublyLinkedList() {",
            "  this.length = 0;",
            "  this.head = null;",
            "  this.tail = null;",
            "}",
            "",
            "function Node(val) {",
            "  this.val = val;",
            "  this.prev = null;",
            "  this.next = null;",
            "}",
            "",
            "function doubLinkedList (queries) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "function forwardTraverse(list) {",
            "  var vals=[],temp=list.head;",
            "  while(temp){",
            "    vals.push(temp.val)",
            "    temp=temp.next",
            "  }",
            "  return vals",
            "}",
            "function reverseTraverse(list) {",
            "  var vals=[],temp=list.tail;",
            "  while(temp){",
            "    vals.push(temp.val)",
            "    temp=temp.prev",
            "  }",
            "  return vals",
            "}"
          ]
        }
      }
    },
    {
      "title": "Element-wise operations",
      "description": [
        "<p>Implement basic element-wise matrix-matrix and scalar-matrix operations.</p><p>Implement:</p>",
        "<p>::*  addition</p>",
        "<p>::*  subtraction</p>",
        "<p>::*  multiplication</p>",
        "<p>::*  division</p>",
        "<p>::*  exponentiation</p>",
        "<p>The first parameter will be the operation to be performed, for example : \"m_add\" for matrix addition and \"s_add\" for scalar addition. The second and third parameters will be the matrices on which the operations are to be performed."
      ],
      "solutions": [
        "function operation(op, arr1, arr2) {\n  const ops = {\n    add: ((a, b) => a + b),\n    sub: ((a, b) => a - b),\n    mult: ((a, b) => a * b),\n    div: ((a, b) => a / b),\n    exp: ((a, b) => Math.pow(a, b))\n  };\n  const ifm = op.startsWith('m');\n  const doOp = ops[op.substring(2)];\n  for (let i = 0; i < arr1.length; i++) {\n    for (let j = 0; j < arr1[0].length; j++) {\n      arr1[i][j] = doOp(arr1[i][j], (ifm) ? (arr2[i][j]) : (arr2));\n    }\n  }\n  return arr1;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>operation</code> is a function.",
          "testString":
            "assert(typeof operation === 'function', '<code>operation</code> is a function.');"
        },
        {
          "text":
            "<code>operation(\"m_add\",[[1,2],[3,4]],[[1,2],[3,4]])</code> should return <code>[[2,4],[6,8]]</code>.",
          "testString":
            "assert.deepEqual(operation('m_add', [[1, 2], [3, 4]], [[1, 2], [3, 4]]), [[2, 4], [6, 8]], '<code>operation(\"m_add\",[[1,2],[3,4]],[[1,2],[3,4]])</code> should return <code>[[2,4],[6,8]]</code>.');"
        },
        {
          "text":
            "<code>operation(\"s_add\",[[1,2],[3,4]],[[1,2],[3,4]])</code> should return <code>[[3,4],[5,6]]</code>.",
          "testString":
            "assert.deepEqual(operation('s_add', [[1, 2], [3, 4]], 2), [[3, 4], [5, 6]], '<code>operation(\"s_add\",[[1,2],[3,4]],[[1,2],[3,4]])</code> should return <code>[[3,4],[5,6]]</code>.');"
        },
        {
          "text":
            "<code>operation(\"m_sub\",[[1,2],[3,4]],[[1,2],[3,4]])</code> should return <code>[[0,0],[0,0]]</code>.",
          "testString":
            "assert.deepEqual(operation('m_sub', [[1, 2], [3, 4]], [[1, 2], [3, 4]]), [[0, 0], [0, 0]], '<code>operation(\"m_sub\",[[1,2],[3,4]],[[1,2],[3,4]])</code> should return <code>[[0,0],[0,0]]</code>.');"
        },
        {
          "text":
            "<code>operation(\"m_mult\",[[1,2],[3,4]],[[1,2],[3,4]])</code> should return <code>[[1,4],[9,16]]</code>.",
          "testString":
            "assert.deepEqual(operation('m_mult', [[1, 2], [3, 4]], [[1, 2], [3, 4]]), [[1, 4], [9, 16]], '<code>operation(\"m_mult\",[[1,2],[3,4]],[[1,2],[3,4]])</code> should return <code>[[1,4],[9,16]]</code>.');"
        },
        {
          "text":
            "<code>operation(\"m_div\",[[1,2],[3,4]],[[1,2],[3,4]])</code> should return <code>[[1,1],[1,1]]</code>.",
          "testString":
            "assert.deepEqual(operation('m_div', [[1, 2], [3, 4]], [[1, 2], [3, 4]]), [[1, 1], [1, 1]], '<code>operation(\"m_div\",[[1,2],[3,4]],[[1,2],[3,4]])</code> should return <code>[[1,1],[1,1]]</code>.');"
        },
        {
          "text":
            "<code>operation(\"m_exp\",[[1,2],[3,4]],[[1,2],[3,4]])</code> should return <code>[[1,4],[27,256]]</code>.",
          "testString":
            "assert.deepEqual(operation('m_exp', [[1, 2], [3, 4]], [[1, 2], [3, 4]]), [[1, 4], [27, 256]], '<code>operation(\"m_exp\",[[1,2],[3,4]],[[1,2],[3,4]])</code> should return <code>[[1,4],[27,256]]</code>.');"
        },
        {
          "text":
            "<code>operation(\"m_add\",[[1,2,3,4],[5,6,7,8]],[[9,10,11,12],[13,14,15,16]])</code> should return <code>[[10,12,14,16],[18,20,22,24]]</code>.",
          "testString":
            "assert.deepEqual(operation('m_add', [[1, 2, 3, 4], [5, 6, 7, 8]], [[9, 10, 11, 12], [13, 14, 15, 16]]), [[10, 12, 14, 16], [18, 20, 22, 24]], '<code>operation(\"m_add\",[[1,2,3,4],[5,6,7,8]],[[9,10,11,12],[13,14,15,16]])</code> should return <code>[[10,12,14,16],[18,20,22,24]]</code>.');"
        }
      ],
      "id": "599c333915e0ea32d04d4bec",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function operation (op, arr1, arr2) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Emirp primes",
      "description": [
        "<p>An  emirp  (prime spelled backwards)  are primes that when reversed  (in their decimal representation)  are a different prime.</p>",
        "<p>Write a function that should be able to : Show the first <b>n</b> eprimes numbers.Show the eprimes numbers in a range.Show the number of eprimes in a range.Show the <b>n<sup>th</sup></b> eprimes number.<p>The function should have two parameters. The first will receive <b>n</b> or the range as an array. The second will receive a boolean, that specifies if the function returns the eprimes as an array or a single number(the number of primes in the range or the <b>n<sup>th</sup></b> prime). According to the parameters the function should return an array or a number."
      ],
      "null": [],
      "solutions": [
        "// noprotect\nfunction emirps(num, showEmirps)\n{\n  const is_prime = function(n)\n\t{\n    if (!(n % 2) || !(n % 3)) return false;\n    let p = 1;\n    while (p * p < n)\n\t\t\t        { if (n % (p += 4) == 0 || n % (p += 2) == 0)\n\t\t\t                { return false; } }\n    return true;\n  };\n  const is_emirp = function(n) {\n    const r = parseInt(n.toString().split('').reverse().join(''));\n    return r != n && is_prime(n) && is_prime(r);\n  };\n\n  let i,\n    arr = [];\n  if (typeof num === 'number') {\n    for (i = 0; arr.length < num; i++) if (is_emirp(i)) arr.push(i);\n    // first x emirps\n    if (showEmirps) return arr;\n    // xth emirp\n    return arr.pop();\n  }\n\n  if (Array.isArray(num)) {\n    for (i = num[0]; i <= num[1]; i++) if (is_emirp(i)) arr.push(i);\n    // emirps between x .. y\n    if (showEmirps) return arr;\n    // number of emirps between x .. y\n    return arr.length;\n  }\n}\n"
      ],
      "tests": [
        {
          "text": "<code>emirps</code> is a function.",
          "testString":
            "assert(typeof emirps === 'function', '<code>emirps</code> is a function.');"
        },
        {
          "text":
            "<code>emirps(20,true)</code> should return <code>[13,17,31,37,71,73,79,97,107,113,149,157,167,179,199,311,337,347,359,389]</code>",
          "testString":
            "assert.deepEqual(emirps(20, true), [13, 17, 31, 37, 71, 73, 79, 97, 107, 113, 149, 157, 167, 179, 199, 311, 337, 347, 359, 389], '<code>emirps(20,true)</code> should return <code>[13,17,31,37,71,73,79,97,107,113,149,157,167,179,199,311,337,347,359,389]</code>');"
        },
        {
          "text":
            "<code>emirps(10000)</code> should return <code>948349</code>",
          "testString":
            "assert.deepEqual(emirps(10000), 948349, '<code>emirps(10000)</code> should return <code>948349</code>');"
        },
        {
          "text":
            "<code>emirps([7700,8000],true)</code> should return <code>[7717,7757,7817,7841,7867,7879,7901,7927,7949,7951,7963]</code>",
          "testString":
            "assert.deepEqual(emirps([7700, 8000], true), [7717, 7757, 7817, 7841, 7867, 7879, 7901, 7927, 7949, 7951, 7963], '<code>emirps([7700,8000],true)</code> should return <code>[7717,7757,7817,7841,7867,7879,7901,7927,7949,7951,7963]</code>');"
        },
        {
          "text":
            "<code>emirps([7700,8000],true)</code> should return <code>11</code>",
          "testString":
            "assert.deepEqual(emirps([7700, 8000], false), 11, '<code>emirps([7700,8000],true)</code> should return <code>11</code>');"
        }
      ],
      "id": "599d0ba974141b0f508b37d5",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function emirps(n) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Entropy",
      "description": [
        "Task:",
        "<p>Calculate the Shannon entropy  H  of a given input string.</p><p>Given the discreet random variable $X$ that is a string of $N$ \"symbols\" (total characters) consisting of $n$ different characters (n=2 for binary), the Shannon entropy of X in bits/symbol is :</p>",
        "<p>$H_2(X) = -\\sum_{i=1}^n \\frac{count_i}{N} \\log_2 \\left(\\frac{count_i}{N}\\right)$</p><p>where $count_i$ is the count of character $n_i$.</p>"
      ],
      "solutions": [
        "function entropy(s) {\n\t// Create a dictionary of character frequencies and iterate over it.\n  function process(s, evaluator) {\n    let h = Object.create(null),\n      k;\n    s.split('').forEach(c => {\n      h[c] && h[c]++ || (h[c] = 1); });\n    if (evaluator) for (k in h) evaluator(k, h[k]);\n    return h;\n  }\n\t// Measure the entropy of a string in bits per symbol.\n\n  let sum = 0,\n    len = s.length;\n  process(s, (k, f) => {\n    const p = f / len;\n    sum -= p * Math.log(p) / Math.log(2);\n  });\n  return sum;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>entropy</code> is a function.",
          "testString":
            "assert(typeof entropy === 'function', '<code>entropy</code> is a function.');"
        },
        {
          "text": "<code>entropy(\"0\")</code> should return <code>0</code>",
          "testString":
            "assert.equal(entropy('0'), 0, '<code>entropy(\"0\")</code> should return <code>0</code>');"
        },
        {
          "text": "<code>entropy(\"01\")</code> should return <code>1</code>",
          "testString":
            "assert.equal(entropy('01'), 1, '<code>entropy(\"01\")</code> should return <code>1</code>');"
        },
        {
          "text": "<code>entropy(\"0123\")</code> should return <code>2</code>",
          "testString":
            "assert.equal(entropy('0123'), 2, '<code>entropy(\"0123\")</code> should return <code>2</code>');"
        },
        {
          "text":
            "<code>entropy(\"01234567\")</code> should return <code>3</code>",
          "testString":
            "assert.equal(entropy('01234567'), 3, '<code>entropy(\"01234567\")</code> should return <code>3</code>');"
        },
        {
          "text":
            "<code>entropy(\"0123456789abcdef\")</code> should return <code>4</code>",
          "testString":
            "assert.equal(entropy('0123456789abcdef'), 4, '<code>entropy(\"0123456789abcdef\")</code> should return <code>4</code>');"
        },
        {
          "text":
            "<code>entropy(\"1223334444\")</code> should return <code>1.8464393446710154</code>",
          "testString":
            "assert.equal(entropy('1223334444'), 1.8464393446710154, '<code>entropy(\"1223334444\")</code> should return <code>1.8464393446710154</code>');"
        }
      ],
      "id": "599d15309e88c813a40baf58",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function entropy (s) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Equilibrium index",
      "description": [
        "<p>An equilibrium index of a sequence is an index into the sequence such that the sum of elements at lower indices is equal to the sum of elements at higher indices.</p>",
        "<p>For example, in a sequence  <big>$A$</big>:</p><p>::::  <big>$A_0 = -7$</big></p>",
        "<p>::::  <big>$A_1 =  1$</big></p>",
        "<p>::::  <big>$A_2 =  5$</big></p>",
        "<p>::::  <big>$A_3 =  2$</big></p>",
        "<p>::::  <big>$A_4 = -4$</big></p>",
        "<p>::::  <big>$A_5 =  3$</big></p>",
        "<p>::::  <big>$A_6 =  0$</big></p><p>3  is an equilibrium index, because:</p><p>::::  <big>$A_0 + A_1 + A_2 = A_4 + A_5 + A_6$</big></p><p>6  is also an equilibrium index, because:</p><p>::::  <big>$A_0 + A_1 + A_2 + A_3 + A_4 + A_5 = 0$</big></p><p>(sum of zero elements is zero)</p><p>7  is not an equilibrium index, because it is not a valid index of sequence <big>$A$</big>.</p>",
        "<p>Write a function that, given a sequence, returns its equilibrium indices (if any).</p><p>Assume that the sequence may be very long.</p>"
      ],
      "solutions": [
        "function equilibrium(a) {\n  let N = a.length,\n    i,\n    l = [],\n    r = [],\n    e = [];\n  for (l[0] = a[0], r[N - 1] = a[N - 1], i = 1; i < N; i++)\n    { l[i] = l[i - 1] + a[i], r[N - i - 1] = r[N - i] + a[N - i - 1]; }\n  for (i = 0; i < N; i++)\n    { if (l[i] === r[i]) e.push(i); }\n  return e;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>equilibrium</code> is a function.",
          "testString":
            "assert(typeof equilibrium === 'function', '<code>equilibrium</code> is a function.');"
        },
        {
          "text":
            "<code>equilibrium([-7, 1, 5, 2, -4, 3, 0])</code> should return <code>[3,6]</code>.",
          "testString":
            "assert.deepEqual(equilibrium(tests[0]), ans[0], '<code>equilibrium([-7, 1, 5, 2, -4, 3, 0])</code> should return <code>[3,6]</code>.');"
        },
        {
          "text":
            "<code>equilibrium([2, 4, 6])</code> should return <code>[]</code>.",
          "testString":
            "assert.deepEqual(equilibrium(tests[1]), ans[1], '<code>equilibrium([2, 4, 6])</code> should return <code>[]</code>.');"
        },
        {
          "text":
            "<code>equilibrium([2, 9, 2])</code> should return <code>[1]</code>.",
          "testString":
            "assert.deepEqual(equilibrium(tests[2]), ans[2], '<code>equilibrium([2, 9, 2])</code> should return <code>[1]</code>.');"
        },
        {
          "text":
            "<code>equilibrium([1, -1, 1, -1, 1, -1, 1])</code> should return <code>[0,1,2,3,4,5,6]</code>.",
          "testString":
            "assert.deepEqual(equilibrium(tests[3]), ans[3], '<code>equilibrium([1, -1, 1, -1, 1, -1, 1])</code> should return <code>[0,1,2,3,4,5,6]</code>.');"
        },
        {
          "text":
            "<code>equilibrium([1])</code> should return <code>[0]</code>.",
          "testString":
            "assert.deepEqual(equilibrium(tests[4]), ans[4], '<code>equilibrium([1])</code> should return <code>[0]</code>.');"
        },
        {
          "text": "<code>equilibrium([])</code> should return <code>[]</code>.",
          "testString":
            "assert.deepEqual(equilibrium(tests[5]), ans[5], '<code>equilibrium([])</code> should return <code>[]</code>.');"
        }
      ],
      "id": "5987fd532b954e0f21b5d3f6",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function equilibrium (a) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "const tests =",
            "  [[-7, 1, 5, 2, -4, 3, 0], // 3, 6",
            "  [2, 4, 6], // empty",
            "  [2, 9, 2], // 1",
            "  [1, -1, 1, -1, 1, -1, 1], // 0,1,2,3,4,5,6",
            "  [1], // 0",
            "  [] // empty",
            "  ];",
            "const ans = [[3, 6], [], [1], [0, 1, 2, 3, 4, 5, 6], [0], []];"
          ]
        }
      }
    },
    {
      "title": "Ethiopian multiplication",
      "description": [
        "<p>Ethiopian multiplication is a method of multiplying integers using only addition, doubling, and halving.</p>",
        "<p>Method: </p>",
        "Take two numbers to be multiplied and write them down at the top of two columns.",
        "In the left-hand column repeatedly halve the last number, discarding any remainders, and write the result below the last in the same column, until you write a value of 1.",
        "In the right-hand column repeatedly double the last number and write the result below. stop when you add a result in the same row as where the left hand column shows 1.",
        "Examine the table produced and discard any row where the value in the left column is even.",
        "Sum the values in the right-hand column that remain to produce the result of multiplying the original two numbers together",
        "<p>For example:  17 &times; 34</p>",
        "<p>17    34</p>",
        "<p>Halving the first column:</p>",
        "<p>17    34</p>",
        "<p>8</p>",
        "<p>4</p>",
        "<p>2</p>",
        "<p>1</p>",
        "<p>Doubling the second column:</p>",
        "<p>17    34</p>",
        "<p>8    68</p>",
        "<p>4   136</p>",
        "<p>2   272</p>",
        "<p>1   544</p>",
        "<p>Strike-out rows whose first cell is even:</p>",
        "<p>17    34</p>",
        "<p>8    <strike>68</strike></p>",
        "<p>4   <strike>136</strike></p>",
        "<p>2   <strike>272</strike></p>",
        "<p>1   544</p>",
        "<p>Sum the remaining numbers in the right-hand column:</p>",
        "<p>17    34</p>",
        "<p>8    --</p>",
        "<p>4   ---</p>",
        "<p>2   ---</p>",
        "<p>1   544</p>",
        "<p>====</p>",
        "<p>578</p>",
        "<p>So 17 multiplied by 34, by the Ethiopian method is 578.</p>",
        "Task:",
        "<p>The task is to define three named functions/methods/procedures/subroutines:</p>",
        "one to halve an integer,",
        "one to double an integer, and",
        "one to state if an integer is even.",
        "<p>Use these functions to create a function that does Ethiopian multiplication.</p>"
      ],
      "solutions": [
        "function eth_mult(a, b) {\n  let sum = 0; a = [a]; b = [b];\n\n  let half = a => a / 2,\n    double = a => a * 2,\n    is_even = a => a % 2 == 0;\n\n  while (a[0] !== 1) {\n    a.unshift(Math.floor(half(a[0])));\n    b.unshift(double(b[0]));\n  }\n\n  for (let i = a.length - 1; i > 0; i -= 1) {\n    if (!is_even(a[i])) {\n      sum += b[i];\n    }\n  }\n  return sum + b[0];\n}"
      ],
      "tests": [
        {
          "text": "<code>eth_mult</code> is a function.",
          "testString":
            "assert(typeof eth_mult === 'function', '<code>eth_mult</code> is a function.');"
        },
        {
          "text":
            "<code>eth_mult(17,34)</code> should return <code>578</code>.",
          "testString":
            "assert.equal(eth_mult(17, 34), 578, '<code>eth_mult(17,34)</code> should return <code>578</code>.');"
        },
        {
          "text":
            "<code>eth_mult(23,46)</code> should return <code>1058</code>.",
          "testString":
            "assert.equal(eth_mult(23, 46), 1058, '<code>eth_mult(23,46)</code> should return <code>1058</code>.');"
        },
        {
          "text":
            "<code>eth_mult(12,27)</code> should return <code>324</code>.",
          "testString":
            "assert.equal(eth_mult(12, 27), 324, '<code>eth_mult(12,27)</code> should return <code>324</code>.');"
        },
        {
          "text":
            "<code>eth_mult(56,98)</code> should return <code>5488</code>.",
          "testString":
            "assert.equal(eth_mult(56, 98), 5488, '<code>eth_mult(56,98)</code> should return <code>5488</code>.');"
        },
        {
          "text":
            "<code>eth_mult(63,74)</code> should return <code>4662</code>.",
          "testString":
            "assert.equal(eth_mult(63, 74), 4662, '<code>eth_mult(63,74)</code> should return <code>4662</code>.');"
        }
      ],
      "id": "599d1566a02b571412643b84",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function eth_mult (a, b) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Euler method",
      "description": [
        "<p>Euler's method numerically approximates solutions of first-order ordinary differential equations (ODEs) with a given initial value.  It is an explicit method for solving initial value problems (IVPs), as described in <a href=\"https://en.wikipedia.org/wiki/Euler method\" title=\"wp: Euler method\">the wikipedia page</a>.</p><p>The ODE has to be provided in the following form:</p><p>:: <big>$\\frac{dy(t)}{dt} = f(t,y(t))$</big></p><p>with an initial value</p><p>:: <big>$y(t_0) = y_0$</big></p><p>To get a numeric solution, we replace the derivative on the  LHS  with a finite difference approximation:</p><p>:: <big>$\\frac{dy(t)}{dt}  \\approx \\frac{y(t+h)-y(t)}{h}$</big></p><p>then solve for $y(t+h)$:</p><p>:: <big>$y(t+h) \\approx y(t) + h \\, \\frac{dy(t)}{dt}$</big></p><p>which is the same as</p><p>:: <big>$y(t+h) \\approx y(t) + h \\, f(t,y(t))$</big></p><p>The iterative solution rule is then:</p><p>:: <big>$y_{n+1} = y_n + h \\, f(t_n, y_n)$</big></p><p>where  <big>$h$</big>  is the step size, the most relevant parameter for accuracy of the solution.  A smaller step size increases accuracy but also the computation cost, so it has always has to be hand-picked according to the problem at hand.</p>",
        "<p>Example: Newton's Cooling Law</p><p>Newton's cooling law describes how an object of initial temperature  <big>$T(t_0) = T_0$</big>  cools down in an environment of temperature  <big>$T_R$</big>:</p><p>:: <big>$\\frac{dT(t)}{dt} = -k \\, \\Delta T$</big></p>",
        "<p>or</p>",
        "<p>:: <big>$\\frac{dT(t)}{dt} = -k \\, (T(t) - T_R)$</big></p>",
        "<p>It says that the cooling rate  <big>$\\frac{dT(t)}{dt}$</big>  of the object is proportional to the current temperature difference  <big>$\\Delta T = (T(t) - T_R)$</big>  to the surrounding environment.</p><p>The analytical solution, which we will compare to the numerical approximation, is</p>",
        "<p>:: <big>$T(t) = T_R + (T_0 - T_R) \\; e^{-k t}$</big></p>",
        "Task:",
        "<p>Implement a routine of Euler's method and then to use it to solve the given example of Newton's cooling law with it for three different step sizes of:</p>",
        "<p>::*  2 s</p>",
        "<p>::*  5 s    and </p>",
        "<p>::*  10 s </p>",
        "<p>and to compare with the analytical solution.</p>",
        "Initial values:",
        "<p>::*  initial temperature  <big>$T_0$</big>  shall be  100 °C</p>",
        "<p>::*  room temperature  <big>$T_R$</big>  shall be  20 °C</p>",
        "<p>::*  cooling constant   <big>$k$</big>   shall be  0.07  </p>",
        "<p>::*  time interval to calculate shall be from  0 s  ──►  100 s</p>"
      ],
      "solutions": [
        "function eulersMethod(x1, y1, x2, h) {\n  let x = x1;\n  let y = y1;\n\n  while ((x < x2 && x1 < x2) || (x > x2 && x1 > x2)) {\n    y += h * (-0.07 * (y - 20));\n    x += h;\n  }\n\n  return y;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>eulersMethod</code> is a function.",
          "testString":
            "assert(typeof eulersMethod === 'function', '<code>eulersMethod</code> is a function.');"
        },
        {
          "text":
            "<code>eulersMethod(0, 100, 100, 10)</code> should return a number.",
          "testString":
            "assert(typeof eulersMethod(0, 100, 100, 10) === 'number', '<code>eulersMethod(0, 100, 100, 10)</code> should return a number.');"
        },
        {
          "text":
            "<code>eulersMethod(0, 100, 100, 10)</code> should return 20.0424631833732.",
          "testString":
            "assert.equal(eulersMethod(0, 100, 100, 2), 20.0424631833732, '<code>eulersMethod(0, 100, 100, 10)</code> should return 20.0424631833732.');"
        },
        {
          "text":
            "<code>eulersMethod(0, 100, 100, 10)</code> should return 20.01449963666907.",
          "testString":
            "assert.equal(eulersMethod(0, 100, 100, 5), 20.01449963666907, '<code>eulersMethod(0, 100, 100, 10)</code> should return 20.01449963666907.');"
        },
        {
          "text":
            "<code>eulersMethod(0, 100, 100, 10)</code> should return 20.000472392.",
          "testString":
            "assert.equal(eulersMethod(0, 100, 100, 10), 20.000472392, '<code>eulersMethod(0, 100, 100, 10)</code> should return 20.000472392.');"
        }
      ],
      "id": "59880443fb36441083c6c20e",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function eulersMethod (x1, y1, x2, h) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Evaluate binomial coefficients",
      "description": [
        "<p>Write a function to calculate the binomial coefficient for the given value of n and k.</p><p>This formula is recommended:</p>",
        "$\\binom{n}{k} = \\frac{n!}{(n-k)!k!} = \\frac{n(n-1)(n-2)\\ldots(n-k+1)}{k(k-1)(k-2)\\ldots 1}$"
      ],
      "solutions": [
        "function binom(n, k) {\n  let coeff = 1;\n  for (let i = n - k + 1; i <= n; i++) coeff *= i;\n  for (let i = 1; i <= k; i++) coeff /= i;\n  return coeff;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>binom</code> is a function.",
          "testString":
            "assert(typeof binom === 'function', '<code>binom</code> is a function.');"
        },
        {
          "text": "<code>binom(5,3)</code> should return 10.",
          "testString":
            "assert.equal(binom(5, 3), 10, '<code>binom(5,3)</code> should return 10.');"
        },
        {
          "text": "<code>binom(7,2)</code> should return 21.",
          "testString":
            "assert.equal(binom(7, 2), 21, '<code>binom(7,2)</code> should return 21.');"
        },
        {
          "text": "<code>binom(10,4)</code> should return 210.",
          "testString":
            "assert.equal(binom(10, 4), 210, '<code>binom(10,4)</code> should return 210.');"
        },
        {
          "text": "<code>binom(6,1)</code> should return 6.",
          "testString":
            "assert.equal(binom(6, 1), 6, '<code>binom(6,1)</code> should return 6.');"
        },
        {
          "text": "<code>binom(12,8)</code> should return 495.",
          "testString":
            "assert.equal(binom(12, 8), 495, '<code>binom(12,8)</code> should return 495.');"
        }
      ],
      "id": "598de241872ef8353c58a7a2",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function binom (n, k) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Execute a Markov algorithm",
      "description": [
        "Task:",
        "<p>Create an interpreter for a <a href=\"https://en.wikipedia.org/wiki/Markov algorithm\" title=\"wp: Markov algorithm\">Markov Algorithm</a>.</p><p>Rules have the syntax:</p>",
        "<p><ruleset> ::= ((<comment> | <rule>) <newline>+)*</p>",
        "<p><comment> ::= # {<any character>}</p>",
        "<p><rule> ::= <pattern> <whitespace> -> <whitespace> [.] <replacement></p>",
        "<p><whitespace> ::= (<tab> | <space>) [<whitespace>]</p>",
        "<p>There is one rule per line.</p><p>If there is a  <b>.</b>  (period)  present before the  <replacement>,  then this is a terminating rule in which case the interpreter must halt execution.</p><p>A ruleset consists of a sequence of rules, with optional comments.</p>",
        "<p><big><big> Rulesets </big></big></p><p>Use the following tests on entries:</p>",
        "Ruleset 1:",
        "<pre>",
        "This rules file is extracted from Wikipedia:",
        "http://en.wikipedia.org/wiki/Markov_AlgorithmA -> apple",
        "B -> bag",
        "S -> shop",
        "T -> the",
        "the shop -> my brother",
        "a never used -> .terminating rule",
        "</pre>",
        "<p>Sample text of:</p>",
        "<p> <code> I bought a B of As from T S. </code></p>",
        "<p>Should generate the output:</p>",
        "<p> <code> I bought a bag of apples from my brother. </code></p>",
        "Ruleset 2:",
        "<p>A test of the terminating rule</p>",
        "<pre>",
        "Slightly modified from the rules on WikipediaA -> apple",
        "B -> bag",
        "S -> .shop",
        "T -> the",
        "the shop -> my brother",
        "a never used -> .terminating rule</pre>",
        "<p>Sample text of:</p>",
        "<p> <code>I bought a B of As from T S.</code></p>",
        "<p>Should generate:</p>",
        "<p> <code>I bought a bag of apples from T shop.</code></p>",
        "Ruleset 3:",
        "<p>This tests for correct substitution order and may trap simple regexp based replacement routines if special regexp characters are not escaped.</p>",
        "<pre>",
        "BNF Syntax testing rulesA -> apple",
        "WWWW -> with",
        "Bgage -> ->.*",
        "B -> bag",
        "->.* -> money",
        "W -> WW",
        "S -> .shop",
        "T -> the",
        "the shop -> my brother",
        "a never used -> .terminating rule",
        "</pre>",
        "<p>Sample text of:</p>",
        "<p> <code>I bought a B of As W my Bgage from T S.</code></p>",
        "<p>Should generate:</p>",
        "<p> <code>I bought a bag of apples with my money from T shop.</code></p>",
        "Ruleset 4:",
        "<p>This tests for correct order of scanning of rules, and may trap replacement routines that scan in the wrong order.  It implements a general unary multiplication engine.  (Note that the input expression must be placed within underscores in this implementation.)</p>",
        "<pre>",
        "## Unary Multiplication Engine, for testing Markov Algorithm implementations",
        "## By Donal Fellows.",
        "Unary addition engine_+1 -> _1+",
        "1+1 -> 11+",
        "Pass for converting from the splitting of multiplication into ordinary",
        "addition1! -> !1",
        ",! -> !+",
        "_! -> _",
        "Unary multiplication by duplicating left side, right side times1*1 -> x,@y",
        "1x -> xX",
        "X, -> 1,1",
        "X1 -> 1X",
        "_x -> _X",
        ",x -> ,X",
        "y1 -> 1y",
        "y_ -> _",
        "Next phase of applying1@1 -> x,@y",
        "1@_ -> @_",
        ",@_ -> !_",
        "++ -> +",
        "Termination cleanup for addition_1 -> 1",
        "1+_ -> 1",
        "_+_ -> ",
        "</pre>",
        "<p>Sample text of:</p>",
        "<p> <code> _1111*11111_ </code></p>",
        "<p>should generate the output:</p>",
        "<p> <code> 11111111111111111111 </code></p>",
        "Ruleset 5:",
        "<p>A simple <a href=\"http://en.wikipedia.org/wiki/Turing_machine\" title=\"link: http://en.wikipedia.org/wiki/Turing_machine\">Turing machine</a>,</p>",
        "<p>implementing a three-state <a href=\"http://en.wikipedia.org/wiki/Busy_beaver\" title=\"link: http://en.wikipedia.org/wiki/Busy_beaver\">busy beaver</a>.</p><p>The tape consists of 0s and 1s,  the states are A, B, C and H (for Halt), and the head position is indicated by writing the state letter before the character where the head is.</p>",
        "<p>All parts of the initial tape the machine operates on have to be given in the input.</p><p>Besides demonstrating that the Markov algorithm is Turing-complete, it also made me catch a bug in the C++ implementation which wasn't caught by the first four rulesets.</p>",
        "<pre>",
        "Turing machine: three-state busy beaver",
        "# state A, symbol 0 => write 1, move right, new state BA0 -> 1B",
        "state A, symbol 1 => write 1, move left, new state C0A1 -> C01",
        "1A1 -> C11",
        "state B, symbol 0 => write 1, move left, new state A0B0 -> A01",
        "1B0 -> A11",
        "state B, symbol 1 => write 1, move right, new state BB1 -> 1B",
        "state C, symbol 0 => write 1, move left, new state B0C0 -> B01",
        "1C0 -> B11",
        "state C, symbol 1 => write 1, move left, halt0C1 -> H01",
        "1C1 -> H11",
        "</pre>",
        "<p>This ruleset should turn</p>",
        "<p> <code> 000000A000000 </code></p>",
        "<p>into</p>",
        "<p> <code> 00011H1111000 </code></p>"
      ],
      "solutions": [
        "function markov(rules,test) {\n    let pattern = new RegExp(\"^([^#]*?)\\\\s+->\\\\s+(\\\\.?)(.*)\");\n    let origTest = test;\n\n    let captures = [];\n    \n    rules.forEach(function(rule){\n\t\tlet m = pattern.exec(rule);\n\t\tfor (let j = 0; j < m.length; j++)\n\t\t    m[j] = m[j + 1];\n\t\tcaptures.push(m);\n    });\n\n    test = origTest;\n    let copy = test;\n    for (let j = 0; j < captures.length; j++) {\n        let c = captures[j];\n        test = test.replace(c[0], c[2]);\n        if (c[1]==\".\")\n            break;\n        if (test!=copy) {\n            j = -1;\n            copy = test;\n        }\n    }\n    return test;\n}\n\n// tail:\nlet rules=[[\"A -> apple\",\"B -> bag\",\"S -> shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\n\t\t\t[\"A -> apple\",\"B -> bag\",\"S -> .shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\n\t\t\t[\"A -> apple\",\"WWWW -> with\",\"Bgage -> ->.*\",\"B -> bag\",\"->.* -> money\",\"W -> WW\",\"S -> .shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\n\t\t\t[\"_+1 -> _1+\",\"1+1 -> 11+\",\"1! -> !1\",\",! -> !+\",\"_! -> _\",\"1*1 -> x,@y\",\"1x -> xX\",\"X, -> 1,1\",\"X1 -> 1X\",\"_x -> _X\",\",x -> ,X\",\"y1 -> 1y\",\"y_ -> _\",\"1@1 -> x,@y\",\"1@_ -> @_\",\",@_ -> !_\",\"++ -> +\",\"_1 -> 1\",\"1+_ -> 1\",\"_+_ -> \"],\n\t\t\t[\"A0 -> 1B\",\"0A1 -> C01\",\"1A1 -> C11\",\"0B0 -> A01\",\"1B0 -> A11\",\"B1 -> 1B\",\"0C0 -> B01\",\"1C0 -> B11\",\"0C1 -> H01\",\"1C1 -> H11\"]];\nlet tests=[\"I bought a B of As from T S.\",\n\t\t\t\"I bought a B of As from T S.\",\n\t\t\t\"I bought a B of As W my Bgage from T S.\",\n\t\t\t\"_1111*11111_\",\n\t\t\t\"000000A000000\"];\nlet outputs=[\"I bought a bag of apples from my brother.\",\n\t\t\t\"I bought a bag of apples from T shop.\",\n\t\t\t\"I bought a bag of apples with my money from T shop.\",\n\t\t\t\"11111111111111111111\",\n\t\t\t\"00011H1111000\"];"
      ],
      "tests": [
        {
          "text": "<code>markov</code> is a function.",
          "testString":
            "assert(typeof markov === 'function', '<code>markov</code> is a function.');"
        },
        {
          "text":
            "<code>markov([\"A -> apple\",\"B -> bag\",\"S -> shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\"I bought a B of As from T S.\")</code> should return \"I bought a bag of apples from my brother.\".",
          "testString":
            "assert.deepEqual(markov(rules[0],tests[0]),outputs[0],'<code>markov([\"A -> apple\",\"B -> bag\",\"S -> shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\"I bought a B of As from T S.\")</code> should return \"I bought a bag of apples from my brother.\".');"
        },
        {
          "text":
            "<code>markov([\"A -> apple\",\"B -> bag\",\"S -> .shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\"I bought a B of As from T S.\")</code> should return \"I bought a bag of apples from T shop.\".",
          "testString":
            "assert.deepEqual(markov(rules[1],tests[1]),outputs[1],'<code>markov([\"A -> apple\",\"B -> bag\",\"S -> .shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\"I bought a B of As from T S.\")</code> should return \"I bought a bag of apples from T shop.\".');"
        },
        {
          "text":
            "<code>markov([\"A -> apple\",\"WWWW -> with\",\"Bgage -> ->.*\",\"B -> bag\",\"->.* -> money\",\"W -> WW\",\"S -> .shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\"I bought a B of As W my Bgage from T S.\")</code> should return \"I bought a bag of apples with my money from T shop.\".",
          "testString":
            "assert.deepEqual(markov(rules[2],tests[2]),outputs[2],'<code>markov([\"A -> apple\",\"WWWW -> with\",\"Bgage -> ->.*\",\"B -> bag\",\"->.* -> money\",\"W -> WW\",\"S -> .shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\"I bought a B of As W my Bgage from T S.\")</code> should return \"I bought a bag of apples with my money from T shop.\".');"
        },
        {
          "text":
            "<code>markov([\"_+1 -> _1+\",\"1+1 -> 11+\",\"1! -> !1\",\",! -> !+\",\"_! -> _\",\"1*1 -> x,@y\",\"1x -> xX\",\"X, -> 1,1\",\"X1 -> 1X\",\"_x -> _X\",\",x -> ,X\",\"y1 -> 1y\",\"y_ -> _\",\"1@1 -> x,@y\",\"1@_ -> @_\",\",@_ -> !_\",\"++ -> +\",\"_1 -> 1\",\"1+_ -> 1\",\"_+_ -> \"],\"_1111*11111_\")</code> should return \"11111111111111111111\".",
          "testString":
            "assert.deepEqual(markov(rules[3],tests[3]),outputs[3],'<code>markov([\"_+1 -> _1+\",\"1+1 -> 11+\",\"1! -> !1\",\",! -> !+\",\"_! -> _\",\"1*1 -> x,@y\",\"1x -> xX\",\"X, -> 1,1\",\"X1 -> 1X\",\"_x -> _X\",\",x -> ,X\",\"y1 -> 1y\",\"y_ -> _\",\"1@1 -> x,@y\",\"1@_ -> @_\",\",@_ -> !_\",\"++ -> +\",\"_1 -> 1\",\"1+_ -> 1\",\"_+_ -> \"],\"_1111*11111_\")</code> should return \"11111111111111111111\".');"
        },
        {
          "text":
            "<code>markov([\"A0 -> 1B\",\"0A1 -> C01\",\"1A1 -> C11\",\"0B0 -> A01\",\"1B0 -> A11\",\"B1 -> 1B\",\"0C0 -> B01\",\"1C0 -> B11\",\"0C1 -> H01\",\"1C1 -> H11\"],\"\")</code> should return \"00011H1111000\".",
          "testString":
            "assert.deepEqual(markov(rules[4],tests[4]),outputs[4],'<code>markov([\"A0 -> 1B\",\"0A1 -> C01\",\"1A1 -> C11\",\"0B0 -> A01\",\"1B0 -> A11\",\"B1 -> 1B\",\"0C0 -> B01\",\"1C0 -> B11\",\"0C1 -> H01\",\"1C1 -> H11\"],\"\")</code> should return \"00011H1111000\".');"
        }
      ],
      "id": "59e09e6d412c5939baa02d16",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function markov (rules,test) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Execute Brain****",
      "description": [
        "<p>Write a function to implement a Brain**** interpreter. The function will take a string as a parameter and should return a string as the output. More details are given below : </p>",
        "<p>RCBF is a set of <a href=\"http://rosettacode.org/wiki/Brainf***\" title=\"Brainf***\">Brainf***</a> compilers and interpreters written for Rosetta Code in a variety of languages.</p><p>Below are links to each of the versions of RCBF.</p><p>An implementation need only properly implement the following instructions:</p>",
        "<p>{|</p>",
        "<p>!Command</p>",
        "<p>!Description</p>",
        "<p>|-</p>",
        "<p>| style=\"text-align:center\"| <code>&gt;</code> || Move the pointer to the right</p>",
        "<p>|-</p>",
        "<p>| style=\"text-align:center\"| <code>&lt;</code> || Move the pointer to the left</p>",
        "<p>|-</p>",
        "<p>| style=\"text-align:center\"| <code>+</code> || Increment the memory cell under the pointer</p>",
        "<p>|-</p>",
        "<p>| style=\"text-align:center\"| <code>-</code> || Decrement the memory cell under the pointer</p>",
        "<p>|-</p>",
        "<p>| style=\"text-align:center\"| <code>.</code> || Output the character signified by the cell at the pointer</p>",
        "<p>|-</p>",
        "<p>| style=\"text-align:center\"| <code>,</code> || Input a character and store it in the cell at the pointer</p>",
        "<p>|-</p>",
        "<p>| style=\"text-align:center\"| <code>[</code> || Jump past the matching <code>]</code> if the cell under the pointer is 0</p>",
        "<p>|-</p>",
        "<p>| style=\"text-align:center\"| <code>]</code> || Jump back to the matching <code>[</code> if the cell under the pointer is nonzero</p>",
        "<p>|}</p>",
        "<p>Any cell size is allowed,  EOF   (<u>E</u>nd-<u>O</u>-<u>F</u>ile)  support is optional, as is whether you have bounded or unbounded memory.</p>",
        ""
      ],
      "solutions": [
        "function brain(prog){\n  var output=\"\";\n\tvar code; // formatted code\n  var ip = 0; // current instruction within code\n  var nest = 0; // current bracket nesting (for Out button)\n  var ahead = []; // locations of matching brackets\n\n  var data = [0]; // data array (mod by +, -)\n  var dp = 0; // index into data (mod by <, >)\n\n  var inp = 0; // current input character (fetch with ,)\n  var quit = 0;\n\tvar commands = {\n\t'>':function() { if (++dp >= data.length) data[dp]=0 },\n\t'<':function() { if (--dp < 0) quit++ },\n\t'+':function() { ++data[dp] },\n\t'-':function() { --data[dp] },\n\t'[':function() { if (!data[dp]) ip = ahead[ip]; else ++nest },\n\t']':function() { if ( data[dp]) ip = ahead[ip]; else --nest },\n\t',':function() {\n\t\tvar c = document.getElementById(\"input\").value.charCodeAt(inp++);\n\t\tdata[dp] = isNaN(c) ? 0 : c; // EOF: other options are -1 or no change\n\t},\n\t'.':function() {\n    \t\toutput+=String.fromCharCode(data[dp]);\n    \t\t/*var s = document.getElementById(\"output\").innerHTML)\n    \t\t + String.fromCharCode(data[dp]);\n    \t\ts = s.replace(/\\n/g,\"<br>\").replace(/ /g,\"&amp;nbsp;\");\n    \t\tdocument.getElementById(\"output\").innerHTML = s;*/\n    \t},\n    };\n\n\tlet ar=prog.split('');\n\tvar st = [], back, error = -1;\n\tfor (ip=0; ip<ar.length; ip++) {\n\t\tswitch(ar[ip]) {\n\t\tcase '[':\n\t\t\tst.push(ip);\n\t\t\tbreak;\n\t\tcase ']':\n\t\t\tif (st.length == 0) error = ip;\n\t\t\tback = st.pop();\n\t\t\tahead[ip] = back;\n\t\t\tahead[back] = ip;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor(ip=0;ip<ar.length;ip++){\n    if(commands.hasOwnProperty(ar[ip]))\n\t\t  commands[ar[ip]]();\n\t}\n\n\treturn output;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>brain(bye)</code> should retuen a string",
          "testString":
            "assert(typeof brain(bye) === 'string', '<code>brain(bye)</code> should return a string');"
        },
        {
          "text":
            "<code>brain(\"++++++[>++++++++++<-]>+++++.\")</code should return \"A\"",
          "testString":
            "assert.equal(brain(\"++++++[>++++++++++<-]>+++++.\"),\"A\", '<code>brain(\"++++++[>++++++++++<-]>+++++.\")</code should return \"A\"');"
        },
        {
          "text":
            "<code>brain(bye)</code> should return <code>Goodbye, World!\\\\r\\\\n</code>",
          "testString":
            "assert.equal(brain(bye), 'Goodbye, World!\\r\\n', '<code>brain(bye)</code> should return <code>Goodbye, World!\\\\r\\\\n</code>');"
        },
        {
          "text":
            "<code>brain(hello)</code> should return <code>Hello World!\\\\n</code>'",
          "testString":
            "assert.equal(brain(hello), \"Hello World!\\n\", '<code>brain(hello)</code> should return <code>Hello World!\\\\n</code>');"
        },
        {
          "text":
            "<code>brain(fib)</code> should return <code>1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89</code>",
          "testString":
            "assert.equal(brain(fib), \"1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89\", '<code>brain(fib)</code> should return <code>1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89</code>');"
        }
      ],
      "id": "59e0a8df964e4540d5abe599",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function brain (prog) {", "  // Good luck!", "}"],
          "head": [
            "let fib=`+\n\n++\n\n+++\n\n++++\n\n+>+>>\n\n>>++++\n\n+++++++\n\n++++++++\n\n+++++++++\n\n++++++++++\n\n++++++>++++\n\n++++++++++++\n\n+++++++++++++\n\n+++<<<<<<[>[>>\n\n>>>>+>+<<<<<<<-\n\n]>>>>>>>[<<<<<<<\n\n+>>>>>>>-]<[>++++\n\n++++++[-<-[>>+>+<<\n\n<-]>>>[<<<+>>>-]+<[\n\n>[-]<[-]]>[<<[>>>+<<\n\n<-]>>[-]]<<]>>>[>>+>+\n\n<<<-]>>>[<<<+>>>-]+<[>\n\n[-]<[-]]>[<<+>>[-]]<<<<\n\n<<<]>>>>>[++++++++++++++\n\n+++++++++++++++++++++++++\n\n+++++++++.[-]]++++++++++<[\n\n->-<]>+++++++++++++++++++++\n\n+++++++++++++++++++++++++++.\n\n[-]<<<<<<<<<<<<[>>>+>+<<<<-]>\n\n>>>[<<<<+>>>>-]<-[>>.>.<<<[-]]\n\n<<[>>+>+<<<-]>>>[<<<+>>>-]<<[<+\n\n>-]>[<+>-]<<<-]`;",
            "let hello='++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.'",
            "let bye='++++++++++[>+>+++>++++>+++++++>++++++++>+++++++++>++++++++++>+++++++++++>++++++++++++<<<<<<<<<-]>>>>+.>>>>+..<.<++++++++.>>>+.<<+.<<<<++++.<++.>>>+++++++.>>>.+++.<+++++++.--------.<<<<<+.<+++.---.';"
          ],
          "tail": []
        }
      }
    },
    {
      "title": "Extensible prime generator",
      "description": [
        "<p>Write a generator of prime numbers, in order, that will automatically adjust to accommodate the generation of any reasonably high prime.</p> The generator should be able to : Show the first <b>n</b> prime numbers.Show the prime numbers in a range.Show the number of primes in a range.Show the <b>n<sup>th</sup></b> prime number.<p>The function should have two parameters. The first will receive <b>n</b> or the range as an array. The second will receive a boolean, that specifies if the function returns the prime numbers as an array or a single number(the number of primes in the range or the <b>n<sup>th</sup></b> prime). According to the parameters the function should return an array."
      ],
      "solutions": [
        "// noprotect\nfunction primeGenerator(num, showPrimes) {\n  let i,\n    arr = [];\n\n  function isPrime(num) {\n    // try primes <= 16\n    if (num <= 16) { return (\n      num == 2 || num == 3 || num == 5 || num == 7 || num == 11 || num == 13\n    ); }\n    // cull multiples of 2, 3, 5 or 7\n    if (num % 2 == 0 || num % 3 == 0 || num % 5 == 0 || num % 7 == 0)\n      { return false; }\n    // cull square numbers ending in 1, 3, 7 or 9\n    for (let i = 10; i * i <= num; i += 10) {\n      if (num % (i + 1) == 0) return false;\n      if (num % (i + 3) == 0) return false;\n      if (num % (i + 7) == 0) return false;\n      if (num % (i + 9) == 0) return false;\n    }\n    return true;\n  }\n\n  if (typeof num === 'number') {\n    for (i = 0; arr.length < num; i++) if (isPrime(i)) arr.push(i);\n    // first x primes\n    if (showPrimes) return arr;\n    // xth prime\n    return arr.pop();\n  }\n\n  if (Array.isArray(num)) {\n    for (i = num[0]; i <= num[1]; i++) if (isPrime(i)) arr.push(i);\n    // primes between x .. y\n    if (showPrimes) return arr;\n    // number of primes between x .. y\n    return arr.length;\n  }\n}\n"
      ],
      "tests": [
        {
          "text": "<code>primeGenerator</code> is a function.",
          "testString":
            "assert(typeof primeGenerator === 'function', '<code>primeGenerator</code> is a function.');"
        },
        {
          "text": "<code>primeGenerator</code> is a function.",
          "testString":
            "assert.deepEqual(primeGenerator(20, true), [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71], '<code>primeGenerator</code> is a function.');"
        },
        {
          "text": "<code>primeGenerator</code> is a function.",
          "testString":
            "assert.deepEqual(primeGenerator([100, 150], true), [101, 103, 107, 109, 113, 127, 131, 137, 139, 149], '<code>primeGenerator</code> is a function.');"
        },
        {
          "text": "<code>primeGenerator</code> is a function.",
          "testString":
            "assert.equal(primeGenerator([7700, 8000], false), 30, '<code>primeGenerator</code> is a function.');"
        },
        {
          "text": "<code>primeGenerator</code> is a function.",
          "testString":
            "assert.equal(primeGenerator(10000, false), 104729, '<code>primeGenerator</code> is a function.');"
        }
      ],
      "id": "598ee8b91b410510ae82efef",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function primeGenerator (num, showPrimes) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Factorial",
      "description": [
        "<p>Write a function to return the factorial of a number.</p>",
        "<p>Factorial of a number is given by : </p>",
        "n! = n * (n-1) * (n-2) * ..... * 1",
        "<p>",
        "For example :",
        "3! = 3*2*1 = 6",
        "4! = 4*3*2*1 = 24",
        "</p>",
        "<p>Note : ",
        "0! = 1 ",
        "</p>"
      ],
      "solutions": [
        "function factorial(n) {\n  let sum = 1;\n  while (n > 1) {\n    sum *= n;\n    n--;\n  }\n  return sum;\n}\n\n"
      ],
      "tests": [
        {
          "text": "<code>factorial</code> is a function.",
          "testString":
            "assert(typeof factorial === 'function', '<code>factorial</code> is a function.');"
        },
        {
          "text": "<code>factorial(2)</code> should return a number.",
          "testString":
            "assert(typeof factorial(2) === 'number', '<code>factorial(2)</code> should return a number.');"
        },
        {
          "text": "<code>factorial(3)</code> should return 6.\")",
          "testString":
            "assert.equal(factorial(3),results[0],\"<code>factorial(3)</code> should return 6.\");"
        },
        {
          "text": "<code>factorial(3)</code> should return 120.\")",
          "testString":
            "assert.equal(factorial(5),results[1],\"<code>factorial(3)</code> should return 120.\");"
        },
        {
          "text": "<code>factorial(3)</code> should return 3,628,800.\")",
          "testString":
            "assert.equal(factorial(10),results[2],\"<code>factorial(3)</code> should return 3,628,800.\");"
        }
      ],
      "id": "597b2b2a2702b44414742771",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function factorial (n) {", "  // Good luck!", "}"],
          "head": [],
          "tail": ["const results=[6,120,3628800];"]
        }
      }
    },
    {
      "title": "Factors of a Mersenne number",
      "description": [
        "<p>A Mersenne number is a number in the form of 2<sup>P</sup>-1.</p><p>If P is prime, the Mersenne number may be a Mersenne prime</p>",
        "<p>(if P is not prime, the Mersenne number is also not prime).</p><p>In the search for Mersenne prime numbers it is advantageous to eliminate exponents by finding a small factor before starting a,  potentially lengthy, <a href=\"http://rosettacode.org/wiki/Lucas-Lehmer test\" title=\"Lucas-Lehmer test\">Lucas-Lehmer test</a>.</p><p>There are very efficient algorithms for determining if a number divides 2<sup>P</sup>-1 (or equivalently, if 2<sup>P</sup> mod (the number) = 1).</p>",
        "<p>Some languages already have built-in implementations of this exponent-and-mod operation (called modPow or similar).</p><p>The following is how to implement this modPow yourself:</p><p>For example, let's compute 2<sup>23</sup> mod 47.</p>",
        "<p>Convert the exponent 23 to binary, you get 10111. Starting with <tt>square</tt> = 1, repeatedly square it.</p>",
        "<p>Remove the top bit of the exponent, and if it's 1 multiply <tt>square</tt> by the base of the exponentiation (2), then compute <tt>square</tt> modulo 47.</p>",
        "<p>Use the result of the modulo from the last step as the initial value of <tt>square</tt> in the next step:</p><p>Remove   Optional</p>",
        "<p>square        top bit  multiply by 2  mod 47</p>",
        "<p>------------  -------  -------------  ------</p>",
        "<p>1*1 = 1       1  0111  1*2 = 2           2</p>",
        "<p>2*2 = 4       0   111     no             4</p>",
        "<p>4*4 = 16      1    11  16*2 = 32        32</p>",
        "<p>32*32 = 1024  1     1  1024*2 = 2048    27</p>",
        "<p>27*27 = 729   1        729*2 = 1458      1</p><p>Since 2<sup>23</sup> mod 47 = 1, 47 is a factor of 2<sup>P</sup>-1.</p>",
        "<p>(To see this, subtract 1 from both sides: 2<sup>23</sup>-1 = 0 mod 47.)</p>",
        "<p>Since we've shown that 47 is a factor, 2<sup>23</sup>-1 is not prime.</p>",
        "<p>Further properties of Mersenne numbers allow us to refine the process even more.</p>",
        "<p>Any factor q of 2<sup>P</sup>-1 must be of the form 2kP+1, k being a positive integer or zero. Furthermore, q must be 1 or 7 mod 8.</p>",
        "<p>Finally any potential factor q must be <a href=\"http://rosettacode.org/wiki/Primality by Trial Division\" title=\"Primality by Trial Division\">prime</a>.</p>",
        "<p>As in other trial division algorithms, the algorithm stops when 2kP+1 > sqrt(N).</p><p>These primality tests only work on Mersenne numbers where P is prime. For example, M<sub>4</sub>=15 yields no factors using these techniques, but factors into 3 and 5, neither of which fit 2kP+1.</p>",
        "Task:",
        "<p>Using the above method find a factor of  2<sup>929</sup>-1 (aka M929)</p>",
        "Related tasks:",
        " <a href=\"http://rosettacode.org/wiki/count in factors\" title=\"count in factors\">count in factors</a>",
        " <a href=\"http://rosettacode.org/wiki/prime decomposition\" title=\"prime decomposition\">prime decomposition</a>",
        " <a href=\"http://rosettacode.org/wiki/factors of an integer\" title=\"factors of an integer\">factors of an integer</a>",
        " <a href=\"http://rosettacode.org/wiki/Sieve of Eratosthenes\" title=\"Sieve of Eratosthenes\">Sieve of Eratosthenes</a>",
        " <a href=\"http://rosettacode.org/wiki/primality by trial division\" title=\"primality by trial division\">primality by trial division</a>",
        " <a href=\"http://rosettacode.org/wiki/trial factoring of a Mersenne number\" title=\"trial factoring of a Mersenne number\">trial factoring of a Mersenne number</a>",
        " <a href=\"http://rosettacode.org/wiki/partition an integer X into N primes\" title=\"partition an integer X into N primes\">partition an integer X into N primes</a>",
        " <a href=\"http://rosettacode.org/wiki/sequence of primes by Trial Division\" title=\"sequence of primes by Trial Division\">sequence of primes by Trial Division</a>",
        " <a href=\"https://www.youtube.com/watch?v=SNwvJ7psoow\" title=\"link: https://www.youtube.com/watch?v=SNwvJ7psoow\">Computers in 1948: 2¹²⁷-1</a>"
      ],
      "solutions": [
        "function check_mersenne(p){  \n\tfunction isPrime(value){\n\t  for (let i=2; i < value; i++){\n\t\tif (value % i == 0){\n\t\t  return false;\n\t\t}\n\t\tif (value % i != 0){\n\t\t  return true;\n\t\t }\n\t  }\n\t}\n\t\n\tfunction trial_factor(base, exp, mod){\n\t  let square, bits;\n\t  square = 1;\n\t  bits = exp.toString(2).split('');\n\t  for (let i=0,ln=bits.length; i<ln; i++){\n\t\tsquare = Math.pow(square, 2) * (bits[i] == 1 ? base : 1) % mod;\n\t  }\n\t  return (square == 1);\n\t}\n\t\n\tfunction mersenne_factor(p){\n\t  let limit, k, q;\n\t  limit = Math.sqrt(Math.pow(2,p) - 1);\n\t  k = 1;\n\t  while ((2*k*p - 1) < limit){\n\t\tq = 2*k*p + 1;\n\t\tif (isPrime(q) && (q % 8 == 1 || q % 8 == 7) && trial_factor(2,p,q)){\n\t\t  return q; // q is a factor of 2**p-1\n\t\t}\n\t\tk++;\n\t  }\n\t  return null;\n\t}\n  let f, result;\n  result=\"M\"+p+\" = 2^\"+p+\"-1 is \";\n  f = mersenne_factor(p);\n  result+=f == null ? \"prime\" : \"composite with factor \"+f;\n  return result;\n}\n\n"
      ],
      "tests": [
        {
          "text": "<code>check_mersenne</code> is a function.",
          "testString":
            "assert(typeof check_mersenne === 'function', '<code>check_mersenne</code> is a function.');"
        },
        {
          "text": "<code>check_mersenne(3)</code> should return a string.",
          "testString":
            "assert(typeof check_mersenne(3) == 'string', '<code>check_mersenne(3)</code> should return a string.');"
        },
        {
          "text":
            "<code>check_mersenne(3)</code> should return \"M3 = 2^3-1 is prime\".",
          "testString":
            "assert.equal(check_mersenne(3),\"M3 = 2^3-1 is prime\",'<code>check_mersenne(3)</code> should return \"M3 = 2^3-1 is prime\".');"
        },
        {
          "text":
            "<code>check_mersenne(23)</code> should return \"M23 = 2^23-1 is composite with factor 47\".",
          "testString":
            "assert.equal(check_mersenne(23),\"M23 = 2^23-1 is composite with factor 47\",'<code>check_mersenne(23)</code> should return \"M23 = 2^23-1 is composite with factor 47\".');"
        },
        {
          "text":
            "<code>check_mersenne(929)</code> should return \"M929 = 2^929-1 is composite with factor 13007",
          "testString":
            "assert.equal(check_mersenne(929),\"M929 = 2^929-1 is composite with factor 13007\",'<code>check_mersenne(929)</code> should return \"M929 = 2^929-1 is composite with factor 13007');"
        }
      ],
      "id": "598eea87e5cf4b116c3ff81a",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function check_mersenne (p) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Factors of an integer",
      "description": [
        "<p>Write a function that returns the factors  of a positive integer.</p><p>These factors are the positive integers by which the number being factored can be divided to yield a positive integer result.</p>",
        "///"
      ],
      "solutions": [
        "function factors(num)\n{\n let n_factors = [], i, sqr=Math.floor(Math.sqrt(num));\n\n for (i = 1; i <=sqr ; i += 1)\n  if (num % i === 0)\n  {\n   n_factors.push(i);\n   if (num / i !== i)\n    n_factors.push(num / i);\n  }\n n_factors.sort(function(a, b){return a - b;});\n return n_factors;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>factors</code> is a function.",
          "testString":
            "assert(typeof factors === 'function', '<code>factors</code> is a function.');"
        },
        {
          "text":
            "<code>factors(45)</code> should return <code>[1,3,5,9,15,45]</code>.",
          "testString":
            "assert.deepEqual(factors(45), ans[0], '<code>factors(45)</code> should return <code>[1,3,5,9,15,45]</code>.');"
        },
        {
          "text": "<code>factors(53)</code> should return <code>[1,53]</code>.",
          "testString":
            "assert.deepEqual(factors(53), ans[1], '<code>factors(53)</code> should return <code>[1,53]</code>.');"
        },
        {
          "text":
            "<code>factors(64)</code> should return <code>[1,2,4,8,16,32,64]</code>.",
          "testString":
            "assert.deepEqual(factors(64), ans[2], '<code>factors(64)</code> should return <code>[1,2,4,8,16,32,64]</code>.');"
        }
      ],
      "id": "597f1e7fbc206f0e9ba95dc4",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function factors (num) {", "  // Good luck!", "}"],
          "head": [],
          "tail": ["const ans=[[1,3,5,9,15,45],[1,53],[1,2,4,8,16,32,64]];"]
        }
      }
    },
    {
      "title": "Farey sequence",
      "description": [
        "<p>Write a function that returns the Farey sequence of order n. The function should have one parameter that is n. It should return the sequence as an array. Read the following for more details : </p><p>The  <a href=\"https://en.wikipedia.org/wiki/Farey sequence\" title=\"wp: Farey sequence\">Farey sequence</a>   F<sub>n</sub>  of order  n  is the sequence of completely reduced fractions between  0  and  1  which, when in lowest terms, have denominators less than or equal to  n,  arranged in order of increasing size.</p><p>The  Farey sequence  is sometimes incorrectly called a  Farey series.</p>",
        "<p>Each Farey sequence:</p>",
        "<p>::*  starts with the value  0,  denoted by the fraction  $ \\frac{0}{1} $</p>",
        "<p>::*  ends with the value  1,  denoted by the fraction  $ \\frac{1}{1}$.</p>",
        "<p>The Farey sequences of orders  1  to  5  are:</p><p>${\\bf\\it{F}}_1 = \\frac{0}{1}, \\frac{1}{1}$</p>",
        "<p></p>",
        "<p>${\\bf\\it{F}}_2 = \\frac{0}{1}, \\frac{1}{2}, \\frac{1}{1}$</p>",
        "<p></p>",
        "<p>${\\bf\\it{F}}_3 = \\frac{0}{1}, \\frac{1}{3}, \\frac{1}{2}, \\frac{2}{3}, \\frac{1}{1}$</p>",
        "<p></p>",
        "<p>${\\bf\\it{F}}_4 = \\frac{0}{1}, \\frac{1}{4}, \\frac{1}{3}, \\frac{1}{2}, \\frac{2}{3}, \\frac{3}{4}, \\frac{1}{1}$</p>",
        "<p></p>",
        "<p>${\\bf\\it{F}}_5 = \\frac{0}{1}, \\frac{1}{5}, \\frac{1}{4}, \\frac{1}{3}, \\frac{2}{5}, \\frac{1}{2}, \\frac{3}{5}, \\frac{2}{3}, \\frac{3}{4}, \\frac{4}{5}, \\frac{1}{1}$</p>"
      ],
      "solutions": [
        "function farey(n){\n\tlet farSeq=[];\n\tfor(let den = 1; den <= n; den++){\n\t\tfor(let num = 1; num < den; num++){\n\t\t\tfarSeq.push({\n\t\t\t\tstr:num+\"/\"+den,\n\t\t\t\tval:num/den});\n\t\t}\n\t}\n\tfarSeq.sort(function(a,b){\n\t\treturn a.val-b.val;\n\t});\n\tfarSeq=farSeq.map(function(a){\n\t\treturn a.str;\n\t});\n\treturn farSeq;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>farey</code> is a function.",
          "testString":
            "assert(typeof farey === 'function', '<code>farey</code> is a function.');"
        },
        {
          "text": "<code>farey(3)</code> should return an array",
          "testString":
            "assert(Array.isArray(farey(3)), '<code>farey(3)</code> should return an array');"
        },
        {
          "text":
            "<code>farey(3)</code> should return <code>[\"1/3\",\"1/2\",\"2/3\"]</code>",
          "testString":
            "assert.deepEqual(farey(3), [\"1/3\",\"1/2\",\"2/3\"], '<code>farey(3)</code> should return <code>[\"1/3\",\"1/2\",\"2/3\"]</code>');"
        },
        {
          "text":
            "<code>farey(4)</code> should return <code>[\"1/4\",\"1/3\",\"1/2\",\"2/4\",\"2/3\",\"3/4\"]</code>",
          "testString":
            "assert.deepEqual(farey(4), [\"1/4\",\"1/3\",\"1/2\",\"2/4\",\"2/3\",\"3/4\"], '<code>farey(4)</code> should return <code>[\"1/4\",\"1/3\",\"1/2\",\"2/4\",\"2/3\",\"3/4\"]</code>');"
        },
        {
          "text":
            "<code>farey(5)</code> should return <code>[\"1/5\",\"1/4\",\"1/3\",\"2/5\",\"1/2\",\"2/4\",\"3/5\",\"2/3\",\"3/4\",\"4/5\"]</code>",
          "testString":
            "assert.deepEqual(farey(5), [\"1/5\",\"1/4\",\"1/3\",\"2/5\",\"1/2\",\"2/4\",\"3/5\",\"2/3\",\"3/4\",\"4/5\"], '<code>farey(5)</code> should return <code>[\"1/5\",\"1/4\",\"1/3\",\"2/5\",\"1/2\",\"2/4\",\"3/5\",\"2/3\",\"3/4\",\"4/5\"]</code>');"
        }
      ],
      "id": "59c3ec9f15068017c96eb8a3",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function farey (n) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Fibonacci n-step number sequences",
      "description": [
        "<p>Write a function to generate Fibonacci n-step number sequences and Lucas sequences. The first parameter will be n. The second parameter will be the number of elements to be returned. The third parameter will specify whether to output the Fibonacci sequence or the Lucas sequence. If the parameter is \"f\" then return the Fibonacci sequence and if it is \"l\", then return the Lucas sequence. The sequences must be returned as an array. More details are given below : </p><p>These number series are an expansion of the ordinary <a href=\"http://rosettacode.org/wiki/Fibonacci sequence\" title=\"Fibonacci sequence\">Fibonacci sequence</a> where:</p>",
        "For $n = 2$ we have the Fibonacci sequence; with initial values $[1, 1]$ and $F_k^2 = F_{k-1}^2 + F_{k-2}^2$",
        "For $n = 3$ we have the tribonacci sequence; with initial values $[1, 1, 2]$ and $F_k^3 = F_{k-1}^3 + F_{k-2}^3 + F_{k-3}^3$",
        "For $n = 4$ we have the tetranacci sequence; with initial values $[1, 1, 2, 4]$ and $F_k^4 = F_{k-1}^4 + F_{k-2}^4 + F_{k-3}^4 + F_{k-4}^4$...",
        "For general $n>2$ we have the Fibonacci $n$-step sequence - $F_k^n$; with initial values of the first $n$ values of the $(n-1)$'th Fibonacci $n$-step sequence $F_k^{n-1}$; and $k$'th value of this $n$'th sequence being $F_k^n = \\sum_{i=1}^{(n)} {F_{k-i}^{(n)}}$",
        "<p>For small values of $n$, <a href=\"https://en.wikipedia.org/wiki/Number prefix#Greek_series\" title=\"wp: Number prefix#Greek_series\">Greek numeric prefixes</a> are sometimes used to individually name each series.</p><p>{| style=\"text-align: left;\" border=\"4\" cellpadding=\"2\" cellspacing=\"2\"</p>",
        "<p>|+ Fibonacci $n$-step sequences</p>",
        "<p>|- style=\"background-color: rgb(255, 204, 255);\"</p>",
        "<p>! $n$ !! Series name !! Values</p>",
        "<p>|-</p>",
        "<p>|  2 ||  fibonacci || 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...</p>",
        "<p>|-</p>",
        "<p>|  3 || tribonacci || 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...</p>",
        "<p>|-</p>",
        "<p>|  4 || tetranacci || 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...</p>",
        "<p>|-</p>",
        "<p>|  5 || pentanacci || 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...</p>",
        "<p>|-</p>",
        "<p>|  6 ||  hexanacci || 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...</p>",
        "<p>|-</p>",
        "<p>|  7 || heptanacci || 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...</p>",
        "<p>|-</p>",
        "<p>|  8 ||  octonacci || 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...</p>",
        "<p>|-</p>",
        "<p>|  9 ||  nonanacci || 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...</p>",
        "<p>|-</p>",
        "<p>| 10 ||  decanacci || 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...</p>",
        "<p>|}</p><p>Allied sequences can be generated where the initial values are changed:</p>",
        "<p> The <a href=\"https://en.wikipedia.org/wiki/Lucas number\" title=\"wp: Lucas number\">Lucas series</a> sums the two preceding values like the fibonacci series for $n=2$ but uses $[2, 1]$ as its initial values.</p><p><!-- Lucas numbers, Lucas number, Lucas series     [added to make searches easier.] --></p>"
      ],
      "solutions": [
        "function fib_luc(n, len, w) {\n\tfunction nacci(a, n, len) {\n\t\twhile (a.length < len) {\n\t\t    let sum = 0;\n\t\t    for (let i = Math.max(0, a.length - n); i < a.length; i++)\n\t\t        sum += a[i];\n\t\t    a.push(sum);\n\t\t}\n\t\treturn a;\n\t}\n\tif(w==\"f\"){\n    \treturn nacci(nacci([1,1], n, n), n, len);\n\t}else{\n    \treturn nacci(nacci([2,1], n, n), n, len);\n\t}\n}\n"
      ],
      "tests": [
        {
          "text": "<code>fib_luc</code> is a function.",
          "testString":
            "assert(typeof fib_luc === 'function', '<code>fib_luc</code> is a function.');"
        },
        {
          "text":
            "<code>fib_luc(2,10,\"f\")</code> should return <code>[1,1,2,3,5,8,13,21,34,55]</code>.",
          "testString":
            "assert.deepEqual(fib_luc(2,10,\"f\"),ans[0],'<code>fib_luc(2,10,\"f\")</code> should return <code>[1,1,2,3,5,8,13,21,34,55]</code>.');"
        },
        {
          "text":
            "<code>fib_luc(3,15,\"f\")</code> should return <code>[1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136]</code>.",
          "testString":
            "assert.deepEqual(fib_luc(3,15,\"f\"),ans[1],'<code>fib_luc(3,15,\"f\")</code> should return <code>[1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136]</code>.');"
        },
        {
          "text":
            "<code>fib_luc(4,15,\"f\")</code> should return <code>[1,1,2,4,8,15,29,56,108,208,401,773,1490,2872,5536]</code>.",
          "testString":
            "assert.deepEqual(fib_luc(4,15,\"f\"),ans[2],'<code>fib_luc(4,15,\"f\")</code> should return <code>[1,1,2,4,8,15,29,56,108,208,401,773,1490,2872,5536]</code>.');"
        },
        {
          "text":
            "<code>fib_luc(2,10,\"l\")</code> should return <code>[ 2, 1, 3, 4, 7, 11, 18, 29, 47, 76]</code>.",
          "testString":
            "assert.deepEqual(fib_luc(2,10,\"l\"),ans[3],'<code>fib_luc(2,10,\"l\")</code> should return <code>[ 2, 1, 3, 4, 7, 11, 18, 29, 47, 76]</code>.');"
        },
        {
          "text":
            "<code>fib_luc(3,15,\"l\")</code> should return <code>[ 2, 1, 3, 6, 10, 19, 35, 64, 118, 217, 399, 734, 1350, 2483, 4567 ]</code>.",
          "testString":
            "assert.deepEqual(fib_luc(3,15,\"l\"),ans[4],'<code>fib_luc(3,15,\"l\")</code> should return <code>[ 2, 1, 3, 6, 10, 19, 35, 64, 118, 217, 399, 734, 1350, 2483, 4567 ]</code>.');"
        },
        {
          "text":
            "<code>fib_luc(4,15,\"l\")</code> should return <code>[ 2, 1, 3, 6, 12, 22, 43, 83, 160, 308, 594, 1145, 2207, 4254, 8200 ]</code>.",
          "testString":
            "assert.deepEqual(fib_luc(4,15,\"l\"),ans[5],'<code>fib_luc(4,15,\"l\")</code> should return <code>[ 2, 1, 3, 6, 12, 22, 43, 83, 160, 308, 594, 1145, 2207, 4254, 8200 ]</code>.');"
        },
        {
          "text":
            "<code>fib_luc(5,15,\"l\")</code> should return <code>[ 2, 1, 3, 6, 12, 24, 46, 91, 179, 352, 692, 1360, 2674, 5257, 10335 ]</code>.",
          "testString":
            "assert.deepEqual(fib_luc(5,15,\"l\"),ans[6],'<code>fib_luc(5,15,\"l\")</code> should return <code>[ 2, 1, 3, 6, 12, 24, 46, 91, 179, 352, 692, 1360, 2674, 5257, 10335 ]</code>.');"
        }
      ],
      "id": "598eef80ba501f1268170e1e",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function fib_luc (n, len, w) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "const ans = [[1,1,2,3,5,8,13,21,34,55],",
            "[1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136],",
            "[1,1,2,4,8,15,29,56,108,208,401,773,1490,2872,5536],",
            "[ 2, 1, 3, 4, 7, 11, 18, 29, 47, 76],",
            "[ 2, 1, 3, 6, 10, 19, 35, 64, 118, 217, 399, 734, 1350, 2483, 4567 ],",
            "[ 2, 1, 3, 6, 12, 22, 43, 83, 160, 308, 594, 1145, 2207, 4254, 8200 ],",
            "[ 2, 1, 3, 6, 12, 24, 46, 91, 179, 352, 692, 1360, 2674, 5257, 10335 ]];"
          ]
        }
      }
    },
    {
      "title": "Fibonacci sequence",
      "description": [
        "<p>Write a function to generate the  <big> n<sup>th</sup> </big>  Fibonacci number.</p>",
        "///<p>The <big> n<sup>th</sup> </big>  Fibonacci number is given by :",
        "///<p>F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub></p>",
        "///<p>The first two terms of the series are 0, 1.</p>",
        "///<p>Hence, the series is : 0, 1, 1, 2, 3, 5, 8, 13...</p>",
        "///"
      ],
      "solutions": [
        "function fibonacci(n) {\n  let a = 0, b = 1, t;\n  while (--n > 0) {\n    t = a;\n    a = b;\n    b += t;\n  }\n  return a;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>fibonacci</code> is a function.",
          "testString":
            "assert(typeof fibonacci === 'function', '<code>fibonacci</code> is a function.');"
        },
        {
          "text": "<code>fibonacci(2)</code> should return a number.",
          "testString":
            "assert(typeof fibonacci(2) == 'number', '<code>fibonacci(2)</code> should return a number.');"
        },
        {
          "text": "<code>fibonacci(3)</code> should return 1.\")",
          "testString":
            "assert.equal(fibonacci(3),1,\"<code>fibonacci(3)</code> should return 1.\");"
        },
        {
          "text": "<code>fibonacci(5)</code> should return 3.\")",
          "testString":
            "assert.equal(fibonacci(5),3,\"<code>fibonacci(5)</code> should return 3.\");"
        },
        {
          "text": "<code>fibonacci(10)</code> should return 34.\")",
          "testString":
            "assert.equal(fibonacci(10),34,\"<code>fibonacci(10)</code> should return 34.\");"
        }
      ],
      "id": "597f24c1dda4e70f53c79c81",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function fibonacci(n) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Fibonacci word",
      "description": [
        "<p>Write a function to return the Fibonacci Words upto N. N will be provided as a parameter to the function. The function should return an array of objects. The objects should be of the form : { N: 1, Length: 1, Entropy: 0, Word: '1' }. More details are given below : </p><p>The  Fibonacci Word  may be created in a manner analogous to the  Fibonacci Sequence   <a href=\"http://hal.archives-ouvertes.fr/docs/00/36/79/72/PDF/The_Fibonacci_word_fractal.pdf\" title=\"link: http://hal.archives-ouvertes.fr/docs/00/36/79/72/PDF/The_Fibonacci_word_fractal.pdf\">as described here</a>:</p><p>Define  F_Word<sub>1</sub>  as  1</p>",
        "<p>Define  F_Word<sub>2</sub>  as  0</p>",
        "<p>Form   F_Word<sub>3</sub>  as  F_Word<sub>2</sub>   concatenated with  F_Word<sub>1</sub>   i.e.:  01</p>",
        "<p>Form   F_Word<sub>n</sub>  as  F_Word<sub>n-1</sub>  concatenated with  F_word<sub>n-2</sub></p>"
      ],
      "solutions": [
        "function fibWord(n) {\n    function entropy(s) {\n         //create an object containing each individual char\n      //and the amount of iterations per char \n        function prob(s) {\n            var h = Object.create(null);\n            s.split('').forEach(function(c) {\n               h[c] && h[c]++ || (h[c] = 1); \n            });\n            return h;\n        }\n\n        s = s.toString(); //just in case \n        var e = 0, l = s.length, h = prob(s);\n\n        for (var i in h ) {\n            var p = h[i]/l;\n            e -= p * Math.log(p) / Math.log(2);\n        }\n        return e;\n    }\n    var wOne = \"1\", wTwo = \"0\", wNth = [wOne, wTwo], w = \"\", o = [];\n \n    for (var i = 0; i < n; i++) {\n        if (i === 0 || i === 1) {\n            w = wNth[i];\n        } else {\n            w = wNth[i - 1] + wNth[i - 2];\n            wNth.push(w);\n        }\n        var l = w.length;\n        var e = entropy(w);\n \n        if (l <= 21) {\n        \to.push({\n            \tN: i + 1,\n            \tLength: l,\n            \tEntropy: e,\n            \tWord: w\n        \t});\n        } else {\n        \to.push({\n            \tN: i + 1,\n            \tLength: l,\n            \tEntropy: e,\n            \tWord: \"...\"\n        \t});\n        }            \n    }\n  return o;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>fibWord</code> is a function.",
          "testString":
            "assert(typeof fibWord === 'function', '<code>fibWord</code> is a function.');"
        },
        {
          "text": "<code>fibWord(5)</code> should return an array.",
          "testString":
            "assert(Array.isArray(fibWord(5)),'<code>fibWord(5)</code> should return an array.');"
        },
        {
          "text":
            "<code>fibWord(5)</code> should return <code>'+JSON.stringify(ans)+'</code>.",
          "testString":
            "assert.deepEqual(fibWord(5),ans,'<code>fibWord(5)</code> should return <code>'+JSON.stringify(ans)+'</code>.');"
        }
      ],
      "id": "5992e222d397f00d21122931",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function fibWord (n) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "let ans=[ { N: 1, Length: 1, Entropy: 0, Word: '1' },",
            "",
            "  { N: 2, Length: 1, Entropy: 0, Word: '0' },",
            "",
            "  { N: 3, Length: 2, Entropy: 1, Word: '01' },",
            "",
            "  { N: 4, Length: 3, Entropy: 0.9182958340544896, Word: '010' },",
            "",
            "  { N: 5, Length: 5, Entropy: 0.9709505944546688, Word: '01001' }];"
          ]
        }
      }
    },
    {
      "title": "Fractran",
      "description": [
        "<div class=\"rosetta\"><p class=\"rosetta__paragraph\"><span class=\"rosetta__text--bold\"><a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/FRACTRAN\" title=\"wp: FRACTRAN\">FRACTRAN</a></span> is a Turing-complete esoteric programming language invented by the mathematician <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/John Horton Conway\" title=\"wp: John Horton Conway\">John Horton Conway</a>.</p><br/><p class=\"rosetta__paragraph\">A FRACTRAN program is an ordered list of positive fractions $P = (f_1, f_2, \\ldots, f_m)$, together with an initial positive integer input $n$.</p>",
        "<br/><p class=\"rosetta__paragraph\">The program is run by updating the integer $n$ as follows:</p><br/><ul class=\"rosetta__unordered-list\"><li class=\"rosetta__list-item--unordered\">for the first fraction, $f_i$, in the list for which $nf_i$ is an integer, replace $n$ with $nf_i$ ;</li>",
        "<li class=\"rosetta__list-item--unordered\">repeat this rule until no fraction in the list produces an integer when multiplied by $n$, then halt.</li></ul>",
        "<br>",
        "<p class=\"rosetta__paragraph\">Conway gave a program for primes in FRACTRAN:</p><br/><p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"> $17/91$, $78/85$, $19/51$, $23/38$, $29/33$, $77/29$, $95/23$, $77/19$, $1/17$, $11/13$, $13/11$, $15/14$, $15/2$, $55/1$</span></p><br/><p class=\"rosetta__paragraph\">Starting with $n=2$, this FRACTRAN program will change $n$ to $15=2\\times (15/2)$, then $825=15\\times (55/1)$, generating the following sequence of integers:</p><br/><p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"> $2$, $15$, $825$, $725$, $1925$, $2275$, $425$, $390$, $330$, $290$, $770$, $\\ldots$</span></p><br/><p class=\"rosetta__paragraph\">After 2, this sequence contains the following powers of 2:</p><br/><p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">$2^2=4$, $2^3=8$, $2^5=32$, $2^7=128$, $2^{11}=2048$, $2^{13}=8192$, $2^{17}=131072$, $2^{19}=524288$, $\\ldots$</span></p><br/><p class=\"rosetta__paragraph\">which are the prime powers of 2.</p>",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Write a function that takes a fractran program as a string parameter and returns the first 10 numbers of the program as an array. If the result does not have 10 numbers then return the numbers as is.</p></div>"
      ],
      "solutions": [
        "function fractran(progStr){\n  var num = new Array();\n  var den = new Array();\n  var val ;\n  var out=\"\";\n  function compile(prog){\n    var regex = /\\s*(\\d*)\\s*\\/\\s*(\\d*)\\s*(.*)/m;\n    while(regex.test(prog)){\n      num.push(regex.exec(prog)[1]);\n      den.push(regex.exec(prog)[2]);\n      prog = regex.exec(prog)[3];\n    }\n  }\n\n  function step(val){\n    var i=0;\n    while(i<den.length && val%den[i] != 0) i++;\n    return num[i]*val/den[i];\n  }\n\n  var seq=[]\n\n  function exec(val){\n    var i = 0;\n    while(val && i<limit){\n      seq.push(val)\n      val = step(val);\n      i ++;\n    }\n  }\n\n  // Main\n  compile(progStr);\n  var limit = 10;\n  exec(2);\n  return seq;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>fractran</code> should be a function.",
          "testString":
            "assert(typeof fractran=='function','<code>fractran</code> should be a function.');"
        },
        {
          "text":
            "<code>fractran(\"'+tests[0]+'\")</code> should return an array.",
          "testString":
            "assert(Array.isArray(fractran(tests[0])),'<code>fractran(\"'+tests[0]+'\")</code> should return an array.');"
        },
        {
          "text":
            "<code>fractran(\"'+tests[0]+'\")</code> should return <code>'+JSON.stringify(results[0])+'</code>.",
          "testString":
            "assert.deepEqual(fractran(tests[0]),results[0],'<code>fractran(\"'+tests[0]+'\")</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "<code>fractran(\"'+tests[1]+'\")</code> should return <code>'+JSON.stringify(results[1])+'</code>.",
          "testString":
            "assert.deepEqual(fractran(tests[1]),results[1],'<code>fractran(\"'+tests[1]+'\")</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "<code>fractran(\"'+tests[2]+'\")</code> should return <code>'+JSON.stringify(results[2])+'</code>.",
          "testString":
            "assert.deepEqual(fractran(tests[2]),results[2],'<code>fractran(\"'+tests[2]+'\")</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "<code>fractran(\"'+tests[3]+'\")</code> should return <code>'+JSON.stringify(results[3])+'</code>.",
          "testString":
            "assert.deepEqual(fractran(tests[3]),results[3],'<code>fractran(\"'+tests[3]+'\")</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "<code>fractran(\"'+tests[4]+'\")</code> should return <code>'+JSON.stringify(results[4])+'</code>.",
          "testString":
            "assert.deepEqual(fractran(tests[4]),results[4],'<code>fractran(\"'+tests[4]+'\")</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a7dad05be01840e1778a0d1",
      "challengeType": 3,
      "releasedOn": "May 31, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function fractran (progStr) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "let tests=[",
            "  '3/2,1/3',",
            "  '3/2,5/3,1/5',",
            "  '3/2,6/3',",
            "  '2/7,7/2',",
            "  '17/91 78/85 19/51 23/38 29/33 77/29 95/23 77/19 1/17 11/13 13/11 15/14 15/2 55/1'",
            "]",
            "let results=[",
            "  [ 2, 3, 1 ],",
            "  [ 2, 3, 5, 1 ],",
            "  [ 2, 3, 6, 9, 18, 27, 54, 81, 162, 243 ],",
            "  [ 2, 7, 2, 7, 2, 7, 2, 7, 2, 7 ],",
            "  [ 2, 15, 825, 725, 1925, 2275, 425, 390, 330, 290 ]",
            "]"
          ]
        }
      }
    },
    {
      "title": "Gamma function",
      "description": [
        "Implement one algorithm (or more) to compute the <a href=\"https://en.wikipedia.org/wiki/Gamma function\">Gamma</a> ($\\Gamma$) function (in the real field only).",
        "The Gamma function can be defined as:",
        "<div style='padding-left: 4em;'><big><big>$\\Gamma(x) = \\displaystyle\\int_0^\\infty t^{x-1}e^{-t} dt$</big></big></div>"
      ],
      "solutions": [
        "function gamma(x) {\n  var p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028,\n  771.32342877765313, -176.61502916214059, 12.507343278686905,\n  -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7\n  ];\n   \n  var g = 7;\n  if (x < 0.5) {\n    return Math.PI / (Math.sin(Math.PI * x) * gamma(1 - x));\n  }\n\n  x -= 1;\n  var a = p[0];\n  var t = x + g + 0.5;\n  for (var i = 1; i < p.length; i++) {\n  a += p[i] / (x + i);\n  }\n   \n  var result=Math.sqrt(2 * Math.PI) * Math.pow(t, x + 0.5) * Math.exp(-t) * a;\n\n  return result;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>gamma</code> should be a function.",
          "testString":
            "assert(typeof gamma=='function','<code>gamma</code> should be a function.')"
        },
        {
          "text": "<code>gamma('+tests[0]+')</code> should return a number.",
          "testString":
            "assert(typeof gamma(tests[0])=='number','<code>gamma('+tests[0]+')</code> should return a number.')"
        },
        {
          "text":
            "<code>gamma('+tests[0]+')</code> should return <code>'+results[0]+'</code>.",
          "testString":
            "assert.equal(gamma(tests[0]),results[0],'<code>gamma('+tests[0]+')</code> should return <code>'+results[0]+'</code>.')"
        },
        {
          "text":
            "<code>gamma('+tests[1]+')</code> should return <code>'+results[1]+'</code>.",
          "testString":
            "assert.equal(gamma(tests[1]),results[1],'<code>gamma('+tests[1]+')</code> should return <code>'+results[1]+'</code>.')"
        },
        {
          "text":
            "<code>gamma('+tests[2]+')</code> should return <code>'+results[2]+'</code>.",
          "testString":
            "assert.equal(gamma(tests[2]),results[2],'<code>gamma('+tests[2]+')</code> should return <code>'+results[2]+'</code>.')"
        },
        {
          "text":
            "<code>gamma('+tests[3]+')</code> should return <code>'+results[3]+'</code>.",
          "testString":
            "assert.equal(gamma(tests[3]),results[3],'<code>gamma('+tests[3]+')</code> should return <code>'+results[3]+'</code>.')"
        },
        {
          "text":
            "<code>gamma('+tests[4]+')</code> should return <code>'+results[4]+'</code>.",
          "testString":
            "assert.equal(gamma(tests[4]),results[4],'<code>gamma('+tests[4]+')</code> should return <code>'+results[4]+'</code>.')"
        }
      ],
      "id": "5a23c84252665b21eecc7e76",
      "challengeType": 5,
      "releasedOn": "June 1, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function gamma (x) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "let tests=[.1,.2,.3,.4,.5];",
            "let results=[",
            "  9.513507698668736,",
            "  4.590843711998803,",
            "  2.9915689876875904,",
            "  2.218159543757687,",
            "  1.7724538509055159",
            "];"
          ]
        }
      }
    },
    {
      "title": "Gaussian elimination",
      "description": [
        "Write a function to solve \\(A.x = b\\) using Gaussian elimination then backwards substitution. \\(A\\) being an \\(n \\times n\\) matrix. Also, \\(x\\) and \\(b\\) are \\(n\\) by 1 vectors. To improve accuracy, please use partial pivoting and scaling."
      ],
      "solutions": [
        "function gaussianElimination(A, b) {\n  // Lower Upper Decomposition\n  function ludcmp(A) {\n  \t// A is a matrix that we want to decompose into Lower and Upper matrices.\n  \tvar d = true\n  \tvar n = A.length\n  \tvar idx = new Array(n) // Output vector with row permutations from partial pivoting\n  \tvar vv = new Array(n) // Scaling information\n   \n  \tfor (var i=0; i<n; i++) {\n  \t\tvar max = 0\n  \t\tfor (var j=0; j<n; j++) {\n  \t\t\tvar temp = Math.abs(A[i][j])\n  \t\t\tif (temp > max) max = temp\n  \t\t}\n  \t\tif (max == 0) return // Singular Matrix!\n  \t\tvv[i] = 1 / max // Scaling\n  \t}\n   \n\t\tvar Acpy = new Array(n)\n\t\tfor (var i=0; i<n; i++) {\n\t\t\tvar Ai = A[i]\n\t\t\tlet Acpyi = new Array(Ai.length)\n\t\t\tfor (j=0; j<Ai.length; j+=1) Acpyi[j] = Ai[j]\n\t\t\tAcpy[i] = Acpyi\n\t\t}\n\t\tA = Acpy\n   \n  \tvar tiny = 1e-20 // in case pivot element is zero\n  \tfor (var i=0; ; i++) {\n  \t\tfor (var j=0; j<i; j++) {\n  \t\t\tvar sum = A[j][i]\n  \t\t\tfor (var k=0; k<j; k++) sum -= A[j][k] * A[k][i];\n  \t\t\tA[j][i] = sum\n  \t\t}\n  \t\tvar jmax = 0\n  \t\tvar max = 0;\n  \t\tfor (var j=i; j<n; j++) {\n  \t\t\tvar sum = A[j][i]\n  \t\t\tfor (var k=0; k<i; k++) sum -= A[j][k] * A[k][i];\n  \t\t\tA[j][i] = sum\n  \t\t\tvar temp = vv[j] * Math.abs(sum)\n  \t\t\tif (temp >= max) {\n  \t\t\t\tmax = temp\n  \t\t\t\tjmax = j\n  \t\t\t}\n  \t\t}\n  \t\tif (i <= jmax) {\n  \t\t\tfor (var j=0; j<n; j++) {\n  \t\t\t\tvar temp = A[jmax][j]\n  \t\t\t\tA[jmax][j] = A[i][j]\n  \t\t\t\tA[i][j] = temp\n  \t\t\t}\n  \t\t\td = !d;\n  \t\t\tvv[jmax] = vv[i]\n  \t\t}\n  \t\tidx[i] = jmax;\n  \t\tif (i == n-1) break;\n  \t\tvar temp = A[i][i]\n  \t\tif (temp == 0) A[i][i] = temp = tiny\n  \t\ttemp = 1 / temp\n  \t\tfor (var j=i+1; j<n; j++) A[j][i] *= temp\n  \t}\n  \treturn {A:A, idx:idx, d:d}\n  }\n   \n  // Lower Upper Back Substitution\n  function lubksb(lu, b) {\n  \t// solves the set of n linear equations A*x = b.\n  \t// lu is the object containing A, idx and d as determined by the routine ludcmp.\n  \tvar A = lu.A\n  \tvar idx = lu.idx\n  \tvar n = idx.length\n\n\t\tvar bcpy = new Array(n)\n\t\tfor (var i=0; i<b.length; i+=1) bcpy[i] = b[i]\n\t\tb = bcpy\n   \n  \tfor (var ii=-1, i=0; i<n; i++) {\n  \t\tvar ix = idx[i]\n  \t\tvar sum = b[ix]\n  \t\tb[ix] = b[i]\n  \t\tif (ii > -1)\n  \t\t\tfor (var j=ii; j<i; j++) sum -= A[i][j] * b[j]\n  \t\telse if (sum)\n  \t\t\tii = i\n  \t\tb[i] = sum\n  \t}\n  \tfor (var i=n-1; i>=0; i--) {\n  \t\tvar sum = b[i]\n  \t\tfor (var j=i+1; j<n; j++) sum -= A[i][j] * b[j]\n  \t\tb[i] = sum / A[i][i]\n  \t}\n  \treturn b // solution vector x\n  }\n\n\tvar lu = ludcmp(A)\n\tif (lu === undefined) return // Singular Matrix!\n\treturn lubksb(lu, b)\n}\n\n\n"
      ],
      "tests": [
        {
          "text": "'<code>gaussianElimination</code> should be a function.'",
          "testString":
            "assert(typeof gaussianElimination=='function','<code>gaussianElimination</code> should be a function.');"
        },
        {
          "text":
            "'<code>gaussianElimination('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return an array.'",
          "testString":
            "assert(Array.isArray(gaussianElimination(tests[0][0],tests[0][1])),'<code>gaussianElimination('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return an array.');"
        },
        {
          "text":
            "'<code>gaussianElimination('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(gaussianElimination(tests[0][0],tests[0][1]),results[0],'<code>gaussianElimination('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>gaussianElimination('+JSON.stringify(tests[1][0])+','+JSON.stringify(tests[1][1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(gaussianElimination(tests[1][0],tests[1][1]),results[1],'<code>gaussianElimination('+JSON.stringify(tests[1][0])+','+JSON.stringify(tests[1][1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>gaussianElimination('+JSON.stringify(tests[2][0])+','+JSON.stringify(tests[2][1])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(gaussianElimination(tests[2][0],tests[2][1]),results[2],'<code>gaussianElimination('+JSON.stringify(tests[2][0])+','+JSON.stringify(tests[2][1])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>gaussianElimination('+JSON.stringify(tests[3][0])+','+JSON.stringify(tests[3][1])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(gaussianElimination(tests[3][0],tests[3][1]),results[3],'<code>gaussianElimination('+JSON.stringify(tests[3][0])+','+JSON.stringify(tests[3][1])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>gaussianElimination('+JSON.stringify(tests[4][0])+','+JSON.stringify(tests[4][1])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(gaussianElimination(tests[4][0],tests[4][1]),results[4],'<code>gaussianElimination('+JSON.stringify(tests[4][0])+','+JSON.stringify(tests[4][1])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7e77",
      "challengeType": 5,
      "releasedOn": "June 2, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function gaussianElimination (A,b) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "let tests=[",
            "  [ [[1,1],[1,-1]] , [5,1] ],",
            "  [ [[2,3],[2,1]] , [8,4] ],",
            "  [ [[1,3],[5,-2]] , [14,19] ],",
            "  [ [[1,1],[5,-1]] , [10,14] ],",
            "  [ [[1,2,3],[4,5,6],[7,8,8]] , [6,15,23] ]",
            "];",
            "let results=[",
            "  [ 3, 2 ],",
            "  [ 1, 2 ],",
            "  [ 5, 3 ],",
            "  [ 4, 6 ],",
            "  [ 1, 1, 1 ]",
            "]"
          ]
        }
      }
    },
    {
      "title": "General FizzBuzz",
      "description": [
        "Write a generalized version of <a href=\"http://rosettacode.org/wiki/FizzBuzz\">FizzBuzz</a> that works for any list of factors, along with their words.",
        "This is basically a \"fizzbuzz\" implementation where the rules of the game are supplied to the user. Create a function to implement this. The function should take two parameters.",
        "The first will be an array with the FizzBuzz rules. For example: <code>[ [3,\"Fizz\"] , [5,\"Buzz\"] ]</code>.",
        "This indcates that <code>Fizz</code> should be printed if the number is a multiple of 3 and <code>Buzz</code> if it is a multiple of 5. If it is a multiple of both then the strings should be concatenated in the order specified in the array. In this case, <code>FizzBuzz</code> if the number is a multiple of 3 and 5.",
        "The second parameter is the number for which the function should return a string as stated above."
      ],
      "solutions": [
        "function genFizzBuzz(rules, num) {\n  let res='';\n  rules.forEach(function (e) {\n    if(num % e[0] == 0)\n      res+=e[1];\n  })\n\n  if(res==''){\n    res=num.toString();\n  }\n\n  return res;\n}\n\n\n\n"
      ],
      "tests": [
        {
          "text": "'<code>genFizzBuzz</code> should be a function.'",
          "testString":
            "assert(typeof genFizzBuzz=='function','<code>genFizzBuzz</code> should be a function.');"
        },
        {
          "text":
            "'<code>genFizzBuzz('+JSON.stringify(tests[0][0])+','+tests[0][1]+')</code> should return a type.'",
          "testString":
            "assert(typeof genFizzBuzz(tests[0][0],tests[0][1])=='string','<code>genFizzBuzz('+JSON.stringify(tests[0][0])+','+tests[0][1]+')</code> should return a type.');"
        },
        {
          "text":
            "'<code>genFizzBuzz('+JSON.stringify(tests[0][0])+','+tests[0][1]+')</code> should return <code>\"'+results[0]+'\"</code>.'",
          "testString":
            "assert.equal(genFizzBuzz(tests[0][0],tests[0][1]),results[0],'<code>genFizzBuzz('+JSON.stringify(tests[0][0])+','+tests[0][1]+')</code> should return <code>\"'+results[0]+'\"</code>.');"
        },
        {
          "text":
            "'<code>genFizzBuzz('+JSON.stringify(tests[1][0])+','+tests[1][1]+')</code> should return <code>\"'+results[1]+'\"</code>.'",
          "testString":
            "assert.equal(genFizzBuzz(tests[1][0],tests[1][1]),results[1],'<code>genFizzBuzz('+JSON.stringify(tests[1][0])+','+tests[1][1]+')</code> should return <code>\"'+results[1]+'\"</code>.');"
        },
        {
          "text":
            "'<code>genFizzBuzz('+JSON.stringify(tests[2][0])+','+tests[2][1]+')</code> should return <code>\"'+results[2]+'\"</code>.'",
          "testString":
            "assert.equal(genFizzBuzz(tests[2][0],tests[2][1]),results[2],'<code>genFizzBuzz('+JSON.stringify(tests[2][0])+','+tests[2][1]+')</code> should return <code>\"'+results[2]+'\"</code>.');"
        },
        {
          "text":
            "'<code>genFizzBuzz('+JSON.stringify(tests[3][0])+','+tests[3][1]+')</code> should return <code>\"'+results[3]+'\"</code>.'",
          "testString":
            "assert.equal(genFizzBuzz(tests[3][0],tests[3][1]),results[3],'<code>genFizzBuzz('+JSON.stringify(tests[3][0])+','+tests[3][1]+')</code> should return <code>\"'+results[3]+'\"</code>.');"
        },
        {
          "text":
            "'<code>genFizzBuzz('+JSON.stringify(tests[4][0])+','+tests[4][1]+')</code> should return <code>\"'+results[4]+'\"</code>.'",
          "testString":
            "assert.equal(genFizzBuzz(tests[4][0],tests[4][1]),results[4],'<code>genFizzBuzz('+JSON.stringify(tests[4][0])+','+tests[4][1]+')</code> should return <code>\"'+results[4]+'\"</code>.');"
        },
        {
          "text":
            "'<code>genFizzBuzz('+JSON.stringify(tests[5][0])+','+tests[5][1]+')</code> should return <code>\"'+results[5]+'\"</code>.'",
          "testString":
            "assert.equal(genFizzBuzz(tests[5][0],tests[5][1]),results[5],'<code>genFizzBuzz('+JSON.stringify(tests[5][0])+','+tests[5][1]+')</code> should return <code>\"'+results[5]+'\"</code>.');"
        },
        {
          "text":
            "'<code>genFizzBuzz('+JSON.stringify(tests[6][0])+','+tests[6][1]+')</code> should return <code>\"'+results[6]+'\"</code>.'",
          "testString":
            "assert.equal(genFizzBuzz(tests[6][0],tests[6][1]),results[6],'<code>genFizzBuzz('+JSON.stringify(tests[6][0])+','+tests[6][1]+')</code> should return <code>\"'+results[6]+'\"</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7e78",
      "challengeType": 5,
      "releasedOn": "June 2, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function genFizzBuzz (rules, num) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "let tests=[",
            "  [ [[3, 'Fizz'],[5, 'Buzz']], 6 ],",
            "  [ [[3, 'Fizz'],[5, 'Buzz']], 10 ],",
            "  [ [[3, 'Buzz'],[5, 'Fizz']], 12 ],",
            "  [ [[3, 'Buzz'],[5, 'Fizz']], 13 ],",
            "  [ [[3, 'Buzz'],[5, 'Fizz']], 15 ],",
            "  [ [[3, 'Fizz'],[5, 'Buzz']], 15 ],",
            "  [ [[3, 'Fizz'],[5, 'Buzz'],[7, 'Baxx']], 105 ],",
            "]",
            "let results=[",
            "  \"Fizz\",",
            "  \"Buzz\",",
            "  \"Buzz\",",
            "  \"13\",",
            "  \"BuzzFizz\",",
            "  \"FizzBuzz\",",
            "  \"FizzBuzzBaxx\"",
            "]"
          ]
        }
      }
    },
    {
      "title": "Generate lower case ASCII alphabet",
      "description": [
        "Write a function to generate an array of lower case ASCII characters, for a given range. For example: for range 1 to 4 the function should return <code>['a','b','c','d']</code>."
      ],
      "solutions": [
        "function lascii(cFrom, cTo) {\n\n  function cRange(cFrom, cTo) {\n    var iStart = cFrom.charCodeAt(0);\n\n    return Array.apply(\n      null, Array(cTo.charCodeAt(0) - iStart + 1)\n    ).map(function (_, i) {\n\n      return String.fromCharCode(iStart + i);\n\n    });\n  }\n\n  return cRange(cFrom, cTo);\n\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>lascii</code> should be a function.'",
          "testString":
            "assert(typeof lascii=='function','<code>lascii</code> should be a function.');"
        },
        {
          "text": "'<code>lascii(\"a\",\"d\")</code> should return an array.'",
          "testString":
            "assert(Array.isArray(lascii('a','d')),'<code>lascii(\"a\",\"d\")</code> should return an array.');"
        },
        {
          "text":
            "\"<code>lascii('a','d')</code> should return <code>[ 'a', 'b', 'c', 'd' ]</code>.\"",
          "testString":
            "assert.deepEqual(lascii(\"a\",\"d\"),results[0],\"<code>lascii('a','d')</code> should return <code>[ 'a', 'b', 'c', 'd' ]</code>.\");"
        },
        {
          "text":
            "\"<code>lascii('c','i')</code> should return <code>[ 'c', 'd', 'e', 'f', 'g', 'h', 'i' ]</code>.\"",
          "testString":
            "assert.deepEqual(lascii(\"c\",\"i\"),results[1],\"<code>lascii('c','i')</code> should return <code>[ 'c', 'd', 'e', 'f', 'g', 'h', 'i' ]</code>.\");"
        },
        {
          "text":
            "\"<code>lascii('m','q')</code> should return <code>[ 'm', 'n', 'o', 'p', 'q' ]</code>.\"",
          "testString":
            "assert.deepEqual(lascii(\"m\",\"q\"),results[2],\"<code>lascii('m','q')</code> should return <code>[ 'm', 'n', 'o', 'p', 'q' ]</code>.\");"
        },
        {
          "text":
            "\"<code>lascii('k','n')</code> should return <code>[ 'k', 'l', 'm', 'n' ]</code>.\")",
          "testString":
            "assert.deepEqual(lascii(\"k\",\"n\"),results[3],\"<code>lascii('k','n')</code> should return <code>[ 'k', 'l', 'm', 'n' ]</code>.\");"
        },
        {
          "text":
            "\"<code>lascii('t','z')</code> should return <code>[ 't', 'u', 'v', 'w', 'x', 'y', 'z' ]</code>.\"",
          "testString":
            "assert.deepEqual(lascii(\"t\",\"z\"),results[4],\"<code>lascii('t','z')</code> should return <code>[ 't', 'u', 'v', 'w', 'x', 'y', 'z' ]</code>.\");"
        }
      ],
      "id": "5a23c84252665b21eecc7e7a",
      "challengeType": 5,
      "releasedOn": "June 2, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function lascii (cFrom, cTo) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "let results=[",
            "  [ 'a', 'b', 'c', 'd' ],",
            "  [ 'c', 'd', 'e', 'f', 'g', 'h', 'i' ],",
            "  [ 'm', 'n', 'o', 'p', 'q' ],",
            "  [ 'k', 'l', 'm', 'n' ],",
            "  [ 't', 'u', 'v', 'w', 'x', 'y', 'z' ]",
            "]"
          ]
        }
      }
    },
    {
      "title": "Generator/Exponential",
      "description": [
        "A generator is an executable entity (like a function or procedure) that contains code that yields a sequence of values, one at a time, so that each time you call the generator, the next value in the sequence is provided.",
        "Generators are often built on top of coroutines or objects so that the internal state of the object is handled “naturally”.",
        "Generators are often used in situations where a sequence is potentially infinite, and where it is possible to construct the next value of the sequence with only minimal state.",
        "Write a function that uses generators to generate squares and cubes. Create a new generator that filters all cubes from the generator of squares.",
        "The function should return the \\( n^{th} \\) value of the filtered generator.",
        "For example for \\(n=7\\), the function should return 81 as the sequence would be 4,9,16,25,36,49,81. Here 64 is filtered out, as it is a cube."
      ],
      "solutions": [
        "function exponentialGenerator(n){\n  function* PowersGenerator(m) {\n  \tvar n=0;\n  \twhile(1) {\n  \t\tyield Math.pow(n, m);\n  \t\tn += 1;\n  \t}\n  }\n\n  function* FilteredGenerator(g, f){\n  \tvar value = g.next().value;\n  \tvar filter = f.next().value;\n  \twhile(1) {\n  \t\tif( value < filter ) {\n  \t\t\tyield value;\n  \t\t\tvalue = g.next().value;\n  \t\t} else if ( value > filter ) {\n  \t\t\tfilter = f.next().value;\n  \t\t} else {\n  \t\t\tvalue = g.next().value;\n  \t\t\tfilter = f.next().value;\n  \t\t}\n  \t}\n  }\n\n  var squares = PowersGenerator(2);\n  var cubes = PowersGenerator(3);\n\n  var filtered = FilteredGenerator(squares, cubes);\n\n  var curr=0;\n  for(var i=0;i<n;i++) curr=filtered.next();\n\n  return curr.value;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>exponentialGenerator</code> should be a function.'",
          "testString":
            "assert(typeof exponentialGenerator=='function','<code>exponentialGenerator</code> should be a function.');"
        },
        {
          "text":
            "'<code>exponentialGenerator()</code> should return a number.'",
          "testString":
            "assert(typeof exponentialGenerator(10)=='number','<code>exponentialGenerator()</code> should return a number.');"
        },
        {
          "text":
            "'<code>exponentialGenerator(10)</code> should return <code>144</code>.'",
          "testString":
            "assert.equal(exponentialGenerator(10),144,'<code>exponentialGenerator(10)</code> should return <code>144</code>.');"
        },
        {
          "text":
            "'<code>exponentialGenerator(12)</code> should return <code>196</code>.'",
          "testString":
            "assert.equal(exponentialGenerator(12),196,'<code>exponentialGenerator(12)</code> should return <code>196</code>.');"
        },
        {
          "text":
            "'<code>exponentialGenerator(14)</code> should return <code>256</code>.'",
          "testString":
            "assert.equal(exponentialGenerator(14),256,'<code>exponentialGenerator(14)</code> should return <code>256</code>.');"
        },
        {
          "text":
            "'<code>exponentialGenerator(20)</code> should return <code>484</code>.'",
          "testString":
            "assert.equal(exponentialGenerator(20),484,'<code>exponentialGenerator(20)</code> should return <code>484</code>.');"
        },
        {
          "text":
            "'<code>exponentialGenerator(25)</code> should return <code>784</code>.'",
          "testString":
            "assert.equal(exponentialGenerator(25),784,'<code>exponentialGenerator(25)</code> should return <code>784</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7e7b",
      "challengeType": 5,
      "releasedOn": "June 7, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function exponentialGenerator (n) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Gray code",
      "description": [
        "<a href=\"https://en.wikipedia.org/wiki/Gray code\">Gray code</a> is a form of binary encoding where transitions between consecutive numbers differ by only one bit.",
        "This is a useful encoding for reducing hardware data hazards with values that change rapidly and/or connect to slower hardware as inputs. ",
        "It is also useful for generating inputs for <a href=\"https://en.wikipedia.org/wiki/Karnaugh map\">Karnaugh maps</a> in order from left to right or top to bottom. ",
        "Create a function to encode a number to and decode a number from Gray code. The function should will have 2 parameters. ",
        "The first would be a boolean. The function should encode for true and decode for false. The second parameter would be the number to be encoded/decoded.",
        "Display the normal binary representations, Gray code representations, and decoded Gray code values for all 5-bit binary numbers (0-31 inclusive, leading 0's not necessary).",
        "There are many possible Gray codes. The following encodes what is called \"binary reflected Gray code.\"<br>Encoding (MSB is bit 0, b is binary, g is Gray code): ",
        "<code><br>if b[i-1] = 1<br><span style=\"padding-left:1em\">g[i] = not b[i]</span><br>else<br><span style=\"padding-left:1em\">g[i] = b[i]</span><br>",
        "</code>  Or: <br><code> g = b xor (b logically right shifted 1 time)</code><br>Decoding (MSB is bit 0, b is binary, g is Gray code): <br>",
        "<code>b[0] = g[0]<br>for other bits:<br>b[i] = g[i] xor b[i-1]<br></code>"
      ],
      "solutions": [
        "function gray(enc, number){\n  if(enc){\n      return number ^ (number >> 1);\n  }else{\n      let n = number;\n\n      while (number >>= 1) {\n          n ^= number;\n      }\n      return n;\n  }\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>gray</code> should be a function.'",
          "testString":
            "assert(typeof gray=='function','<code>gray</code> should be a function.');"
        },
        {
          "text": "'<code>gray(true,177)</code> should return a number.'",
          "testString":
            "assert(typeof gray(true,177)=='number','<code>gray(true,177)</code> should return a number.');"
        },
        {
          "text":
            "'<code>gray(true,177)</code> should return <code>233</code>.'",
          "testString":
            "assert.equal(gray(true,177),233,'<code>gray(true,177)</code> should return <code>233</code>.');"
        },
        {
          "text":
            "'<code>gray(true,425)</code> should return <code>381</code>.'",
          "testString":
            "assert.equal(gray(true,425),381,'<code>gray(true,425)</code> should return <code>381</code>.');"
        },
        {
          "text":
            "'<code>gray(true,870)</code> should return <code>725</code>.'",
          "testString":
            "assert.equal(gray(true,870),725,'<code>gray(true,870)</code> should return <code>725</code>.');"
        },
        {
          "text":
            "'<code>gray(false,233)</code> should return <code>177</code>.'",
          "testString":
            "assert.equal(gray(false,233),177,'<code>gray(false,233)</code> should return <code>177</code>.');"
        },
        {
          "text":
            "'<code>gray(false,381)</code> should return <code>425</code>.'",
          "testString":
            "assert.equal(gray(false,381),425,'<code>gray(false,381)</code> should return <code>425</code>.');"
        },
        {
          "text":
            "'<code>gray(false,725)</code> should return <code>870</code>.'",
          "testString":
            "assert.equal(gray(false,725),870,'<code>gray(false,725)</code> should return <code>870</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7e80",
      "challengeType": 5,
      "releasedOn": "June 7, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function gray(enc, number) {", " // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Greatest common divisor",
      "description": [
        "Write a function that returns the greatest common divisor of two integers."
      ],
      "solutions": [
        "function gcd(a, b) {\n  return b==0 ? Math.abs(a):gcd(b, a % b);\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>gcd</code> should be a function.'",
          "testString":
            "assert(typeof gcd=='function','<code>gcd</code> should be a function.');"
        },
        {
          "text": "'<code>gcd(24,36)</code> should return a number.'",
          "testString":
            "assert(typeof gcd(24,36)=='number','<code>gcd(24,36)</code> should return a number.');"
        },
        {
          "text": "'<code>gcd(24,36)</code> should return <code>12</code>.'",
          "testString":
            "assert.equal(gcd(24,36),12,'<code>gcd(24,36)</code> should return <code>12</code>.');"
        },
        {
          "text": "'<code>gcd(30,48)</code> should return <code>6</code>.'",
          "testString":
            "assert.equal(gcd(30,48),6,'<code>gcd(30,48)</code> should return <code>6</code>.');"
        },
        {
          "text": "'<code>gcd(10,15)</code> should return <code>5</code>.'",
          "testString":
            "assert.equal(gcd(10,15),5,'<code>gcd(10,15)</code> should return <code>5</code>.');"
        },
        {
          "text": "'<code>gcd(100,25)</code> should return <code>25</code>.'",
          "testString":
            "assert.equal(gcd(100,25),25,'<code>gcd(100,25)</code> should return <code>25</code>.');"
        },
        {
          "text": "'<code>gcd(13,250)</code> should return <code>1</code>.'",
          "testString":
            "assert.equal(gcd(13,250),1,'<code>gcd(13,250)</code> should return <code>1</code>.');"
        },
        {
          "text": "'<code>gcd(1300,250)</code> should return <code>50</code>.'",
          "testString":
            "assert.equal(gcd(1300,250),50,'<code>gcd(1300,250)</code> should return <code>50</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7e82",
      "challengeType": 5,
      "releasedOn": "June 7, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function gcd(a, b) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Greatest subsequential sum",
      "description": [
        "Given a sequence of integers, find a continuous subsequence which maximizes the sum of its elements, that is, the elements of no other single subsequence add up to a value larger than this one.",
        "An empty subsequence is considered to have the sum of \\( 0 \\);  thus if all elements are negative, the result must be the empty sequence."
      ],
      "solutions": [
        "function maximumSubsequence(population) {\n  function sumValues(arr) {\n      var result = 0;\n      for (var i = 0, len = arr.length; i < len; i++) {\n          result += arr[i];\n      }\n      return result;\n  }\n  var greatest;\n  var maxValue = 0;\n  var subsequence = [];\n\n  for (var i = 0, len = population.length; i < len; i++) {\n      for (var j = i; j <= len; j++) {\n          var subsequence = population.slice(i, j);\n          var value = sumValues(subsequence);\n          if (value > maxValue) {\n              maxValue = value;\n              greatest = subsequence;\n          };\n      }\n  }\n\n  return greatest;\n}\n\n\n"
      ],
      "tests": [
        {
          "text": "'<code>maximumSubsequence</code> should be a function.'",
          "testString":
            "assert(typeof maximumSubsequence=='function','<code>maximumSubsequence</code> should be a function.');"
        },
        {
          "text":
            "'<code>maximumSubsequence('+JSON.stringify(tests[0])+')</code> should return an array.'",
          "testString":
            "assert(Array.isArray(maximumSubsequence(tests[0])),'<code>maximumSubsequence('+JSON.stringify(tests[0])+')</code> should return an array.');"
        },
        {
          "text":
            "'<code>maximumSubsequence('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(maximumSubsequence(tests[0]),results[0],'<code>maximumSubsequence('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>maximumSubsequence('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(maximumSubsequence(tests[1]),results[1],'<code>maximumSubsequence('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>maximumSubsequence('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(maximumSubsequence(tests[2]),results[2],'<code>maximumSubsequence('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>maximumSubsequence('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(maximumSubsequence(tests[3]),results[3],'<code>maximumSubsequence('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>maximumSubsequence('+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(maximumSubsequence(tests[4]),results[4],'<code>maximumSubsequence('+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        },
        {
          "text":
            "'<code>maximumSubsequence('+JSON.stringify(tests[5])+')</code> should return <code>'+JSON.stringify(results[5])+'</code>.'",
          "testString":
            "assert.deepEqual(maximumSubsequence(tests[5]),results[5],'<code>maximumSubsequence('+JSON.stringify(tests[5])+')</code> should return <code>'+JSON.stringify(results[5])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7e84",
      "challengeType": 5,
      "releasedOn": "June 7, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function maximumSubsequence (population) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "let tests=[ [1,2,-1,3,10,-10],",
            "            [0, 8, 10, -2, -4, -1, -5, -3],",
            "            [9, 9, -10, 1],",
            "            [7, 1, -5, -3, -8, 1],",
            "            [-3, 6, -1, 4, -4, -6],",
            "            [-1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1]]",
            "let results=[ [ 1, 2, -1, 3, 10 ],",
            "          [ 0, 8, 10 ],",
            "          [ 9, 9 ],",
            "          [ 7, 1 ],",
            "          [ 6, -1, 4 ],",
            "          [ 3, 5, 6, -2, -1, 4 ] ]"
          ]
        }
      }
    },
    {
      "title": "Hailstone sequence",
      "description": [
        "<p>The Hailstone sequence of numbers can be generated from a starting positive integer,  n  by:</p>",
        " If  n  is   1   then the sequence ends.",
        " If  n  is  even then the next  n  of the sequence <code> = n/2 </code>",
        " If  n  is  odd   then the next  n  of the sequence <code> = (3 * n) + 1 </code><p>The (unproven) <a href=\"https://en.wikipedia.org/wiki/Collatz conjecture\" title=\"wp: Collatz conjecture\">Collatz conjecture</a> is that the hailstone sequence for any starting number always terminates.</p>",
        "<p>The hailstone sequence is also known as hailstone numbers (because the values are usually subject to multiple descents and ascents like hailstones in a cloud), or as the Collatz sequence.</p>",
        "Task:",
        "Create a routine to generate the hailstone sequence for a number.",
        "Use the routine to show that the hailstone sequence for the number 27 has 112 elements starting with <code>27, 82, 41, 124</code> and ending with <code>8, 4, 2, 1</code>",
        "Show the number less than 100,000 which has the longest hailstone sequence together with that sequence's length.   (But don't show the actual sequence!)See also:",
        " <a href=\"http://xkcd.com/710\" title=\"link: http://xkcd.com/710\">xkcd</a> (humourous)."
      ],
      "solutions": [
        "// noprotect\nfunction hailstoneSequence () {\n  const res = [];\n\n  function hailstone(n) {\n    const seq = [n];\n    while (n > 1) {\n      n = n % 2 ? 3 * n + 1 : n / 2;\n      seq.push(n);\n    }\n    return seq;\n  }\n\n  const h = hailstone(27);\n  const hLen = h.length;\n  res.push([...h.slice(0, 4), ...h.slice(hLen - 4, hLen)]);\n\n  let n = 0;\n  let max = 0;\n  for (let i = 100000; --i;) {\n    const seq = hailstone(i);\n    const sLen = seq.length;\n\n    if (sLen > max) {\n      n = i;\n      max = sLen;\n    }\n  }\n  res.push([max, n]);\n\n  return res;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>hailstoneSequence</code> is a function.",
          "testString":
            "assert(typeof hailstoneSequence === 'function', '<code>hailstoneSequence</code> is a function.');"
        },
        {
          "text":
            "<code>hailstoneSequence()</code> should return <code>[[27,82,41,124,8,4,2,1], [351, 77031]]</code>",
          "testString":
            "assert.deepEqual(hailstoneSequence(), res, '<code>hailstoneSequence()</code> should return <code>[[27,82,41,124,8,4,2,1], [351, 77031]]</code>');"
        }
      ],
      "id": "595608ff8bcd7a50bd490181",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "// noprotect",
            "function hailstoneSequence () {",
            "  const res = [];",
            "  // Good luck!",
            "",
            "  return res;",
            "}"
          ],
          "head": [],
          "tail": ["const res = [[27, 82, 41, 124, 8, 4, 2, 1], [351, 77031]];"]
        }
      }
    },
    {
      "title": "Happy numbers",
      "description": [
        "<p>A happy number is defined by the following process:</p>",
        "<p>Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers, while those that do not end in 1 are unhappy numbers.</p>",
        "<p>Implement a function that returns true if the number is happy, or false if not.</p>"
      ],
      "solutions": [
        "function happy (number) {\n  let m;\n  let digit;\n  const cycle = [];\n\n  while (number !== 1 && cycle[number] !== true) {\n    cycle[number] = true;\n    m = 0;\n    while (number > 0) {\n      digit = number % 10;\n      m += Math.pow(digit, 2);\n      number = (number - digit) / 10;\n    }\n    number = m;\n  }\n  return (number === 1);\n}\n"
      ],
      "tests": [
        {
          "text": "<code>happy</code> is a function.",
          "testString":
            "assert(typeof happy === 'function', '<code>happy</code> is a function.');"
        },
        {
          "text": "<code>happy(1)</code> should return a boolean.",
          "testString":
            "assert(typeof happy(1) === 'boolean', '<code>happy(1)</code> should return a boolean.');"
        },
        {
          "text": "<code>happy(1)</code> should return true.",
          "testString":
            "assert(happy(1), '<code>happy(1)</code> should return true.');"
        },
        {
          "text": "<code>happy(2)</code> should return false.",
          "testString":
            "assert(!happy(2), '<code>happy(2)</code> should return false.');"
        },
        {
          "text": "<code>happy(7)</code> should return true.",
          "testString":
            "assert(happy(7), '<code>happy(7)</code> should return true.');"
        },
        {
          "text": "<code>happy(10)</code> should return true.",
          "testString":
            "assert(happy(10), '<code>happy(10)</code> should return true.');"
        },
        {
          "text": "<code>happy(13)</code> should return true.",
          "testString":
            "assert(happy(13), '<code>happy(13)</code> should return true.');"
        },
        {
          "text": "<code>happy(19)</code> should return true.",
          "testString":
            "assert(happy(19), '<code>happy(19)</code> should return true.');"
        },
        {
          "text": "<code>happy(23)</code> should return true.",
          "testString":
            "assert(happy(23), '<code>happy(23)</code> should return true.');"
        },
        {
          "text": "<code>happy(28)</code> should return true.",
          "testString":
            "assert(happy(28), '<code>happy(28)</code> should return true.');"
        },
        {
          "text": "<code>happy(31)</code> should return true.",
          "testString":
            "assert(happy(31), '<code>happy(31)</code> should return true.');"
        },
        {
          "text": "<code>happy(32)</code> should return true:.",
          "testString":
            "assert(happy(32), '<code>happy(32)</code> should return true:.');"
        },
        {
          "text": "<code>happy(33)</code> should return false.",
          "testString":
            "assert(!happy(33), '<code>happy(33)</code> should return false.');"
        }
      ],
      "id": "594810f028c0303b75339ad1",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function happy (number) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Harshad or Niven series",
      "description": [
        "<p>The <a href=\"http://mathworld.wolfram.com/HarshadNumber.html\" title=\"link: http://mathworld.wolfram.com/HarshadNumber.html\">Harshad</a> or Niven numbers are positive integers ≥ 1 that are divisible by the sum of their digits.</p><p>For example,  42  is a <a href=\"http://rosettacode.org/wiki/oeis:A005349\" title=\"oeis:A005349\">Harshad number</a> as  42  is divisible by  (4 + 2)  without remainder.</p>",
        "Assume that the series is defined as the numbers in increasing order.",
        "Task:",
        "<p>Implement a function to generate successive members of the Harshad sequence.</p><p>Use it to list the first twenty members of the sequence and list the first Harshad number greater than 1000.</p>"
      ],
      "solutions": [
        "function isHarshadOrNiven() {\n  const res = {\n    firstTwenty: [],\n    firstOver1000: undefined\n  };\n\n  function isHarshad(n) {\n    let s = 0;\n    const nStr = n.toString();\n    for (let i = 0; i < nStr.length; ++i) {\n      s += parseInt(nStr.charAt(i), 10);\n    }\n    return n % s === 0;\n  }\n\n  let count = 0;\n  const harshads = [];\n\n  for (let n = 1; count < 20; ++n) {\n    if (isHarshad(n)) {\n      count++;\n      harshads.push(n);\n    }\n  }\n\n  res.firstTwenty = harshads;\n\n  let h = 1000;\n  while (!isHarshad(++h));\n  res.firstOver1000 = h;\n\n  return res;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>isHarshadOrNiven</code> is a function.",
          "testString":
            "assert(typeof isHarshadOrNiven === 'function', '<code>isHarshadOrNiven</code> is a function.');"
        },
        {
          "text":
            "<code>isHarshadOrNiven()</code> should return <code>{\"firstTwenty\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42],\"firstOver1000\": 1002}</code>",
          "testString":
            "assert.deepEqual(isHarshadOrNiven(), res, '<code>isHarshadOrNiven()</code> should return <code>{\"firstTwenty\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42],\"firstOver1000\": 1002}</code>');"
        }
      ],
      "id": "595668ca4cfe1af2fb9818d4",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function isHarshadOrNiven () {",
            "  const res = {",
            "    firstTwenty: [],",
            "    firstOver1000: undefined",
            "  };",
            "  // Change after this line",
            "",
            "  return res;",
            "}"
          ],
          "head": [],
          "tail": [
            "const res = {",
            "  firstTwenty: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42],",
            "  firstOver1000: 1002",
            "};"
          ]
        }
      }
    },
    {
      "title": "Hash from two arrays",
      "description": [
        "Task:",
        "<p>Using two Arrays of equal length, create a Hash object where the elements from one array (the keys) are linked to the elements of the other (the values)</p>",
        "Related task:",
        " <a href=\"http://rosettacode.org/wiki/Associative arrays/Creation\" title=\"Associative arrays/Creation\">Associative arrays/Creation</a>"
      ],
      "solutions": [
        "function arrToObj (keys, vals) {\n  return keys.reduce((map, key, index) => {\n    map[key] = vals[index];\n    return map;\n  }, {});\n}"
      ],
      "tests": [
        {
          "text": "<code>arrToObj</code> is a function.",
          "testString":
            "assert(typeof arrToObj === 'function', '<code>arrToObj</code> is a function.');"
        },
        {
          "text":
            "<code>arrToObj([1, 2, 3, 4, 5], [\"a\", \"b\", \"c\", \"d\", \"e\"])</code> should return <code>{ 1: \"a\", 2: \"b\", 3: \"c\", 4: \"d\", 5: \"e\" }</code>",
          "testString":
            "assert.deepEqual(arrToObj(...testCases[0]), res[0], '<code>arrToObj([1, 2, 3, 4, 5], [\"a\", \"b\", \"c\", \"d\", \"e\"])</code> should return <code>{ 1: \"a\", 2: \"b\", 3: \"c\", 4: \"d\", 5: \"e\" }</code>');"
        },
        {
          "text":
            "<code>arrToObj([1, 2, 3, 4, 5], [\"a\", \"b\", \"c\", \"d\"])</code> should return <code>{ 1: \"a\", 2: \"b\", 3: \"c\", 4: \"d\", 5: undefined }</code>",
          "testString":
            "assert.deepEqual(arrToObj(...testCases[1]), res[1], '<code>arrToObj([1, 2, 3, 4, 5], [\"a\", \"b\", \"c\", \"d\"])</code> should return <code>{ 1: \"a\", 2: \"b\", 3: \"c\", 4: \"d\", 5: undefined }</code>');"
        },
        {
          "text":
            "<code>arrToObj([1, 2, 3], [\"a\", \"b\", \"c\", \"d\", \"e\"])</code> should return <code>{ 1: \"a\", 2: \"b\", 3: \"c\" }</code>",
          "testString":
            "assert.deepEqual(arrToObj(...testCases[2]), res[2], '<code>arrToObj([1, 2, 3], [\"a\", \"b\", \"c\", \"d\", \"e\"])</code> should return <code>{ 1: \"a\", 2: \"b\", 3: \"c\" }</code>');"
        },
        {
          "text":
            "<code>arrToObj([\"a\", \"b\", \"c\", \"d\", \"e\"], [1, 2, 3, 4, 5])</code> should return <code>{ \"a\": 1, \"b\": 2, \"c\": 3 , \"d\": 4, \"e\": 5 }</code>",
          "testString":
            "assert.deepEqual(arrToObj(...testCases[3]), res[3], '<code>arrToObj([\"a\", \"b\", \"c\", \"d\", \"e\"], [1, 2, 3, 4, 5])</code> should return <code>{ \"a\": 1, \"b\": 2, \"c\": 3 , \"d\": 4, \"e\": 5 }</code>');"
        },
        {
          "text":
            "<code>arrToObj([\"a\", \"b\", \"c\", \"d\", \"e\"], [1, 2, 3, 4])</code> should return <code>{ \"a\": 1, \"b\": 2, \"c\": 3 , \"d\": 4, \"e\": undefined }</code>",
          "testString":
            "assert.deepEqual(arrToObj(...testCases[4]), res[4], '<code>arrToObj([\"a\", \"b\", \"c\", \"d\", \"e\"], [1, 2, 3, 4])</code> should return <code>{ \"a\": 1, \"b\": 2, \"c\": 3 , \"d\": 4, \"e\": undefined }</code>');"
        },
        {
          "text":
            "<code>arrToObj([\"a\", \"b\", \"c\"], [1, 2, 3, 4, 5])</code> should return <code>{ \"a\": 1, \"b\": 2, \"c\": 3  }</code>",
          "testString":
            "assert.deepEqual(arrToObj(...testCases[5]), res[5], '<code>arrToObj([\"a\", \"b\", \"c\"], [1, 2, 3, 4, 5])</code> should return <code>{ \"a\": 1, \"b\": 2, \"c\": 3  }</code>');"
        }
      ],
      "id": "595671d4d2cdc305f0d5b36f",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function arrToObj (keys, vals) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const testCases = [",
            "  [[1, 2, 3, 4, 5], ['a', 'b', 'c', 'd', 'e']],",
            "  [[1, 2, 3, 4, 5], ['a', 'b', 'c', 'd']],",
            "  [[1, 2, 3], ['a', 'b', 'c', 'd', 'e']],",
            "  [['a', 'b', 'c', 'd', 'e'], [1, 2, 3, 4, 5]],",
            "  [['a', 'b', 'c', 'd', 'e'], [1, 2, 3, 4]],",
            "  [['a', 'b', 'c'], [1, 2, 3, 4, 5]]",
            "];",
            "",
            "const res = [",
            "  { 1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e' },",
            "  { 1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: undefined },",
            "  { 1: 'a', 2: 'b', 3: 'c' },",
            "  { a: 1, b: 2, c: 3, d: 4, e: 5 },",
            "  { a: 1, b: 2, c: 3, d: 4, e: undefined },",
            "  { a: 1, b: 2, c: 3 }",
            "];"
          ]
        }
      }
    },
    {
      "title": "Hash join",
      "description": [
        "<p>An <a href=\"https://en.wikipedia.org/wiki/Join_(SQL)#Inner_join\" title=\"wp: Join_(SQL)#Inner_join\">inner join</a> is an operation that combines two data tables into one table, based on matching column values. The simplest way of implementing this operation is the <a href=\"https://en.wikipedia.org/wiki/Nested loop join\" title=\"wp: Nested loop join\">nested loop join</a> algorithm, but a more scalable alternative is the <a href=\"https://en.wikipedia.org/wiki/hash join\" title=\"wp: hash join\">hash join</a> algorithm.</p>",
        "<p>Implement the \"hash join\" algorithm, and demonstrate that it passes the test-case listed below.</p><p>You should represent the tables as data structures that feel natural in your programming language.</p>",
        "<p>The \"hash join\" algorithm consists of two steps:</p>",
        "Hash phase: Create a <a href=\"https://en.wikipedia.org/wiki/Multimap\" title=\"wp: Multimap\">multimap</a> from one of the two tables, mapping from each join column value to all the rows that contain it.",
        " The multimap must support hash-based lookup which scales better than a simple linear search, because that's the whole point of this algorithm.",
        " Ideally we should create the multimap for the smaller table, thus minimizing its creation time and memory size.",
        "Join phase: Scan the other table, and find matching rows by looking in the multimap created before.",
        "<p>In pseudo-code, the algorithm could be expressed as follows:</p>",
        "<pre>",
        "let A = the first input table (or ideally, the larger one)",
        "let B = the second input table (or ideally, the smaller one)",
        "let j<sub>A</sub> = the join column ID of table A",
        "let j<sub>B</sub> = the join column ID of table B",
        "let M<sub>B</sub> = a multimap for mapping from single values to multiple rows of table B (starts out empty)",
        "let C = the output table (starts out empty)",
        "for each row b in table B:",
        "  place b in multimap M<sub>B</sub> under key b(j<sub>B</sub>)",
        "for each row a in table A:",
        "  for each row b in multimap M<sub>B</sub> under key a(j<sub>A</sub>):",
        "    let c = the concatenation of row a and row b",
        "    place row c in table C</p>",
        "</pre>",
        "Test-case",
        "<p>Input</p>",
        "<table>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\">",
        "<table style=\"border:none; border-collapse:collapse;\">",
        "<tr>",
        "<td style=\"border:none\"> <i>A =</i>",
        "</td>",
        "<td style=\"border:none\">",
        "<table>",
        "<tr>",
        "<th style=\"padding: 4px; margin: 5px;\"> Age </th>",
        "<th style=\"padding: 4px; margin: 5px;\"> Name",
        "</th></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 27 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Jonah",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 18 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 28 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Glory",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 18 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Popeye",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 28 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan",
        "</td></tr></table>",
        "</td>",
        "<td style=\"border:none; padding-left:1.5em;\" rowspan=\"2\">",
        "</td>",
        "<td style=\"border:none\"> <i>B =</i>",
        "</td>",
        "<td style=\"border:none\">",
        "<table>",
        "<tr>",
        "<th style=\"padding: 4px; margin: 5px;\"> Character </th>",
        "<th style=\"padding: 4px; margin: 5px;\"> Nemesis",
        "</th></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> Jonah </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Whales",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> Jonah </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Spiders",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Ghosts",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Zombies",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> Glory </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Buffy",
        "</td></tr></table>",
        "</td></tr>",
        "<tr>",
        "<td style=\"border:none\"> <i>j<sub>A</sub> =</i>",
        "</td>",
        "<td style=\"border:none\"> <i><code>Name</code> (i.e. column 1)</i>",
        "</td>",
        "<td style=\"border:none\"> <i>j<sub>B</sub> =</i>",
        "</td>",
        "<td style=\"border:none\"> <i><code>Character</code> (i.e. column 0)</i>",
        "</td></tr></table>",
        "</td>",
        "<td style=\"padding: 4px; margin: 5px;\">",
        "</td></tr></table>",
        "<p>Output</p>",
        "<table>",
        "<tr>",
        "<th style=\"padding: 4px; margin: 5px;\"> A.Age </th>",
        "<th style=\"padding: 4px; margin: 5px;\"> A.Name </th>",
        "<th style=\"padding: 4px; margin: 5px;\"> B.Character </th>",
        "<th style=\"padding: 4px; margin: 5px;\"> B.Nemesis",
        "</th></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 27 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Jonah </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Jonah </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Whales",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 27 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Jonah </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Jonah </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Spiders",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 18 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Ghosts",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 18 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Zombies",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 28 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Glory </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Glory </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Buffy",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 28 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Ghosts",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 28 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Zombies",
        "</td></tr></table>",
        "<p></p><p></p><p>The order of the rows in the output table is not significant.</p>",
        "<p>If you're using numerically indexed arrays to represent table rows (rather than referring to columns by name), you could represent the output rows in the form <code style=\"white-space:nowrap\">[[27, \"Jonah\"], [\"Jonah\", \"Whales\"]]</code>.</p><hr>"
      ],
      "solutions": [
        "function hashJoin (hash1, hash2) {\n  const hJoin = (tblA, tblB, strJoin) => {\n    const [jA, jB] = strJoin.split('=');\n    const M = tblB.reduce((a, x) => {\n      const id = x[jB];\n      return (\n        a[id] ? a[id].push(x) : (a[id] = [x]),\n        a\n      );\n    }, {});\n\n    return tblA.reduce((a, x) => {\n      const match = M[x[jA]];\n      return match ? (\n                a.concat(match.map(row => dictConcat(x, row)))\n            ) : a;\n    }, []);\n  };\n\n  const dictConcat = (dctA, dctB) => {\n    const ok = Object.keys;\n    return ok(dctB).reduce(\n            (a, k) => (a[`B_${k}`] = dctB[k]) && a,\n            ok(dctA).reduce(\n                (a, k) => (a[`A_${k}`] = dctA[k]) && a, {}\n            )\n        );\n  };\n\n  return hJoin(hash1, hash2, 'name=character');\n}\n\n"
      ],
      "tests": [
        {
          "text": "<code>hashJoin</code> is a function.",
          "testString":
            "assert(typeof hashJoin === 'function', '<code>hashJoin</code> is a function.');"
        },
        {
          "text":
            "<code>hashJoin([{ age: 27, name: \"Jonah\" }, { age: 18, name: \"Alan\" }, { age: 28, name: \"Glory\" }, { age: 18, name: \"Popeye\" }, { age: 28, name: \"Alan\" }], [{ character: \"Jonah\", nemesis: \"Whales\" }, { character: \"Jonah\", nemesis: \"Spiders\" }, { character: \"Alan\", nemesis: \"Ghosts\" }, { character:\"Alan\", nemesis: \"Zombies\" }, { character: \"Glory\", nemesis: \"Buffy\" }, { character: \"Bob\", nemesis: \"foo\" }])</code> should return <code>[{\"A_age\": 27,\"A_name\": \"Jonah\", \"B_character\": \"Jonah\", \"B_nemesis\": \"Whales\"}, {\"A_age\": 27,\"A_name\": \"Jonah\", \"B_character\": \"Jonah\", \"B_nemesis\": \"Spiders\"}, {\"A_age\": 18,\"A_name\": \"Alan\", \"B_character\": \"Alan\", \"B_nemesis\": \"Ghosts\"}, {\"A_age\": 18,\"A_name\": \"Alan\", \"B_character\": \"Alan\", \"B_nemesis\": \"Zombies\"}, {\"A_age\": 28,\"A_name\": \"Glory\", \"B_character\": \"Glory\", \"B_nemesis\": \"Buffy\"}, {\"A_age\": 28,\"A_name\": \"Alan\", \"B_character\": \"Alan\", \"B_nemesis\": \"Ghosts\"}, {\"A_age\": 28,\"A_name\": \"Alan\", \"B_character\": \"Alan\", \"B_nemesis\": \"Zombies\"}]</code>",
          "testString":
            "assert.deepEqual(hashJoin(hash1, hash2), res, '<code>hashJoin([{ age: 27, name: \"Jonah\" }, { age: 18, name: \"Alan\" }, { age: 28, name: \"Glory\" }, { age: 18, name: \"Popeye\" }, { age: 28, name: \"Alan\" }], [{ character: \"Jonah\", nemesis: \"Whales\" }, { character: \"Jonah\", nemesis: \"Spiders\" }, { character: \"Alan\", nemesis: \"Ghosts\" }, { character:\"Alan\", nemesis: \"Zombies\" }, { character: \"Glory\", nemesis: \"Buffy\" }, { character: \"Bob\", nemesis: \"foo\" }])</code> should return <code>[{\"A_age\": 27,\"A_name\": \"Jonah\", \"B_character\": \"Jonah\", \"B_nemesis\": \"Whales\"}, {\"A_age\": 27,\"A_name\": \"Jonah\", \"B_character\": \"Jonah\", \"B_nemesis\": \"Spiders\"}, {\"A_age\": 18,\"A_name\": \"Alan\", \"B_character\": \"Alan\", \"B_nemesis\": \"Ghosts\"}, {\"A_age\": 18,\"A_name\": \"Alan\", \"B_character\": \"Alan\", \"B_nemesis\": \"Zombies\"}, {\"A_age\": 28,\"A_name\": \"Glory\", \"B_character\": \"Glory\", \"B_nemesis\": \"Buffy\"}, {\"A_age\": 28,\"A_name\": \"Alan\", \"B_character\": \"Alan\", \"B_nemesis\": \"Ghosts\"}, {\"A_age\": 28,\"A_name\": \"Alan\", \"B_character\": \"Alan\", \"B_nemesis\": \"Zombies\"}]</code>');"
        }
      ],
      "id": "5956795bc9e2c415eb244de1",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function hashJoin (hash1, hash2) {",
            "  // Good luck!",
            "  return [];",
            "}"
          ],
          "head": [],
          "tail": [
            "const hash1 = [",
            "    { age: 27, name: 'Jonah' },",
            "    { age: 18, name: 'Alan' },",
            "    { age: 28, name: 'Glory' },",
            "    { age: 18, name: 'Popeye' },",
            "    { age: 28, name: 'Alan' }",
            "];",
            "",
            "const hash2 = [",
            "    { character: 'Jonah', nemesis: 'Whales' },",
            "    { character: 'Jonah', nemesis: 'Spiders' },",
            "    { character: 'Alan', nemesis: 'Ghosts' },",
            "    { character: 'Alan', nemesis: 'Zombies' },",
            "    { character: 'Glory', nemesis: 'Buffy' },",
            "    { character: 'Bob', nemesis: 'foo' }",
            "];",
            "",
            "const res = [",
            "    { A_age: 27, A_name: 'Jonah', B_character: 'Jonah', B_nemesis: 'Whales' },",
            "    { A_age: 27, A_name: 'Jonah', B_character: 'Jonah', B_nemesis: 'Spiders' },",
            "    { A_age: 18, A_name: 'Alan', B_character: 'Alan', B_nemesis: 'Ghosts' },",
            "    { A_age: 18, A_name: 'Alan', B_character: 'Alan', B_nemesis: 'Zombies' },",
            "    { A_age: 28, A_name: 'Glory', B_character: 'Glory', B_nemesis: 'Buffy' },",
            "    { A_age: 28, A_name: 'Alan', B_character: 'Alan', B_nemesis: 'Ghosts' },",
            "    { A_age: 28, A_name: 'Alan', B_character: 'Alan', B_nemesis: 'Zombies' }",
            "];",
            "",
            "const bench1 = [{ name: 'u2v7v', num: 1 }, { name: 'n53c8', num: 10 }, { name: 'oysce', num: 9 }, { name: '0mto2s', num: 1 }, { name: 'vkh5id', num: 4 }, { name: '5od0cf', num: 8 }, { name: 'uuulue', num: 10 }, { name: '3rgsbi', num: 9 }, { name: 'kccv35r', num: 4 }, { name: '80un74', num: 9 }, { name: 'h4pp3', num: 6 }, { name: '51bit', num: 7 }, { name: 'j9ndf', num: 8 }, { name: 'vf3u1', num: 10 }, { name: 'g0bw0om', num: 10 }, { name: 'j031x', num: 7 }, { name: 'ij3asc', num: 9 }, { name: 'byv83y', num: 8 }, { name: 'bjzp4k', num: 4 }, { name: 'f3kbnm', num: 10 }];",
            "const bench2 = [{ friend: 'o8b', num: 8 }, { friend: 'ye', num: 2 }, { friend: '32i', num: 5 }, { friend: 'uz', num: 3 }, { friend: 'a5k', num: 4 }, { friend: 'uad', num: 7 }, { friend: '3w5', num: 10 }, { friend: 'vw', num: 10 }, { friend: 'ah', num: 4 }, { friend: 'qv', num: 7 }, { friend: 'ozv', num: 2 }, { friend: '9ri', num: 10 }, { friend: '7nu', num: 4 }, { friend: 'w3', num: 9 }, { friend: 'tgp', num: 8 }, { friend: 'ibs', num: 1 }, { friend: 'ss7', num: 6 }, { friend: 'g44', num: 9 }, { friend: 'tab', num: 9 }, { friend: 'zem', num: 10 }];"
          ]
        }
      }
    },
    {
      "title": "Heronian triangles",
      "description": [
        "<p><a href=\"https://en.wikipedia.org/wiki/Heron's formula\" title=\"wp: Heron's formula\">Hero's formula</a> for the area of a triangle given the length of its three sides  <big> a,</big>  <big>b,</big>  and  <big>c</big>  is given by:</p><p><big>$$A = \\sqrt{s(s-a)(s-b)(s-c)},$$</big></p><p>where  <big>s</big>  is half the perimeter of the triangle; that is,</p><p><big>$$s=\\frac{a+b+c}{2}.$$</big></p>",
        "<p><a href=\"http://www.had2know.com/academics/heronian-triangles-generator-calculator.html\" title=\"link: http://www.had2know.com/academics/heronian-triangles-generator-calculator.html\">Heronian triangles</a> are triangles whose sides and area are all integers.</p>",
        "<p> An example is the triangle with sides  3, 4, 5  whose area is  6  (and whose perimeter is  12). </p>",
        "<p>Note that any triangle whose sides are all an integer multiple of  3, 4, 5;  such as  6, 8, 10,  will also be a Heronian triangle.</p><p>Define a Primitive Heronian triangle as a Heronian triangle where the greatest common divisor</p>",
        "<p>of all three sides is  1  (unity).</p><p>This will exclude, for example, triangle  6, 8, 10.</p>",
        "Task:",
        "<p>Implement a function based on Hero's formula that returns the first <code>n<sub>th</sub></code> ordered triangles in an array of arrays.</p>"
      ],
      "solutions": [
        "// noprotect\nfunction heronianTriangle (n) {\n  const list = [];\n  const result = [];\n\n  let j = 0;\n  for (let c = 1; c <= 200; c++) {\n    for (let b = 1; b <= c; b++) {\n      for (let a = 1; a <= b; a++) {\n        if (gcd(gcd(a, b), c) === 1 && isHeron(heronArea(a, b, c))) {\n          list[j++] = new Array(a, b, c, heronArea(a, b, c));\n        }\n      }\n    }\n  }\n\n  sort(list);\n\n  for (let i = 0; i < n; i++) {\n    result[i] = [list[i][0], list[i][1], list[i][2]];\n  }\n\n  return result;\n\n  function heronArea(a, b, c) {\n    const s = (a + b + c) / 2;\n    return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n  }\n\n  function isHeron(h) { return h % 1 === 0 && h > 0; }\n\n  function gcd(a, b) {\n    let leftover = 1;\n    let dividend = a > b ? a : b;\n    let divisor = a > b ? b : a;\n    while (leftover !== 0) {\n      leftover = dividend % divisor;\n      if (leftover > 0) {\n        dividend = divisor;\n        divisor = leftover;\n      }\n    }\n    return divisor;\n  }\n\n  function sort(arg) {\n    let swapped = true;\n    let temp = [];\n    while (swapped) {\n      swapped = false;\n      for (let i = 1; i < arg.length; i++) {\n        if (arg[i][4] < arg[i - 1][4] || arg[i][4] === arg[i - 1][4] && arg[i][3] < arg[i - 1][3]) {\n          temp = arg[i];\n          arg[i] = arg[i - 1];\n          arg[i - 1] = temp;\n          swapped = true;\n        }\n      }\n    }\n  }\n}\n"
      ],
      "tests": [
        {
          "text": "<code>heronianTriangle</code> is a function.",
          "testString":
            "assert(typeof heronianTriangle === 'function', '<code>heronianTriangle</code> is a function.');"
        },
        {
          "text":
            "<code>heronianTriangle()</code> should return <code>[[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17]]</code>",
          "testString":
            "assert.deepEqual(heronianTriangle(testCases[0]), res[0], '<code>heronianTriangle()</code> should return <code>[[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17]]</code>');"
        },
        {
          "text":
            "<code>heronianTriangle()</code> should return <code>[[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17], [13, 13, 24], [6, 25, 29], [11, 13, 20], [5, 29, 30], [13, 14, 15]],</code>",
          "testString":
            "assert.deepEqual(heronianTriangle(testCases[1]), res[1], '<code>heronianTriangle()</code> should return <code>[[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17], [13, 13, 24], [6, 25, 29], [11, 13, 20], [5, 29, 30], [13, 14, 15]],</code>');"
        },
        {
          "text":
            "<code>heronianTriangle()</code> should return <code>[[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17], [13, 13, 24], [6, 25, 29], [11, 13, 20], [5, 29, 30], [13, 14, 15], [10, 17, 21], [7, 24, 25], [8, 29, 35], [12, 17, 25], [4, 51, 53]],</code>",
          "testString":
            "assert.deepEqual(heronianTriangle(testCases[2]), res[2], '<code>heronianTriangle()</code> should return <code>[[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17], [13, 13, 24], [6, 25, 29], [11, 13, 20], [5, 29, 30], [13, 14, 15], [10, 17, 21], [7, 24, 25], [8, 29, 35], [12, 17, 25], [4, 51, 53]],</code>');"
        },
        {
          "text":
            "<code>heronianTriangle()</code> should return <code>[[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17], [13, 13, 24], [6, 25, 29], [11, 13, 20], [5, 29, 30], [13, 14, 15], [10, 17, 21], [7, 24, 25], [8, 29, 35], [12, 17, 25], [4, 51, 53], [19, 20, 37],[16, 17, 17], [17, 17, 30], [16, 25, 39], [13, 20, 21]]</code>",
          "testString":
            "assert.deepEqual(heronianTriangle(testCases[3]), res[3], '<code>heronianTriangle()</code> should return <code>[[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17], [13, 13, 24], [6, 25, 29], [11, 13, 20], [5, 29, 30], [13, 14, 15], [10, 17, 21], [7, 24, 25], [8, 29, 35], [12, 17, 25], [4, 51, 53], [19, 20, 37],[16, 17, 17], [17, 17, 30], [16, 25, 39], [13, 20, 21]]</code>');"
        }
      ],
      "id": "595b98f8b5a2245e243aa831",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "// noprotect",
            "function heronianTriangle (n) {",
            "  // Good luck!",
            "",
            "  return [];",
            "}"
          ],
          "head": [],
          "tail": [
            "const testCases = [10, 15, 20, 25];",
            "",
            "const res = [",
            "  [[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17]],",
            "  [[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17], [13, 13, 24], [6, 25, 29], [11, 13, 20], [5, 29, 30], [13, 14, 15]],",
            "  [[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17], [13, 13, 24], [6, 25, 29], [11, 13, 20], [5, 29, 30], [13, 14, 15], [10, 17, 21], [7, 24, 25], [8, 29, 35], [12, 17, 25], [4, 51, 53]],",
            "  [[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17], [13, 13, 24], [6, 25, 29], [11, 13, 20], [5, 29, 30], [13, 14, 15], [10, 17, 21], [7, 24, 25], [8, 29, 35], [12, 17, 25], [4, 51, 53], [19, 20, 37], [16, 17, 17], [17, 17, 30], [16, 25, 39], [13, 20, 21]]",
            "];"
          ]
        }
      }
    },
    {
      "title": "Hofstadter Figure-Figure sequences",
      "description": [
        "<p>These two sequences of positive integers are defined as:</p>",
        "<p><big>$$R(1)=1\\ ;\\ S(1)=2 \\\\R(n)=R(n-1)+S(n-1), \\quad n>1.$$</big></p>",
        "<p>The sequence <big>$S(n)$</big> is further defined as the sequence of positive integers not present in <big>$R(n)$</big>.</p><p>Sequence <big>$R$</big> starts:</p>",
        "<p>1, 3, 7, 12, 18, ...</p>",
        "<p>Sequence <big>$S$</big> starts:</p>",
        "<p>2, 4, 5, 6, 8, ...</p>",
        "Task:",
        "Create two functions named ffr and ffs that when given n return R(n) or S(n) respectively.(Note that R(1) = 1 and S(1) = 2 to avoid off-by-one errors).",
        "No maximum value for n should be assumed.",
        "Sloane's <a href=\"http://oeis.org/A005228\" title=\"link: http://oeis.org/A005228\">A005228</a> and <a href=\"http://oeis.org/A030124\" title=\"link: http://oeis.org/A030124\">A030124</a>.",
        "<a href=\"http://mathworld.wolfram.com/HofstadterFigure-FigureSequence.html\" title=\"link: http://mathworld.wolfram.com/HofstadterFigure-FigureSequence.html\">Wolfram MathWorld</a>",
        "Wikipedia: <a href=\"https://en.wikipedia.org/wiki/Hofstadter_sequence#Hofstadter_Figure-Figure_sequences\" title=\"wp: Hofstadter_sequence#Hofstadter_Figure-Figure_sequences\">Hofstadter Figure-Figure sequences</a>."
      ],
      "solutions": [
        "// noprotect\nconst R = [null, 1];\nconst S = [null, 2];\n\nfunction extendSequences (n) {\n  let current = Math.max(R[R.length - 1], S[S.length - 1]);\n  let i;\n  while (R.length <= n || S.length <= n) {\n    i = Math.min(R.length, S.length) - 1;\n    current += 1;\n    if (current === R[i] + S[i]) {\n      R.push(current);\n    } else {\n      S.push(current);\n    }\n  }\n}\n\nfunction ffr (n) {\n  extendSequences(n);\n  return R[n];\n}\n\nfunction ffs (n) {\n  extendSequences(n);\n  return S[n];\n}\n"
      ],
      "tests": [
        {
          "text": "<code>ffr</code> is a function.",
          "testString":
            "assert(typeof ffr === 'function', '<code>ffr</code> is a function.');"
        },
        {
          "text": "<code>ffs</code> is a function.",
          "testString":
            "assert(typeof ffs === 'function', '<code>ffs</code> is a function.');"
        },
        {
          "text": "<code>ffr</code> should return integer.",
          "testString":
            "assert(Number.isInteger(ffr(1)), '<code>ffr</code> should return integer.');"
        },
        {
          "text": "<code>ffs</code> should return integer.",
          "testString":
            "assert(Number.isInteger(ffs(1)), '<code>ffs</code> should return integer.');"
        },
        {
          "text": "<code>ffr()</code> should return <code>69</code>",
          "testString":
            "assert.equal(ffr(ffrParamRes[0][0]), ffrParamRes[0][1], '<code>ffr()</code> should return <code>69</code>');"
        },
        {
          "text": "<code>ffr()</code> should return <code>1509</code>",
          "testString":
            "assert.equal(ffr(ffrParamRes[1][0]), ffrParamRes[1][1], '<code>ffr()</code> should return <code>1509</code>');"
        },
        {
          "text": "<code>ffr()</code> should return <code>5764</code>",
          "testString":
            "assert.equal(ffr(ffrParamRes[2][0]), ffrParamRes[2][1], '<code>ffr()</code> should return <code>5764</code>');"
        },
        {
          "text": "<code>ffr()</code> should return <code>526334</code>",
          "testString":
            "assert.equal(ffr(ffrParamRes[3][0]), ffrParamRes[3][1], '<code>ffr()</code> should return <code>526334</code>');"
        },
        {
          "text": "<code>ffs()</code> should return <code>14</code>",
          "testString":
            "assert.equal(ffs(ffsParamRes[0][0]), ffsParamRes[0][1], '<code>ffs()</code> should return <code>14</code>');"
        },
        {
          "text": "<code>ffs()</code> should return <code>59</code>",
          "testString":
            "assert.equal(ffs(ffsParamRes[1][0]), ffsParamRes[1][1], '<code>ffs()</code> should return <code>59</code>');"
        },
        {
          "text": "<code>ffs()</code> should return <code>112</code>",
          "testString":
            "assert.equal(ffs(ffsParamRes[2][0]), ffsParamRes[2][1], '<code>ffs()</code> should return <code>112</code>');"
        },
        {
          "text": "<code>ffs()</code> should return <code>1041</code>",
          "testString":
            "assert.equal(ffs(ffsParamRes[3][0]), ffsParamRes[3][1], '<code>ffs()</code> should return <code>1041</code>');"
        }
      ],
      "id": "59622f89e4e137560018a40e",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "// noprotect",
            "function ffr(n) {",
            "  return n;",
            "}",
            "",
            "function ffs(n) {",
            "  return n;",
            "}"
          ],
          "head": [],
          "tail": [
            "const ffrParamRes = [[10, 69], [50, 1509], [100, 5764], [1000, 526334]];",
            "const ffsParamRes = [[10, 14], [50, 59], [100, 112], [1000, 1041]];",
            ""
          ]
        }
      }
    },
    {
      "title": "Hofstadter Q sequence",
      "description": [
        "<p>The <a href=\"https://en.wikipedia.org/wiki/Hofstadter_sequence#Hofstadter_Q_sequence\" title=\"wp: Hofstadter_sequence#Hofstadter_Q_sequence\">Hofstadter Q sequence</a> is defined as:</p>",
        "<p>$Q(1)=Q(2)=1, \\\\ Q(n)=Q\\big(n-Q(n-1)\\big)+Q\\big(n-Q(n-2)), \\quad n>2.$</p>",
        "<p>It is defined like the <a href=\"http://rosettacode.org/wiki/Fibonacci sequence\" title=\"Fibonacci sequence\">Fibonacci sequence</a>, but whereas the next term in the Fibonacci sequence is the sum of the previous two terms, in the Q sequence the previous two terms tell you how far to go back in the Q sequence to find the two numbers to sum to make the next term of the sequence.</p>",
        "Task:",
        "Implement the Hofstadter Q Sequence equation into JavaScript"
      ],
      "solutions": [
        "function hofstadterQ (n) {\n  const memo = [1, 1, 1];\n  const Q = function (i) {\n    let result = memo[i];\n    if (typeof result !== 'number') {\n      result = Q(i - Q(i - 1)) + Q(i - Q(i - 2));\n      memo[i] = result;\n    }\n    return result;\n  };\n  return Q(n);\n}\n"
      ],
      "tests": [
        {
          "text": "<code>hofstadterQ</code> is a function.",
          "testString":
            "assert(typeof hofstadterQ === 'function', '<code>hofstadterQ</code> is a function.');"
        },
        {
          "text":
            "<code>hofstadterQ()</code> should return <code>integer</code>",
          "testString":
            "assert(Number.isInteger(hofstadterQ(1000)), '<code>hofstadterQ()</code> should return <code>integer</code>');"
        },
        {
          "text":
            "<code>hofstadterQ(1000)</code> should return <code>502</code>",
          "testString":
            "assert.equal(hofstadterQ(testCase[0]), res[0], '<code>hofstadterQ(1000)</code> should return <code>502</code>');"
        },
        {
          "text":
            "<code>hofstadterQ(1500)</code> should return <code>755</code>",
          "testString":
            "assert.equal(hofstadterQ(testCase[1]), res[1], '<code>hofstadterQ(1500)</code> should return <code>755</code>');"
        },
        {
          "text":
            "<code>hofstadterQ(2000)</code> should return <code>1005</code>",
          "testString":
            "assert.equal(hofstadterQ(testCase[2]), res[2], '<code>hofstadterQ(2000)</code> should return <code>1005</code>');"
        },
        {
          "text":
            "<code>hofstadterQ(2500)</code> should return <code>1261</code>",
          "testString":
            "assert.equal(hofstadterQ(testCase[3]), res[3], '<code>hofstadterQ(2500)</code> should return <code>1261</code>');"
        }
      ],
      "id": "59637c4d89f6786115efd814",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function hofstadterQ (n) {",
            "  // Good luck!",
            "  return n;",
            "}"
          ],
          "head": [],
          "tail": [
            "const testCase = [1000, 1500, 2000, 2500];",
            "const res = [502, 755, 1005, 1261];"
          ]
        }
      }
    },
    {
      "title": "I before E except after C",
      "description": [
        "The phrase   <a href=\"https://en.wikipedia.org/wiki/I before E except after C\"> \"I before E, except after C\"</a> is a widely known mnemonic which is supposed to help when spelling English words.",
        "Using the words provided, check if the two sub-clauses of the phrase are plausible individually:",
        "<ol><li style='margin-bottom: 5px;'><i>\"I before E when not preceded by C\".</i></li><li><i>\"E before I when preceded by C\".</i></li></ol>",
        "If both sub-phrases are plausible then the original phrase can be said to be plausible.",
        "Write a function that accepts a word and check if the word follows this rule. The function should return true if it follows the rule otherwise false."
      ],
      "solutions": [
        "function IBeforeExceptC (word)\n{\n\tif(word.indexOf(\"c\")==-1 && word.indexOf(\"ie\")!=-1)\n\t\treturn true;\n\telse if(word.indexOf(\"cei\")!=-1)\n\t\treturn true;\n\treturn false;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>IBeforeExceptC</code> should be a function.'",
          "testString":
            "assert(typeof IBeforeExceptC=='function','<code>IBeforeExceptC</code> should be a function.');"
        },
        {
          "text":
            "'<code>IBeforeExceptC(\"receive\")</code> should return a boolean.'",
          "testString":
            "assert(typeof IBeforeExceptC(\"receive\")=='boolean','<code>IBeforeExceptC(\"receive\")</code> should return a boolean.');"
        },
        {
          "text":
            "'<code>IBeforeExceptC(\"receive\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(IBeforeExceptC(\"receive\"),true,'<code>IBeforeExceptC(\"receive\")</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>IBeforeExceptC(\"science\")</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(IBeforeExceptC(\"science\"),false,'<code>IBeforeExceptC(\"science\")</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>IBeforeExceptC(\"imperceivable\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(IBeforeExceptC(\"imperceivable\"),true,'<code>IBeforeExceptC(\"imperceivable\")</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>IBeforeExceptC(\"inconceivable\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(IBeforeExceptC(\"inconceivable\"),true,'<code>IBeforeExceptC(\"inconceivable\")</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>IBeforeExceptC(\"insufficient\")</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(IBeforeExceptC(\"insufficient\"),false,'<code>IBeforeExceptC(\"insufficient\")</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>IBeforeExceptC(\"omniscient\")</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(IBeforeExceptC(\"omniscient\"),false,'<code>IBeforeExceptC(\"omniscient\")</code> should return <code>false</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7eb0",
      "challengeType": 5,
      "releasedOn": "June 8, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function IBeforeExceptC (word) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "IBAN",
      "description": [
        "The  <a href=\"https://en.wikipedia.org/wiki/International_Bank_Account_Number\">International Bank Account Number (IBAN)</a>  is an internationally agreed means of identifying bank accounts across national borders with a reduced risk of propagating <a href=\"https://en.wikipedia.org/wiki/Transcription_error\">transcription errors</a>.",
        "The IBAN consists of up to 34 alphanumeric characters:",
        "<ul>",
        "<li>first the two-letter ISO 3166-1 alpha-2 country code</li>",
        "<li>then two check digits, and</li>",
        "<li>finally a country-specific Basic Bank Account Number (BBAN).</li>",
        "</ul>",
        "The check digits enable a sanity check of the bank account number to confirm its integrity even before submitting a transaction.",
        "Write a function that takes IBAN string as parameter. If it is valid return true. Otherwise, return false."
      ],
      "solutions": [
        "function isValid (iban) {\n  var ibanLen = {\n  \tNO:15, BE:16, DK:18, FI:18, FO:18, GL:18, NL:18, MK:19,\n  \tSI:19, AT:20, BA:20, EE:20, KZ:20, LT:20, LU:20, CR:21,\n  \tCH:21, HR:21, LI:21, LV:21, BG:22, BH:22, DE:22, GB:22,\n  \tGE:22, IE:22, ME:22, RS:22, AE:23, GI:23, IL:23, AD:24,\n  \tCZ:24, ES:24, MD:24, PK:24, RO:24, SA:24, SE:24, SK:24,\n  \tVG:24, TN:24, PT:25, IS:26, TR:26, FR:27, GR:27, IT:27,\n  \tMC:27, MR:27, SM:27, AL:28, AZ:28, CY:28, DO:28, GT:28,\n  \tHU:28, LB:28, PL:28, BR:29, PS:29, KW:30, MU:30, MT:31\n  }\n\tiban = iban.replace(/\\s/g, '')\n\tif (!iban.match(/^[\\dA-Z]+$/)) return false\n\tvar len = iban.length\n\tif (len != ibanLen[iban.substr(0,2)]) return false\n\tiban = iban.substr(4) + iban.substr(0,4)\n\tfor (var s='', i=0; i<len; i+=1) s+=parseInt(iban.charAt(i),36)\n\tfor (var m=s.substr(0,15)%97, s=s.substr(15); s; s=s.substr(13)) m=(m+s.substr(0,13))%97\n\treturn m == 1\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>isValid</code> should be a function.'",
          "testString":
            "assert(typeof isValid=='function','<code>isValid</code> should be a function.');"
        },
        {
          "text":
            "'<code>isValid(\"'+tests[0]+'\")</code> should return a boolean.'",
          "testString":
            "assert(typeof isValid(tests[0])=='boolean','<code>isValid(\"'+tests[0]+'\")</code> should return a boolean.');"
        },
        {
          "text":
            "'<code>isValid(\"'+tests[0]+'\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isValid(tests[0]),true,'<code>isValid(\"'+tests[0]+'\")</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isValid(\"'+tests[1]+'\")</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isValid(tests[1]),false,'<code>isValid(\"'+tests[1]+'\")</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>isValid(\"'+tests[2]+'\")</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isValid(tests[2]),false,'<code>isValid(\"'+tests[2]+'\")</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>isValid(\"'+tests[3]+'\")</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isValid(tests[3]),false,'<code>isValid(\"'+tests[3]+'\")</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>isValid(\"'+tests[4]+'\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isValid(tests[4]),true,'<code>isValid(\"'+tests[4]+'\")</code> should return <code>true</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7eaf",
      "challengeType": 5,
      "releasedOn": "June 8, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function isValid (iban) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "let tests=[",
            "'GB82 WEST 1234 5698 7654 32',",
            "'GB82 WEST 1.34 5698 7654 32',",
            "'GB82 WEST 1234 5698 7654 325',",
            "'GB82 TEST 1234 5698 7654 32',",
            "'SA03 8000 0000 6080 1016 7519'",
            "]"
          ]
        }
      }
    },
    {
      "title": "Identity matrix",
      "description": [
        "An <i>identity matrix</i> is a square matrix of size \\( n \\times n \\),",
        "where the diagonal elements are all <b>1</b>s (ones),",
        "and all the other elements are all <b>0</b>s (zeroes).",
        "\\begin{bmatrix} 1 & 0 & 0 \\cr 0 & 1 & 0 \\cr 0 & 0 & 1 \\cr \\end{bmatrix}",
        "Write a function that takes a number 'n' as a parameter and returns the identity matrix of order n x n."
      ],
      "solutions": [
        "function idMatrix (n) {\n\treturn Array.apply(null, new Array(n)).map(function (x, i, xs) {\n\t\treturn xs.map(function (_, k) {\n\t\t\treturn i === k ? 1 : 0;\n\t\t})\n\t});\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>idMatrix</code> should be a function.'",
          "testString":
            "assert(typeof idMatrix=='function','<code>idMatrix</code> should be a function.');"
        },
        {
          "text": "'<code>idMatrix(1)</code> should return an array.'",
          "testString":
            "assert(Array.isArray(idMatrix(1)),'<code>idMatrix(1)</code> should return an array.');"
        },
        {
          "text":
            "'<code>idMatrix(1)</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(idMatrix(1),results[0],'<code>idMatrix(1)</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>idMatrix(2)</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(idMatrix(2),results[1],'<code>idMatrix(2)</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>idMatrix(3)</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(idMatrix(3),results[2],'<code>idMatrix(3)</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>idMatrix(4)</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(idMatrix(4),results[3],'<code>idMatrix(4)</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7eb1",
      "challengeType": 5,
      "releasedOn": "June 8, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function idMatrix (n) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "let results=[[ [ 1 ] ],",
            "[ [ 1, 0 ], [ 0, 1 ] ],",
            "[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ],",
            "[ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ]]"
          ]
        }
      }
    },
    {
      "title": "Iterated digits squaring",
      "description": [
        "If you add the square of the digits of a Natural number (an integer bigger than zero), you always end with either 1 or 89:",
        "<pre>15 -> 26 -> 40 -> 16 -> 37 -> 58 -> 89",
        "7 -> 49 -> 97 -> 130 -> 10 -> 1</pre>",
        "Write a function that takes a number as a parameter and returns 1 or 89 after performing the mentioned process."
      ],
      "solutions": [
        "function iteratedSquare (n) {\n\tvar total;\n\twhile (n != 89 && n != 1) {\n\t\ttotal = 0;\n\t\twhile (n > 0) {\n\t\t\ttotal += Math.pow(n % 10, 2);\n\t\t\tn = Math.floor(n/10);\n\t\t}\n\t\tn = total;\n\t}\n\treturn n;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>iteratedSquare</code> should be a function.'",
          "testString":
            "assert(typeof iteratedSquare=='function','<code>iteratedSquare</code> should be a function.');"
        },
        {
          "text": "'<code>iteratedSquare(4)</code> should return a number.'",
          "testString":
            "assert(typeof iteratedSquare(4)=='number','<code>iteratedSquare(4)</code> should return a number.');"
        },
        {
          "text":
            "'<code>iteratedSquare(4)</code> should return <code>89</code>.'",
          "testString":
            "assert.equal(iteratedSquare(4),89,'<code>iteratedSquare(4)</code> should return <code>89</code>.');"
        },
        {
          "text":
            "'<code>iteratedSquare(7)</code> should return <code>1</code>.'",
          "testString":
            "assert.equal(iteratedSquare(7),1,'<code>iteratedSquare(7)</code> should return <code>1</code>.');"
        },
        {
          "text":
            "'<code>iteratedSquare(15)</code> should return <code>89</code>.'",
          "testString":
            "assert.equal(iteratedSquare(15),89,'<code>iteratedSquare(15)</code> should return <code>89</code>.');"
        },
        {
          "text":
            "'<code>iteratedSquare(20)</code> should return <code>89</code>.'",
          "testString":
            "assert.equal(iteratedSquare(20),89,'<code>iteratedSquare(20)</code> should return <code>89</code>.');"
        },
        {
          "text":
            "'<code>iteratedSquare(70)</code> should return <code>1</code>.'",
          "testString":
            "assert.equal(iteratedSquare(70),1,'<code>iteratedSquare(70)</code> should return <code>1</code>.');"
        },
        {
          "text":
            "'<code>iteratedSquare(100)</code> should return <code>1</code>.'",
          "testString":
            "assert.equal(iteratedSquare(100),1,'<code>iteratedSquare(100)</code> should return <code>1</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7ec1",
      "challengeType": 5,
      "releasedOn": "June 8, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function iteratedSquare (n) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Jaro distance",
      "description": [
        "The Jaro distance is a measure of similarity between two strings. The higher the Jaro distance for two strings is, the more similar the strings are. The score is normalized such that  <b>0</b>  equates to no similarity and  <b>1</b>  is an exact match. Definition The Jaro distance  \\( d_j \\)  of two given strings  \\(s_1\\)  and  \\(s_2\\) is",
        "\\begin{align}d_j = \\begin{cases}0&amp;  & \\text{if }m=0 \\\\\\\\{\\frac {1}{3}}\\left({\\frac {m}{|s_{1}|}}+{\\frac {m}{|s_{2}|}}+{\\frac {m-t}{m}}\\right)&amp; & \\text{otherwise}\\end{cases}\\end{align}",
        "  Where: <ul><li>\\(m\\)   is the number of <i>matching characters</i>;</li><li> \\(t\\)   is half the number of <i>transpositions</i>.</li></uL>",
        "Two characters from  \\(s_1\\)   and  \\(s_2\\)   respectively, are considered <i>matching</i> only if they are the same and not farther than  \\(\\left\\lfloor\\frac{\\max(|s_1|,|s_2|)}{2}\\right\\rfloor-1\\).",
        "Each character of  \\(s_1\\)   is compared with all its matching characters in  \\(s_2\\) . The number of matching (but different sequence order) characters divided by 2 defines the number of <i>transpositions</i>.",
        "<b>Example</b>",
        "Given the strings  \\(s_1\\)   <i>DWAYNE</i>  and  \\(s_2\\)   <i>DUANE</i>  we find:",
        "<ul><li>\\(m = 4\\)</li><li>\\(|s_1| = 6\\) </li><li>\\(|s_2| = 5\\) </li><li>\\(t = 0\\) </li></ul>",
        "We find a Jaro score of: \\(d_j = \\frac{1}{3}\\left(\\frac{4}{6} + \\frac{4}{5} + \\frac{4-0}{4}\\right) = 0.822\\).",
        "Write a function a that takes two strings as parameters and returns the associated Jaro distance."
      ],
      "solutions": [
        "function jaro (s, t) {\n  var s_len = s.length;\n  var t_len = t.length;\n\n  if (s_len == 0 && t_len == 0) return 1;\n\n  var match_distance = Math.max(s_len, t_len) / 2 - 1;\n\n  var s_matches = new Array(s_len);\n  var t_matches = new Array(t_len);\n\n  var matches = 0;\n  var transpositions = 0;\n\n  for (var i = 0; i < s_len; i++) {\n    var start = Math.max(0, i - match_distance);\n    var end = Math.min(i + match_distance + 1, t_len);\n\n    for (var j = start; j < end; j++) {\n      if (t_matches[j]) continue;\n      if (s.charAt(i) != t.charAt(j)) continue;\n      s_matches[i] = true;\n      t_matches[j] = true;\n      matches++;\n      break;\n    }\n  }\n\n  if (matches == 0) return 0;\n\n  var k = 0;\n  for (var i = 0; i < s_len; i++) {\n    if (!s_matches[i]) continue;\n    while (!t_matches[k]) k++;\n    if (s.charAt(i) != t.charAt(k)) transpositions++;\n    k++;\n  }\n\n  return ((matches / s_len) +\n    (matches / t_len) +\n    ((matches - transpositions / 2.0) / matches)) / 3.0;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>jaro</code> should be a function.'",
          "testString":
            "assert(typeof jaro=='function','<code>jaro</code> should be a function.');"
        },
        {
          "text":
            "'<code>jaro(\"'+tests[0][0]+'\",\"'+tests[0][1]+'\")</code> should return a number.'",
          "testString":
            "assert(typeof jaro(tests[0][0],tests[0][1])=='number','<code>jaro()</code> should return a number.');"
        },
        {
          "text":
            "'<code>jaro(\"'+tests[0][0]+'\",\"'+tests[0][1]+'\")</code> should return <code>'+results[0]+'</code>.'",
          "testString":
            "assert.equal(jaro(tests[0][0],tests[0][1]),results[0],'<code>jaro(\"'+tests[0][0]+'\",\"'+tests[0][1]+'\")</code> should return <code>'+results[0]+'</code>.');"
        },
        {
          "text":
            "'<code>jaro(\"'+tests[1][0]+'\",\"'+tests[1][1]+'\")</code> should return <code>'+results[1]+'</code>.'",
          "testString":
            "assert.equal(jaro(tests[1][0],tests[1][1]),results[1],'<code>jaro(\"'+tests[1][0]+'\",\"'+tests[1][1]+'\")</code> should return <code>'+results[1]+'</code>.');"
        },
        {
          "text":
            "'<code>jaro(\"'+tests[2][0]+'\",\"'+tests[2][1]+'\")</code> should return <code>'+results[2]+'</code>.'",
          "testString":
            "assert.equal(jaro(tests[2][0],tests[2][1]),results[2],'<code>jaro(\"'+tests[2][0]+'\",\"'+tests[2][1]+'\")</code> should return <code>'+results[2]+'</code>.');"
        },
        {
          "text":
            "'<code>jaro(\"'+tests[3][0]+'\",\"'+tests[3][1]+'\")</code> should return <code>'+results[3]+'</code>.'",
          "testString":
            "assert.equal(jaro(tests[3][0],tests[3][1]),results[3],'<code>jaro(\"'+tests[3][0]+'\",\"'+tests[3][1]+'\")</code> should return <code>'+results[3]+'</code>.');"
        },
        {
          "text":
            "'<code>jaro(\"'+tests[4][0]+'\",\"'+tests[4][1]+'\")</code> should return <code>'+results[4]+'</code>.'",
          "testString":
            "assert.equal(jaro(tests[4][0],tests[4][1]),results[4],'<code>jaro(\"'+tests[4][0]+'\",\"'+tests[4][1]+'\")</code> should return <code>'+results[4]+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7ec2",
      "challengeType": 5,
      "releasedOn": "June 9, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function jaro (s, t) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "let tests=[",
            "[\"MARTHA\", \"MARHTA\"],",
            "[\"DIXON\", \"DICKSONX\"],",
            "[\"JELLYFISH\", \"SMELLYFISH\"],",
            "[\"HELLOS\", \"CHELLO\"],",
            "[\"ABCD\", \"BCDA\"]",
            "]",
            "let results=[",
            "0.9444444444444445,",
            "0.7666666666666666,",
            "0.8962962962962964,",
            "0.888888888888889,",
            "0.8333333333333334",
            "]"
          ]
        }
      }
    },
    {
      "title": "JortSort",
      "description": [
        "jortSort is a sorting toolset that makes the user do the work and guarantees efficiency because you don't have to sort ever again. It was originally presented by Jenn \"Moneydollars\" Schiffer at the prestigious <a href=\"https://www.youtube.com/watch?v=pj4U_W0OFoE\">JSConf</a>.",
        "jortSort is a function that takes a single array of comparable objects as its argument. It then sorts the array in ascending order and compares the sorted array to the originally provided array. If the arrays match (i.e. the original array was already sorted), the function returns true. If the arrays do not match (i.e. the original array was not sorted), the function returns false."
      ],
      "solutions": [
        "function jortsort (array) {\n  // sort the array\n  var originalArray = array.slice(0);\n  array.sort( function(a,b){return a - b} );\n\n  // compare to see if it was originally sorted\n  for (var i = 0; i < originalArray.length; ++i) {\n    if (originalArray[i] !== array[i]) return false;\n  }\n\n  return true;\n};\n"
      ],
      "tests": [
        {
          "text": "'<code>jortsort</code> should be a function.'",
          "testString":
            "assert(typeof jortsort=='function','<code>jortsort</code> should be a function.');"
        },
        {
          "text":
            "'<code>jortsort('+JSON.stringify(tests[0])+')</code> should return a boolean.'",
          "testString":
            "assert(typeof jortsort(tests[0].slice())=='boolean','<code>jortsort('+JSON.stringify(tests[0])+')</code> should return a boolean.');"
        },
        {
          "text":
            "'<code>jortsort('+JSON.stringify(tests[0])+')</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(jortsort(tests[0].slice()),true,'<code>jortsort('+JSON.stringify(tests[0])+')</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>jortsort('+JSON.stringify(tests[1])+')</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(jortsort(tests[1].slice()),false,'<code>jortsort('+JSON.stringify(tests[1])+')</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>jortsort('+JSON.stringify(tests[2])+')</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(jortsort(tests[2].slice()),false,'<code>jortsort('+JSON.stringify(tests[2])+')</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>jortsort('+JSON.stringify(tests[3])+')</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(jortsort(tests[3].slice()),true,'<code>jortsort('+JSON.stringify(tests[3])+')</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>jortsort('+JSON.stringify(tests[4])+')</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(jortsort(tests[4].slice()),false,'<code>jortsort('+JSON.stringify(tests[4])+')</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>jortsort('+JSON.stringify(tests[5])+')</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(jortsort(tests[5].slice()),true,'<code>jortsort('+JSON.stringify(tests[5])+')</code> should return <code>true</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7ec4",
      "challengeType": 5,
      "releasedOn": "June 9, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function jortsort (array) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "let tests=[[1,2,3,4,5],",
            "[1,2,13,4,5],",
            "[12,4,51,2,4],",
            "[1,2],",
            "[5,4,3,2,1],",
            "[1,1,1,1,1]]"
          ]
        }
      }
    },
    {
      "title": "Josephus problem",
      "description": [
        "<a href=\"https://en.wikipedia.org/wiki/Josephus problem\">Josephus problem</a> is a math puzzle with a grim description: $n$ prisoners are standing on a circle, sequentially numbered from $0$ to $n-1$.",
        "An executioner walks along the circle, starting from prisoner $0$, removing every $k$-th prisoner and killing him.",
        "As the process goes on, the circle becomes smaller and smaller, until only one prisoner remains, who is then freed.",
        "For example, if there are $n=5$ prisoners and $k=2$, the order the prisoners are killed in (let's call it the \"killing sequence\") will be 1, 3, 0, and 4, and the survivor will be #2.",
        "Given any  <big>$n, k > 0$</big>,  find out which prisoner will be the final survivor.",
        "In one such incident, there were 41 prisoners and every 3<sup>rd</sup> prisoner was being killed  (<big>$k=3$</big>).",
        "Among them was a clever chap name Josephus who worked out the problem, stood at the surviving position, and lived on to tell the tale.",
        "Which number was he?",
        "Write a function that takes the initial number of prisoners and 'k' as parameter and returns the number of the prisoner that survives."
      ],
      "solutions": [
        "function josephus (init, kill) {\n  var Josephus = {\n    init: function(n) {\n      this.head = {};\n      var current = this.head;\n      for (var i = 0; i < n - 1; i++) {\n        current.label = i + 1;\n        current.next = {\n          prev: current\n        };\n        current = current.next;\n      }\n      current.label = n;\n      current.next = this.head;\n      this.head.prev = current;\n      return this;\n    },\n    kill: function(spacing) {\n      var current = this.head;\n      while (current.next !== current) {\n        for (var i = 0; i < spacing - 1; i++) {\n          current = current.next;\n        }\n        current.prev.next = current.next;\n        current.next.prev = current.prev;\n        current = current.next;\n      }\n      return current.label;\n    }\n  }\n\n  return Josephus.init(init).kill(kill)\n}\n\n"
      ],
      "tests": [
        {
          "text": "'<code>josephus</code> should be a function.'",
          "testString":
            "assert(typeof josephus=='function','<code>josephus</code> should be a function.');"
        },
        {
          "text": "'<code>josephus(30,3)</code> should return a number.'",
          "testString":
            "assert(typeof josephus(30,3)=='number','<code>josephus(30,3)</code> should return a number.');"
        },
        {
          "text":
            "'<code>josephus(30,3)</code> should return <code>29</code>.'",
          "testString":
            "assert.equal(josephus(30,3),29,'<code>josephus(30,3)</code> should return <code>29</code>.');"
        },
        {
          "text": "'<code>josephus(30,5)</code> should return <code>3</code>.'",
          "testString":
            "assert.equal(josephus(30,5),3,'<code>josephus(30,5)</code> should return <code>3</code>.');"
        },
        {
          "text": "'<code>josephus(20,2)</code> should return <code>9</code>.'",
          "testString":
            "assert.equal(josephus(20,2),9,'<code>josephus(20,2)</code> should return <code>9</code>.');"
        },
        {
          "text": "'<code>josephus(17,6)</code> should return <code>2</code>.'",
          "testString":
            "assert.equal(josephus(17,6),2,'<code>josephus(17,6)</code> should return <code>2</code>.');"
        },
        {
          "text": "'<code>josephus(29,4)</code> should return <code>2</code>.'",
          "testString":
            "assert.equal(josephus(29,4),2,'<code>josephus(29,4)</code> should return <code>2</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7ec5",
      "challengeType": 5,
      "releasedOn": "June 9, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function josephus (init, kill) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "K-d tree",
      "description": [
        "A k-d tree (short for <i>k</i>-dimensional tree) is a space-partitioning data structure for organizing points in a k-dimensional space. k-d trees are a useful data structure for several applications, such as searches involving a multidimensional search key (e.g. range searches and nearest neighbor searches). k-d trees are a special case of binary space partitioning trees.",
        "k-d trees are not suitable, however, for efficiently finding the nearest neighbor in high dimensional spaces. As a general rule, if the dimensionality is <i>k</i>, the number of points in the data, <i>N</i>, should be <i>N</i> ≫ 2<sup><i>k</i></sup>.",
        "Otherwise, when k-d trees are used with high-dimensional data, most of the points in the tree will be evaluated and the efficiency is no better than exhaustive search, and other methods such as approximate nearest-neighbor are used instead.",
        "Write a function to perform a nearest neighbour search using k-d tree. The function takes two parameters: an array of k-dimensional points, and a single k-dimensional point whose nearest neighbour should be returned by the function. A k-dimensional point will be given as an array of k elements."
      ],
      "solutions": [
        "function kdNN (fpoints, fpoint) {\n  function Node(obj, dimension, parent) {\n    this.obj = obj;\n    this.left = null;\n    this.right = null;\n    this.parent = parent;\n    this.dimension = dimension;\n  }\n\n  function kdTree(points, metric, dimensions) {\n\n    var self = this;\n\n    function buildTree(points, depth, parent) {\n      var dim = depth % dimensions.length,\n      median,\n      node;\n\n      if (points.length === 0) {\n        return null;\n      }\n      if (points.length === 1) {\n        return new Node(points[0], dim, parent);\n      }\n\n      points.sort(function (a, b) {\n        return a[dimensions[dim]] - b[dimensions[dim]];\n      });\n\n      median = Math.floor(points.length / 2);\n      node = new Node(points[median], dim, parent);\n      node.left = buildTree(points.slice(0, median), depth + 1, node);\n      node.right = buildTree(points.slice(median + 1), depth + 1, node);\n\n      return node;\n    }\n\n    this.root = buildTree(points, 0, null);\n\n    this.insert = function (point) {\n      function innerSearch(node, parent) {\n\n        if (node === null) {\n          return parent;\n        }\n\n        var dimension = dimensions[node.dimension];\n        if (point[dimension] < node.obj[dimension]) {\n          return innerSearch(node.left, node);\n        } else {\n          return innerSearch(node.right, node);\n        }\n      }\n\n      var insertPosition = innerSearch(this.root, null),\n      newNode,\n      dimension;\n\n      if (insertPosition === null) {\n        this.root = new Node(point, 0, null);\n        return;\n      }\n\n      newNode = new Node(point, (insertPosition.dimension + 1) % dimensions.length, insertPosition);\n      dimension = dimensions[insertPosition.dimension];\n\n      if (point[dimension] < insertPosition.obj[dimension]) {\n        insertPosition.left = newNode;\n      } else {\n        insertPosition.right = newNode;\n      }\n    };\n\n    this.nearest = function (point, maxNodes, maxDistance) {\n      var i,\n      result,\n      bestNodes;\n\n      bestNodes = new BinaryHeap(\n        function (e) { return -e[1]; }\n      );\n\n      function nearestSearch(node) {\n        var bestChild,\n        dimension = dimensions[node.dimension],\n        ownDistance = metric(point, node.obj),\n        linearPoint = {},\n        linearDistance,\n        otherChild,\n        i;\n\n        function saveNode(node, distance) {\n          bestNodes.push([node, distance]);\n          if (bestNodes.size() > maxNodes) {\n            bestNodes.pop();\n          }\n        }\n\n        for (i = 0; i < dimensions.length; i += 1) {\n          if (i === node.dimension) {\n            linearPoint[dimensions[i]] = point[dimensions[i]];\n          } else {\n            linearPoint[dimensions[i]] = node.obj[dimensions[i]];\n          }\n        }\n\n        linearDistance = metric(linearPoint, node.obj);\n\n        if (node.right === null && node.left === null) {\n          if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\n            saveNode(node, ownDistance);\n          }\n          return;\n        }\n\n        if (node.right === null) {\n          bestChild = node.left;\n        } else if (node.left === null) {\n          bestChild = node.right;\n        } else {\n          if (point[dimension] < node.obj[dimension]) {\n            bestChild = node.left;\n          } else {\n            bestChild = node.right;\n          }\n        }\n\n        nearestSearch(bestChild);\n\n        if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\n          saveNode(node, ownDistance);\n        }\n\n        if (bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek()[1]) {\n          if (bestChild === node.left) {\n            otherChild = node.right;\n          } else {\n            otherChild = node.left;\n          }\n          if (otherChild !== null) {\n            nearestSearch(otherChild);\n          }\n        }\n      }\n\n      if (maxDistance) {\n        for (i = 0; i < maxNodes; i += 1) {\n          bestNodes.push([null, maxDistance]);\n        }\n      }\n\n      if(self.root)\n      nearestSearch(self.root);\n\n      result = [];\n\n      for (i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1) {\n        if (bestNodes.content[i][0]) {\n          result.push([bestNodes.content[i][0].obj, bestNodes.content[i][1]]);\n        }\n      }\n      return result;\n    };\n  }\n\n  function BinaryHeap(scoreFunction){\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  BinaryHeap.prototype = {\n    push: function(element) {\n      // Add the new element to the end of the array.\n      this.content.push(element);\n      // Allow it to bubble up.\n      this.bubbleUp(this.content.length - 1);\n    },\n\n    pop: function() {\n      // Store the first element so we can return it later.\n      var result = this.content[0];\n      // Get the element at the end of the array.\n      var end = this.content.pop();\n      // If there are any elements left, put the end element at the\n      // start, and let it sink down.\n      if (this.content.length > 0) {\n        this.content[0] = end;\n        this.sinkDown(0);\n      }\n      return result;\n    },\n\n    peek: function() {\n      return this.content[0];\n    },\n\n    size: function() {\n      return this.content.length;\n    },\n\n    bubbleUp: function(n) {\n      // Fetch the element that has to be moved.\n      var element = this.content[n];\n      // When at 0, an element can not go up any further.\n      while (n > 0) {\n        // Compute the parent element's index, and fetch it.\n        var parentN = Math.floor((n + 1) / 2) - 1,\n        parent = this.content[parentN];\n        // Swap the elements if the parent is greater.\n        if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n          this.content[parentN] = element;\n          this.content[n] = parent;\n          // Update 'n' to continue at the new position.\n          n = parentN;\n        }\n        // Found a parent that is less, no need to move it further.\n        else {\n          break;\n        }\n      }\n    },\n\n    sinkDown: function(n) {\n      // Look up the target element and its score.\n      var length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n\n      while(true) {\n        // Compute the indices of the child elements.\n        var child2N = (n + 1) * 2, child1N = child2N - 1;\n        // This is used to store the new position of the element,\n        // if any.\n        var swap = null;\n        // If the first child exists (is inside the array)...\n        if (child1N < length) {\n          // Look it up and compute its score.\n          var child1 = this.content[child1N],\n          child1Score = this.scoreFunction(child1);\n          // If the score is less than our element's, we need to swap.\n          if (child1Score < elemScore)\n          swap = child1N;\n        }\n        // Do the same checks for the other child.\n        if (child2N < length) {\n          var child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n          if (child2Score < (swap == null ? elemScore : child1Score)){\n            swap = child2N;\n          }\n        }\n\n        // If the element needs to be moved, swap it, and continue.\n        if (swap != null) {\n          this.content[n] = this.content[swap];\n          this.content[swap] = element;\n          n = swap;\n        }\n        // Otherwise, we are done.\n        else {\n          break;\n        }\n      }\n    }\n  };\n\n  var dims=[]\n\n  for(var i=0;i<fpoint.length;i++) dims.push(i)\n\n  var tree=new kdTree(fpoints,function (e1,e2) {\n    var d=0;\n    var e3=e1;\n    if(!Array.isArray(e1)){\n      e3=[]\n      for(var key in e1)\n        e3.push(e1[key])\n\n      e1=e3\n    }\n    e1.forEach(function(e,i){\n      var sqd=(e1[i]-e2[i]);\n      d+=sqd*sqd;\n    })\n    return d;\n  },dims)\n\n  return tree.nearest(fpoint, 1, 1000)[0][0];\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>kdNN</code> should be a function.'",
          "testString":
            "assert(typeof kdNN=='function','<code>kdNN</code> should be a function.');"
        },
        {
          "text":
            "'<code>kdNN('+JSON.stringify(points[0])+','+JSON.stringify(point[0])+')</code> should return an array.'",
          "testString":
            "assert(Array.isArray(kdNN(points[0],point[0])),'<code>kdNN('+JSON.stringify(points[0])+','+JSON.stringify(point[0])+')</code> should return an array.');"
        },
        {
          "text":
            "'<code>kdNN('+JSON.stringify(points[0])+','+JSON.stringify(point[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(kdNN(points[0],point[0]),results[0],'<code>kdNN('+JSON.stringify(points[0])+','+JSON.stringify(point[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>kdNN('+JSON.stringify(points[0])+','+JSON.stringify(point[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(kdNN(points[0],point[1]),results[1],'<code>kdNN('+JSON.stringify(points[0])+','+JSON.stringify(point[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>kdNN('+JSON.stringify(points[0])+','+JSON.stringify(point[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(kdNN(points[0],point[2]),results[2],'<code>kdNN('+JSON.stringify(points[0])+','+JSON.stringify(point[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>kdNN('+JSON.stringify(points[1])+','+JSON.stringify(point[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(kdNN(points[1],point[3]),results[3],'<code>kdNN('+JSON.stringify(points[1])+','+JSON.stringify(point[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>kdNN('+JSON.stringify(points[1])+','+JSON.stringify(point[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(kdNN(points[1],point[4]),results[4],'<code>kdNN('+JSON.stringify(points[1])+','+JSON.stringify(point[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        },
        {
          "text":
            "'<code>kdNN('+JSON.stringify(points[1])+','+JSON.stringify(point[5])+')</code> should return <code>'+JSON.stringify(results[5])+'</code>.'",
          "testString":
            "assert.deepEqual(kdNN(points[1],point[5]),results[5],'<code>kdNN('+JSON.stringify(points[1])+','+JSON.stringify(point[5])+')</code> should return <code>'+JSON.stringify(results[5])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7ecb",
      "challengeType": 5,
      "releasedOn": "June 16, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function kdNN (fpoints, fpoint) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var points=[[[2, 3], [5, 4], [9, 6], [4, 7], [8, 1], [7, 2]],",
            "[[2,3,1],[9,4,5],[4,6,7],[1,2,5],[7,8,9],[3,6,1]]]",
            "var point=[[9,2],[7,1],[3,2],[1,2,3],[4,5,6],[8,8,8]]",
            "var results=[[ 8, 1 ],",
            "[ 8, 1 ],",
            "[ 2, 3 ],",
            "[ 1, 2, 5 ],",
            "[ 4, 6, 7 ],",
            "[ 7, 8, 9 ]]"
          ]
        }
      }
    },
    {
      "title": "Kaprekar numbers",
      "description": [
        "A positive integer is a <a href=\"https://en.wikipedia.org/wiki/Kaprekar number\">Kaprekar number</a> if:",
        "<ul><li>It is 1</li><li>The decimal representation of its square may be split once into two parts consisting of positive integers which sum to the original number. </li></ul>",
        "Note that a split resulting in a part consisting purely of 0s is not valid, as 0 is not considered positive.Example Kaprekar numbers:",
        "<ul><li>$2223$ is a Kaprekar number, as $2223 * 2223 = 4941729$, $4941729$ may be split to $494$ and $1729$, and $494 + 1729 = 2223$.</li><li>The series of Kaprekar numbers is known as <a href=\"http://rosettacode.org/wiki/oeis:A006886\">A006886</a>, and begins as $1, 9, 45, 55, ...$.</li></ul>",
        "<ul><li>$$2223$$ is a Kaprekar number, as $2223 * 2223 = 4941729$, $4941729$ may be split to $494$ and $1729$, and $494 + 1729 = 2223$.</li><li>The series of Kaprekar numbers is known as <a href=\"http://rosettacode.org/wiki/oeis:A006886\">A006886</a>, and begins as $1, 9, 45, 55, ...$.</li></ul>",
        "Write a function that takes a number $n$, a base $bs$, and returns true if the number is a Kaprekar number for the given base. Otherwise, the function returns false."
      ],
      "solutions": [
        "function isKaprekar (n, bs) {\n\tif ( n < 1 ) return false\n\tif ( n == 1 ) return true\n\tfor (var a=n*n, b=0, s=1; a; s*=bs) {\n\t\tb += a%bs*s\n\t\ta = Math.floor(a/bs)\n\t\tif (b && a + b == n) return true\n\t}\n\treturn false\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>isKaprekar</code> should be a function.'",
          "testString":
            "assert(typeof isKaprekar=='function','<code>isKaprekar</code> should be a function.');"
        },
        {
          "text": "'<code>isKaprekar(1,10)</code> should return a boolean.'",
          "testString":
            "assert(typeof isKaprekar(1,10)=='boolean','<code>isKaprekar(1,10)</code> should return a boolean.');"
        },
        {
          "text":
            "'<code>isKaprekar(1,10)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isKaprekar(1,10),true,'<code>isKaprekar(1,10)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isKaprekar(9,10)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isKaprekar(9,10),true,'<code>isKaprekar(9,10)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isKaprekar(2223,10)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isKaprekar(2223,10),true,'<code>isKaprekar(2223,10)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isKaprekar(22823,10)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isKaprekar(22823,10),false,'<code>isKaprekar(22823,10)</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>isKaprekar(9,17)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isKaprekar(9,17),false,'<code>isKaprekar(9,17)</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>isKaprekar(225,17)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isKaprekar(225,17),true,'<code>isKaprekar(225,17)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isKaprekar(999,17)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isKaprekar(999,17),false,'<code>isKaprekar(999,17)</code> should return <code>false</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7eca",
      "challengeType": 5,
      "releasedOn": "June 16, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function isKaprekar (n, bs) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Knapsack problem/0-1",
      "description": [
        "Write a function that solves the knapsack problem that is as follows:",
        "You are given an array of objects representing items to be put in a knapsack. The objects have 3 attributes: name, weight, and value. The items need to be selected so that the total weight does not exceed the maximum weight and the value is maximized.",
        "The function is given the array of objects and the maximum weight as parameters. It should return the maximum total value possible."
      ],
      "solutions": [
        "function knapsack (items, maxweight) {\n  var _={\n    max:function(e){\n      var mx=e[0];\n      e.forEach(function(f){\n        if(mx<f)\n          mx=f;\n      })\n      return mx;\n    },\n    map:function(array,func){\n      return array.map(func)\n    },\n    isUndefined:function (a) {\n      if(a){\n        return false;\n      }\n      return true;\n    },\n    range:function(start,end,step) {\n      var a=[]\n      var f= f=(i,end)=>i<end\n      if(start>end)\n        f=(i,end)=>i>end\n\n      for(var i=start;f(i,end);i+=step)\n        a.push(i)\n      return a\n    }\n  }\n\n  var valuefn=(e)=>e.value\n  var weightfn=(e)=>e.weight\n  var _epsilon = 0.01;\n  var _p = _.max(_.map(items,valuefn));\n  var _k = _epsilon * _p / items.length;\n\n  var _memo = (function(){\n    var _mem = {};\n    var _key = function(i, w) {\n      return i + '::' + w;\n    };\n    return {\n      get: function(i, w) {\n        return _mem[_key(i,w)];\n      },\n      put: function(i, w, r) {\n        _mem[_key(i,w)]=r;\n        return r;\n      }\n    };\n  })();\n\n  var _m = function(i, w) {\n\n    i = Math.round(i);\n    w = Math.round(w);\n\n\n    if (i < 0 || w === 0) {\n      // empty base case\n      return {items: [], totalWeight: 0, totalValue: 0};\n    }\n\n    var mm = _memo.get(i,w);\n    if (!_.isUndefined(mm)) {\n      return mm;\n    }\n\n    var item = items[i];\n    if (weightfn(item) > w) {\n      //item does not fit, try the next item\n      return _memo.put(i, w, _m(i-1, w));\n    }\n    // this item could fit.\n    // are we better off excluding it?\n    var excluded = _m(i-1, w);\n    // or including it?\n    var included = _m(i-1, w - weightfn(item));\n    if (included.totalValue + Math.floor(valuefn(item)/_k) > excluded.totalValue) {\n      // better off including it\n      // make a copy of the list\n      var i1 = included.items.slice();\n      i1.push(item);\n      return _memo.put(i, w,\n        {items: i1,\n         totalWeight: included.totalWeight + weightfn(item),\n         totalValue: included.totalValue + Math.floor(valuefn(item)/_k)});\n    }\n    //better off excluding it\n    return _memo.put(i,w, excluded);\n  };\n  var scaled = _m(items.length - 1, maxweight);\n\n  var val=0;\n  scaled.items.forEach(function (e) {\n    val+=e.value\n  })\n  return val;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>knapsack</code> should be a function.'",
          "testString":
            "assert(typeof knapsack=='function','<code>knapsack</code> should be a function.');"
        },
        {
          "text":
            "'<code>knapsack('+JSON.stringify(tests[0])+',100)</code> should return a number.'",
          "testString":
            "assert(typeof knapsack(tests[0],100)=='number','<code>knapsack('+JSON.stringify(tests[0])+',100)</code> should return a number.');"
        },
        {
          "text":
            "'<code>knapsack('+JSON.stringify(tests[0])+',100)</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.equal(knapsack(tests[0],100),results[0],'<code>knapsack('+JSON.stringify(tests[0])+',100)</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>knapsack('+JSON.stringify(tests[0])+',200)</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.equal(knapsack(tests[0],200),results[1],'<code>knapsack('+JSON.stringify(tests[0])+',200)</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>knapsack('+JSON.stringify(tests[1])+',100)</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.equal(knapsack(tests[1],100),results[2],'<code>knapsack('+JSON.stringify(tests[1])+',100)</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>knapsack('+JSON.stringify(tests[1])+',200)</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.equal(knapsack(tests[1],200),results[3],'<code>knapsack('+JSON.stringify(tests[1])+',200)</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>knapsack('+JSON.stringify(tests[2])+',100)</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.equal(knapsack(tests[2],100),results[4],'<code>knapsack('+JSON.stringify(tests[2])+',100)</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        },
        {
          "text":
            "'<code>knapsack('+JSON.stringify(tests[2])+',200)</code> should return <code>'+JSON.stringify(results[5])+'</code>.')",
          "testString":
            "assert.equal(knapsack(tests[2],200),results[5],'<code>knapsack('+JSON.stringify(tests[2])+',200)</code> should return <code>'+JSON.stringify(results[5])+'</code>.');;"
        }
      ],
      "id": "5a23c84252665b21eecc7ed1",
      "challengeType": 5,
      "releasedOn": "June 16, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function knapsack (items, maxweight) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var tests =[",
            "[",
            "{name:\"map\", weight:9, value: 150},",
            "{name:\"compass\", weight:13, value: 35},",
            "{name:\"water\", weight:153, value: 200},",
            "{name:\"sandwich\", weight: 50, value: 160},",
            "{name:\"glucose\", weight:15, value: 60},",
            "{name:\"tin\", weight:68, value: 45},",
            "{name:\"banana\", weight:27, value: 60},",
            "{name:\"apple\", weight:39, value: 40}",
            "],",
            "[",
            "{name:\"cheese\", weight:23, value: 30},",
            "{name:\"beer\", weight:52, value: 10},",
            "{name:\"suntan cream\", weight:11, value: 70},",
            "{name:\"camera\", weight:32, value: 30},",
            "{name:\"T-shirt\", weight:24, value: 15},",
            "{name:\"trousers\", weight:48, value: 10},",
            "{name:\"umbrella\", weight:73, value: 40}",
            "],",
            "[",
            "{name:\"waterproof trousers\", weight:42, value: 70},",
            "{name:\"waterproof overclothes\", weight:43, value: 75},",
            "{name:\"note-case\", weight:22, value: 80},",
            "{name:\"sunglasses\", weight:7, value: 20},",
            "{name:\"towel\", weight:18, value: 12},",
            "{name:\"socks\", weight:4, value: 50},",
            "{name:\"book\", weight:30, value: 10}",
            "]",
            "];",
            "var results=[ 405, 510, 145, 185, 237, 317 ]"
          ]
        }
      }
    },
    {
      "title": "Knapsack problem/Bounded",
      "description": [
        "Write a function that solves the knapsack problem that is as follows:",
        "You are given an array of objects representing items to be put in a knapsack. The objects have 4 attributes: name, pieces (the number of the particular item), weight, and value. The items need to be selected so that the total weight does not exceed the maximum weight and the value is maximized.",
        "The function is given the array of objects and the maximum weight as parameters. It should return the maximum total value possible."
      ],
      "solutions": [
        "function findBestPack (data, maxweight) {\n  var m = [\n    [0]\n  ]; // maximum pack value found so far\n  var b = [\n    [0]\n  ]; // best combination found so far\n  var opts = [0]; // item index for 0 of item 0\n  var P = [1]; // item encoding for 0 of item 0\n  var choose = 0;\n  for (var j = 0; j < data.length; j++) {\n    opts[j + 1] = opts[j] + data[j].pieces; // item index for 0 of item j+1\n    P[j + 1] = P[j] * (1 + data[j].pieces); // item encoding for 0 of item j+1\n  }\n  for (var j = 0; j < opts[data.length]; j++) {\n    m[0][j + 1] = b[0][j + 1] = 0; // best values and combos for empty pack: nothing\n  }\n  for (var w = 1; w <= maxweight; w++) {\n    m[w] = [0];\n    b[w] = [0];\n    for (var j = 0; j < data.length; j++) {\n      var N = data[j].pieces; // how many of these can we have?\n      var base = opts[j]; // what is the item index for 0 of these?\n      for (var n = 1; n <= N; n++) {\n        var W = n * data[j].weight; // how much do these items weigh?\n        var s = w >= W ? 1 : 0; // can we carry this many?\n        var v = s * n * data[j].value; // how much are they worth?\n        var I = base + n; // what is the item number for this many?\n        var wN = w - s * W; // how much other stuff can we be carrying?\n        var C = n * P[j] + b[wN][base]; // encoded combination\n        m[w][I] = Math.max(m[w][I - 1], v + m[wN][base]); // best value\n        choose = b[w][I] = m[w][I] > m[w][I - 1] ? C : b[w][I - 1];\n      }\n    }\n  }\n\n  var best = [];\n  for (var j = data.length - 1; j >= 0; j--) {\n    best[j] = Math.floor(choose / P[j]);\n    choose -= best[j] * P[j];\n  }\n\n  var wgt = 0;\n  var val = 0;\n  for (var i = 0; i < best.length; i++) {\n    if (0 == best[i]) continue;\n    wgt += best[i] * data[i].weight;\n    val += best[i] * data[i].value;\n  }\n\n  return val;\n}\n\n"
      ],
      "tests": [
        {
          "text":
            "assert(typeof findBestPack == 'function', '<code>findBestPack</code> should be a function.'",
          "testString":
            "assert(typeof findBestPack == 'function', '<code>findBestPack</code> should be a function.');"
        },
        {
          "text":
            "'<code>findBestPack(' + JSON.stringify(items) + ',300)</code> should return a number.'",
          "testString":
            "assert(typeof findBestPack(items, 300) == 'number','<code>findBestPack(' + JSON.stringify(items) + ',300)</code> should return a number.');"
        },
        {
          "text":
            "'<code>findBestPack(' + JSON.stringify(items) + ',300)</code> should return <code>755</code>.'",
          "testString":
            "assert.equal(findBestPack(items, 300), 755,'<code>findBestPack(' + JSON.stringify(items) + ',300)</code> should return <code>755</code>.');"
        },
        {
          "text":
            "'<code>findBestPack(' + JSON.stringify(items) + ',400)</code> should return <code>875</code>.'",
          "testString":
            "assert.equal(findBestPack(items, 400), 875,'<code>findBestPack(' + JSON.stringify(items) + ',400)</code> should return <code>875</code>.');"
        },
        {
          "text":
            "'<code>findBestPack(' + JSON.stringify(items) + ',500)</code> should return <code>1015</code>.'",
          "testString":
            "assert.equal(findBestPack(items, 500), 1015,'<code>findBestPack(' + JSON.stringify(items) + ',500)</code> should return <code>1015</code>.');"
        },
        {
          "text":
            "'<code>findBestPack(' + JSON.stringify(items) + ',600)</code> should return <code>1120</code>.'",
          "testString":
            "assert.equal(findBestPack(items, 600), 1120,'<code>findBestPack(' + JSON.stringify(items) + ',600)</code> should return <code>1120</code>.');"
        },
        {
          "text":
            "'<code>findBestPack(' + JSON.stringify(items) + ',700)</code> should return <code>1225</code>.'",
          "testString":
            "assert.equal(findBestPack(items, 700), 1225,'<code>findBestPack(' + JSON.stringify(items) + ',700)</code> should return <code>1225</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7ed2",
      "challengeType": 5,
      "releasedOn": "June 16, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function findBestPack (data, maxweight) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var items = [",
            "{name: 'map',weight: 9,value: 150,pieces: 1},",
            "{name: 'compass',weight: 13,value: 35,pieces: 1},",
            "{name: 'water',weight: 153,value: 200,pieces: 2},",
            "{name: 'sandwich',weight: 50,value: 60,pieces: 2},",
            "{name: 'glucose',weight: 15,value: 60,pieces: 2},",
            "{name: 'tin',weight: 68,value: 45,pieces: 3},",
            "{name: 'banana',weight: 27,value: 60,pieces: 3},",
            "{name: 'apple',weight: 39,value: 40,pieces: 3},",
            "{name: 'cheese',weight: 23,value: 30,pieces: 1},",
            "{name: 'beer',weight: 52,value: 10,pieces: 3},",
            "{name: 'suntan, cream',weight: 11,value: 70,pieces: 1},",
            "{name: 'camera',weight: 32,value: 30,pieces: 1},",
            "{name: 'T-shirt',weight: 24,value: 15,pieces: 2}",
            "];"
          ]
        }
      }
    },
    {
      "title": "Knapsack problem/Continuous",
      "description": [
        "A thief burgles a butcher's shop, where he can select from some items.",
        "The thief knows the weights and prices of each items.  Because he has a knapsack with a limit on the maximum weight that it can carry, he wants to select the items such that he would have his profit maximized.  He may cut the items;  the item has a reduced price after cutting that is proportional to the original price by the ratio of masses.  That means:  half of an item has half the price of the original.",
        "Write a function that takes an array of objects representing the items available in the shop. Each object has 3 attributes: name, weight, and value. The function also takes the maximum weight as a parameter. The function should return the maximum value possible, and the total weight of the selected items should not exceed the maximum weight."
      ],
      "solutions": [
        "function knapContinuous (items, maxweight) {\n  function item_cmp(a,b)\n  {\n  \tvar ua = a.value / a.weight, ub = b.value / b.weight;\n  \treturn ua < ub ? -1 : ua > ub;\n  }\n\n  items.sort(item_cmp)\n\n  var n=items.length\n  var val=0,it;\n\tfor (it = n-1; it >=0 && maxweight > 0; it--){\n\t\tif (maxweight >= items[it].weight){\n      val+=items[it].value*items[it].weight\n\t\t}else{\n      val+=maxweight*items[it].value\n    }\n    maxweight -= items[it].weight;\n  }\n  return val;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>knapContinuous</code> should be a function.'",
          "testString":
            "assert(typeof knapContinuous=='function','<code>knapContinuous</code> should be a function.');"
        },
        {
          "text":
            "'<code>knapContinuous('+JSON.stringify(items)+',10)</code> should return a number.'",
          "testString":
            "assert(typeof knapContinuous(items,10)=='number','<code>knapContinuous('+JSON.stringify(items)+',10)</code> should return a number.');"
        },
        {
          "text":
            "'<code>knapContinuous('+JSON.stringify(items)+',10)</code> should return <code>789.5</code>.'",
          "testString":
            "assert.equal(knapContinuous(items,10),789.5,'<code>knapContinuous('+JSON.stringify(items)+',10)</code> should return <code>789.5</code>.');"
        },
        {
          "text":
            "'<code>knapContinuous('+JSON.stringify(items)+',12)</code> should return <code>890.5</code>.'",
          "testString":
            "assert.equal(knapContinuous(items,12),890.5,'<code>knapContinuous('+JSON.stringify(items)+',12)</code> should return <code>890.5</code>.');"
        },
        {
          "text":
            "'<code>knapContinuous('+JSON.stringify(items)+',15)</code> should return <code>1091.5</code>.'",
          "testString":
            "assert.equal(knapContinuous(items,15),1091.5,'<code>knapContinuous('+JSON.stringify(items)+',15)</code> should return <code>1091.5</code>.');"
        },
        {
          "text":
            "'<code>knapContinuous('+JSON.stringify(items)+',22)</code> should return <code>1715.5</code>.'",
          "testString":
            "assert.equal(knapContinuous(items,22),1715.5,'<code>knapContinuous('+JSON.stringify(items)+',22)</code> should return <code>1715.5</code>.');"
        },
        {
          "text":
            "'<code>knapContinuous('+JSON.stringify(items)+',24)</code> should return <code>1787.5</code>.'",
          "testString":
            "assert.equal(knapContinuous(items,24),1787.5,'<code>knapContinuous('+JSON.stringify(items)+',24)</code> should return <code>1787.5</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7ed3",
      "challengeType": 5,
      "releasedOn": "June 16, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function knapContinuous (items, maxweight) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var items = [",
            "\t{ \"weight\":3.8, \"value\":36, name:\"beef\" },",
            "\t{ \"weight\":5.4, \"value\":43, name:\"pork\" },",
            "\t{ \"weight\":3.6, \"value\":90, name:\"ham\" },",
            "\t{ \"weight\":2.4, \"value\":45, name:\"greaves\" },",
            "\t{ \"weight\":4.0, \"value\":30, name:\"flitch\" },",
            "\t{ \"weight\":2.5, \"value\":56, name:\"brawn\" },",
            "\t{ \"weight\":3.7, \"value\":67, name:\"welt\" },",
            "\t{ \"weight\":3.0, \"value\":95, name:\"salami\" },",
            "\t{ \"weight\":5.9, \"value\":98, name:\"sausage\" },",
            "];"
          ]
        }
      }
    },
    {
      "title": "Knapsack problem/Unbounded",
      "description": [
        "A traveler gets diverted and has to make an unscheduled stop in what turns out to be Shangri La.  Opting to leave, he is allowed to take as much as he likes of the items available there, so long as it will fit in his knapsack, and he can carry it.",
        "He knows that he can carry no more than  a particalar value of maximum weight in total;  and that the capacity of his knapsack has a limited volume.",
        "Looking just above the bar codes on the items he finds their weights and volumes.  He digs out his recent copy of a  financial paper and gets the value of each item.",
        "He can only take whole units of any item, but there is much more of any item than he could ever carry.",
        "Write a function that takes an array of objects, maximum weight, and maximum volume as parameters. Each object has 4 attributes: name, value, weight, and volume. The function should return the maximum value of items the traveller can take with him."
      ],
      "solutions": [
        "function knapsackUnbounded (items, maxweight, maxvolume) {\n  var n=items.length;\n  var best_value=0;\n  var count=new Array(n)\n  var best=new Array(n)\n  function recurseKnapsack(i, value, weight, volume) {\n    var j, m1, m2, m;\n    if (i == n) {\n        if (value > best_value) {\n            best_value = value;\n            for (j = 0; j < n; j++) {\n                best[j] = count[j];\n            }\n        }\n        return;\n    }\n    m1 = Math.floor(weight / items[i].weight);\n    m2 = Math.floor(volume / items[i].volume);\n    m = m1 < m2 ? m1 : m2;\n    for (count[i] = m; count[i] >= 0; count[i]--) {\n        recurseKnapsack(\n            i + 1,\n            value + count[i] * items[i].value,\n            weight - count[i] * items[i].weight,\n            volume - count[i] * items[i].volume\n        );\n    }\n  }\n\n  recurseKnapsack(0, 0, maxweight, maxvolume);\n  return best_value;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>knapsackUnbounded</code> should be a function.'",
          "testString":
            "assert(typeof knapsackUnbounded=='function','<code>knapsackUnbounded</code> should be a function.');"
        },
        {
          "text":
            "'<code>knapsackUnbounded('+JSON.stringify(items)+','+weights[0]+','+volumes[0]+')</code> should return a number.'",
          "testString":
            "assert(typeof knapsackUnbounded(items,weights[0],volumes[0])=='number','<code>knapsackUnbounded('+JSON.stringify(items)+','+weights[0]+','+volumes[0]+')</code> should return a number.');"
        },
        {
          "text":
            "'<code>knapsackUnbounded('+JSON.stringify(items)+','+weights[0]+','+volumes[0]+')</code> should return <code>'+results[0]+'</code>.'",
          "testString":
            "assert.equal(knapsackUnbounded(items,weights[0],volumes[0]),results[0],'<code>knapsackUnbounded('+JSON.stringify(items)+','+weights[0]+','+volumes[0]+')</code> should return <code>'+results[0]+'</code>.');"
        },
        {
          "text":
            "'<code>knapsackUnbounded('+JSON.stringify(items)+','+weights[1]+','+volumes[1]+')</code> should return <code>'+results[1]+'</code>.'",
          "testString":
            "assert.equal(knapsackUnbounded(items,weights[1],volumes[1]),results[1],'<code>knapsackUnbounded('+JSON.stringify(items)+','+weights[1]+','+volumes[1]+')</code> should return <code>'+results[1]+'</code>.');"
        },
        {
          "text":
            "'<code>knapsackUnbounded('+JSON.stringify(items)+','+weights[2]+','+volumes[2]+')</code> should return <code>'+results[2]+'</code>.'",
          "testString":
            "assert.equal(knapsackUnbounded(items,weights[2],volumes[2]),results[2],'<code>knapsackUnbounded('+JSON.stringify(items)+','+weights[2]+','+volumes[2]+')</code> should return <code>'+results[2]+'</code>.');"
        },
        {
          "text":
            "'<code>knapsackUnbounded('+JSON.stringify(items)+','+weights[3]+','+volumes[3]+')</code> should return <code>'+results[3]+'</code>.'",
          "testString":
            "assert.equal(knapsackUnbounded(items,weights[3],volumes[3]),results[3],'<code>knapsackUnbounded('+JSON.stringify(items)+','+weights[3]+','+volumes[3]+')</code> should return <code>'+results[3]+'</code>.');"
        },
        {
          "text":
            "'<code>knapsackUnbounded('+JSON.stringify(items)+','+weights[4]+','+volumes[4]+')</code> should return <code>'+results[4]+'</code>.'",
          "testString":
            "assert.equal(knapsackUnbounded(items,weights[4],volumes[4]),results[4],'<code>knapsackUnbounded('+JSON.stringify(items)+','+weights[4]+','+volumes[4]+')</code> should return <code>'+results[4]+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7ed4",
      "challengeType": 5,
      "releasedOn": "June 16, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function knapsackUnbounded (items, maxweight, maxvolume) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var items = [",
            "{name:\"panacea\",value: 3000, weight:0.3, volume:0.025},",
            "{name:\"ichor\",value: 1800, weight:0.2, volume:0.015},",
            "{name:\"gold\",value: 2500, weight:2, volume:0.002}",
            "]",
            "let weights=[25,55,25,35,15]",
            "let volumes=[0.25,0.25,0.15,0.35,0.25]",
            "let results=[54500,88400,42500,75300,43200]"
          ]
        }
      }
    },
    {
      "title": "Knight's tour",
      "description": [
        "<a href=\"https://en.wikipedia.org/wiki/Knight%27s_tour\">Problem</a>: you have a w x h chessboard, empty but for a single knight on some square.   Your task is to emit a series of legal knight moves that result in the knight visiting every square on the chessboard exactly once. Note that it is <i>not</i> a requirement that the tour be \"closed\"; that is, the knight need not end within a single move of its start position.",
        "Write a function that takes w, h as parameters and returns the number of initial position from where it is possible to achieve the task stated above."
      ],
      "solutions": [
        "function knightTour (w, h) {\n  var b,cnt=0;\n\n  var dx = [ -2, -2, -1, 1, 2,  2,  1, -1 ];\n  var dy = [ -1,  1,  2, 2, 1, -1, -2, -2 ];\n\n  function init_board()\n  {\n  \tvar i, j, k, x, y;\n  \t// * b is board; a is board with 2 rows padded at each side\n\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        b[i][j]=255\n      }\n    }\n\n  \tfor (i = 0; i < h; i++) {\n  \t\tfor (j = 0; j < w; j++) {\n  \t\t\tfor (k = 0; k < 8; k++) {\n  \t\t\t\tx = j + dx[k], y = i + dy[k];\n  \t\t\t\tif (b[i][j] == 255) b[i][j] = 0;\n  \t\t\t\tif(x >= 0 && x < w && y >= 0 && y < h) b[i][j]++;\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n\n  function walk_board(x,y)\n  {\n  \tvar i, nx, ny, least;\n  \tvar steps = 0;\n  \t// printf(E\"H\"E\"J\"E\"%d;%dH\"E\"32m[]\"E\"m\", y + 1, 1 + 2 * x);\n\n  \twhile (1) {\n  \t\t// * occupy cell\n  \t\tb[y][x] = 255;\n\n  \t\t// * reduce all neighbors' neighbor count\n  \t\tfor (i = 0; i < 8; i++)\n        if(y+dy[i] >= 0 && x+dx[i] >= 0 && y+dy[i] < h && x+dx[i] < w)\n  \t\t\tb[ y + dy[i] ][ x + dx[i] ]--;\n\n  \t\t// find neighbor with lowest neighbor count\n  \t\tleast = 255;\n  \t\tfor (i = 0; i < 8; i++) {\n        if(y+dy[i] >= 0 && x+dx[i] >= 0 && y+dy[i] < h && x+dx[i] < w)\n  \t\t\tif (b[ y + dy[i] ][ x + dx[i] ] < least) {\n  \t\t\t\tnx = x + dx[i];\n  \t\t\t\tny = y + dy[i];\n  \t\t\t\tleast = b[ny][nx];\n  \t\t\t}\n  \t\t}\n\n  \t\tif (least > 7) {\n  \t\t\treturn steps == w * h - 1;\n  \t\t}\n\n      steps++;\n  \t\tx = nx, y = ny;\n  \t}\n  }\n\n  function solve (x,y) {\n    b=new Array(h);\n    for(var i=0;i<h;i++)\n      b[i]=new Array(w)\n\n\t\tinit_board();\n\t\tif (walk_board(x,y)) {\n      cnt++;\n\t\t}\n  }\n\n  for(var i=0;i<h;i++){\n    for(var j=0;j<w;j++){\n      solve(j,i);\n    }\n  }\n\n  return cnt;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>knightTour</code> should be a function.'",
          "testString":
            "assert(typeof knightTour=='function','<code>knightTour</code> should be a function.');"
        },
        {
          "text": "'<code>knightTour(6,6)</code> should return a number.'",
          "testString":
            "assert(typeof knightTour(6,6)=='number','<code>knightTour(6,6)</code> should return a number.');"
        },
        {
          "text":
            "'<code>knightTour(6,6)</code> should return <code>35</code>.'",
          "testString":
            "assert.equal(knightTour(6,6),35,'<code>knightTour(6,6)</code> should return <code>35</code>.');"
        },
        {
          "text":
            "'<code>knightTour(5,6)</code> should return <code>20</code>.'",
          "testString":
            "assert.equal(knightTour(5,6),20,'<code>knightTour(5,6)</code> should return <code>20</code>.');"
        },
        {
          "text":
            "'<code>knightTour(4,6)</code> should return <code>10</code>.'",
          "testString":
            "assert.equal(knightTour(4,6),10,'<code>knightTour(4,6)</code> should return <code>10</code>.');"
        },
        {
          "text":
            "'<code>knightTour(7,3)</code> should return <code>4</code>.'",
          "testString":
            "assert.equal(knightTour(7,3),4,'<code>knightTour(7,3)</code> should return <code>4</code>.');"
        },
        {
          "text":
            "'<code>knightTour(8,6)</code> should return <code>47</code>.'",
          "testString":
            "assert.equal(knightTour(8,6),47,'<code>knightTour(8,6)</code> should return <code>47</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7ed5",
      "challengeType": 5,
      "releasedOn": "June 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function knightTour (w, h) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Kronecker product based fractals",
      "description": [
        "This task is based on  <a href=\"http://rosettacode.org/wiki/Kronecker product\"> Kronecker product</a>  of two matrices.",
        "The essence of fractals is self-replication (at least, self-similar replications).",
        "So, using n times self-product of the matrix (filled with 0/1) we will have a fractal of the \\(n^{th}\\) order.",
        "Actually, \"self-product\" is a Kronecker power of the matrix. In other words: for a matrix <b>M</b> and a power <b>n</b> create a function like <b>kroneckerProductFractal(M, n)</b>, which returns \\( M &times; M &times; M &times; ...  \\) (n times product)."
      ],
      "solutions": [
        "function kroneckerProductFractal (m, ord) {\n  var t,r;\n  var mkp=(a,b)=>a.map(a=>b.map(b=>a.map(y=>b.map(x=>r.push(y*x)),t.push(r=[]))),t=[])&&t;\n  var rm=m;\n  for(var i=1; i<ord; i++) {rm=mkp(rm,m)};\n  return(rm);\n}\n\n"
      ],
      "tests": [
        {
          "text":
            "'<code>kroneckerProductFractal</code> should be a function.'",
          "testString":
            "assert(typeof kroneckerProductFractal=='function','<code>kroneckerProductFractal</code> should be a function.');"
        },
        {
          "text":
            "'<code>kroneckerProductFractal('+JSON.stringify(M[0])+',2)</code> should return an array.'",
          "testString":
            "assert(Array.isArray(kroneckerProductFractal(M[0],2)),'<code>kroneckerProductFractal('+JSON.stringify(M[0])+',2)</code> should return an array.');"
        },
        {
          "text":
            "'<code>kroneckerProductFractal('+JSON.stringify(M[0])+',2)</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(kroneckerProductFractal(M[0],2),results[0],'<code>kroneckerProductFractal('+JSON.stringify(M[0])+',2)</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>kroneckerProductFractal('+JSON.stringify(M[1])+',2)</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(kroneckerProductFractal(M[1],2),results[1],'<code>kroneckerProductFractal('+JSON.stringify(M[1])+',2)</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>kroneckerProductFractal('+JSON.stringify(M[2])+',2)</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(kroneckerProductFractal(M[2],2),results[2],'<code>kroneckerProductFractal('+JSON.stringify(M[2])+',2)</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>kroneckerProductFractal('+JSON.stringify(M[3])+',2)</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(kroneckerProductFractal(M[3],2),results[3],'<code>kroneckerProductFractal('+JSON.stringify(M[3])+',2)</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>kroneckerProductFractal('+JSON.stringify(M[4])+',3)</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(kroneckerProductFractal(M[4],3),results[4],'<code>kroneckerProductFractal('+JSON.stringify(M[4])+',3)</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7ed8",
      "challengeType": 5,
      "releasedOn": "June 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function kroneckerProductFractal (m, ord) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var M=[",
            "[[1,1],[1,1]],",
            "[[0,1],[1,1]],",
            "[[1,0],[0,1]],",
            "[[1,0],[1,0]],",
            "[[0,1],[1,1]]",
            "]",
            "var results=[",
            "[[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]],",
            "[[0,0,0,1],[0,0,1,1],[0,1,0,1],[1,1,1,1]],",
            "[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],",
            "[[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]],",
            "[[0,0,0,0,0,0,0,1],",
            "[0,0,0,0,0,0,1,1],",
            "[0,0,0,0,0,1,0,1],",
            "[0,0,0,0,1,1,1,1],",
            "[0,0,0,1,0,0,0,1],",
            "[0,0,1,1,0,0,1,1],",
            "[0,1,0,1,0,1,0,1],",
            "[1,1,1,1,1,1,1,1]]",
            "]"
          ]
        }
      }
    },
    {
      "title": "Kronecker product",
      "description": [
        "Implement the  <a href=\"https://en.wikipedia.org/wiki/Kronecker_product\">Kronecker product</a>  of two matrices (arbitrary sized) resulting in a block matrix.",
        "Example:",
        "\\begin{align} \\begin{bmatrix} 1 & 2 \\cr 3 & 4 \\end{bmatrix} &times; \\begin{bmatrix} 0 & 5 \\cr 6 & 7 \\end{bmatrix} = \\begin{bmatrix} 0 & 5 & 0 & 10 \\cr 6 & 7& 12& 14 \\cr  0 &15 & 0& 20 \\cr 18& 21& 24& 28 \\end{bmatrix} \\end{align}"
      ],
      "solutions": [
        "function kroneckerProduct (A, B) {\n  var t,r;\n  var mkp=(a,b)=>a.map(a=>b.map(b=>a.map(y=>b.map(x=>r.push(y*x)),t.push(r=[]))),t=[])&&t;\n  return mkp(A,B)\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>kroneckerProduct</code> should be a function.'",
          "testString":
            "assert(typeof kroneckerProduct=='function','<code>kroneckerProduct</code> should be a function.');"
        },
        {
          "text":
            "'<code>kroneckerProduct('+JSON.stringify(A)+','+JSON.stringify(B[0])+')</code> should return an array.'",
          "testString":
            "assert(Array.isArray(kroneckerProduct(A,B[0])),'<code>kroneckerProduct('+JSON.stringify(A)+','+JSON.stringify(B[0])+')</code> should return an array.');"
        },
        {
          "text":
            "'<code>kroneckerProduct('+JSON.stringify(A)+','+JSON.stringify(B[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(kroneckerProduct(A,B[0]),results[0],'<code>kroneckerProduct('+JSON.stringify(A)+','+JSON.stringify(B[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>kroneckerProduct('+JSON.stringify(A)+','+JSON.stringify(B[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(kroneckerProduct(A,B[1]),results[1],'<code>kroneckerProduct('+JSON.stringify(A)+','+JSON.stringify(B[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>kroneckerProduct('+JSON.stringify(A)+','+JSON.stringify(B[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(kroneckerProduct(A,B[2]),results[2],'<code>kroneckerProduct('+JSON.stringify(A)+','+JSON.stringify(B[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>kroneckerProduct('+JSON.stringify(A)+','+JSON.stringify(B[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(kroneckerProduct(A,B[3]),results[3],'<code>kroneckerProduct('+JSON.stringify(A)+','+JSON.stringify(B[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>kroneckerProduct('+JSON.stringify(A)+','+JSON.stringify(B[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(kroneckerProduct(A,B[4]),results[4],'<code>kroneckerProduct('+JSON.stringify(A)+','+JSON.stringify(B[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7ed9",
      "challengeType": 5,
      "releasedOn": "June 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function kroneckerProduct (A, B) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var A=[[1,2],[3,4]]",
            "var B=[",
            "[[0,5],[6,7]],",
            "[[0,1],[1,1]],",
            "[[1,1,],[1,1]],",
            "[[2,3],[1,1]],",
            "[[4,3],[2,1]]",
            "]",
            "var results=[",
            "[[0,5,0,10],[6,7,12,14],[0,15,0,20],[18,21,24,28]],",
            "[[0,1,0,2],[1,1,2,2],[0,3,0,4],[3,3,4,4]],",
            "[[1,1,2,2],[1,1,2,2],[3,3,4,4],[3,3,4,4]],",
            "[[2,3,4,6],[1,1,2,2],[6,9,8,12],[3,3,4,4]],",
            "[[4,3,8,6],[2,1,4,2],[12,9,16,12],[6,3,8,4]]",
            "]"
          ]
        }
      }
    },
    {
      "title": "Largest int from concatenated ints",
      "description": [
        "Given a set of positive integers, write a function to order the integers in such a way that the concatenation of the numbers forms the largest possible integer and return this integer."
      ],
      "solutions": [
        "function maxCombine (xs) {\n   return parseInt(\n       xs.sort(\n           function (x, y) {\n               var a = x.toString(),\n                   b = y.toString(),\n                   ab = parseInt(a + b),\n                   ba = parseInt(b + a);\n\n               return ab > ba ? -1 : (ab < ba ? 1 : 0);\n           }\n       )\n       .join(''), 10\n   );\n}\n\n"
      ],
      "tests": [
        {
          "text": "'<code>maxCombine</code> should be a function.'",
          "testString":
            "assert(typeof maxCombine=='function','<code>maxCombine</code> should be a function.');"
        },
        {
          "text":
            "'<code>maxCombine('+JSON.stringify(tests[0])+')</code> should return a number.'",
          "testString":
            "assert(typeof maxCombine(tests[0])=='number','<code>maxCombine('+JSON.stringify(tests[0])+')</code> should return a number.');"
        },
        {
          "text":
            "'<code>maxCombine('+JSON.stringify(tests[0])+')</code> should return <code>554331</code>.'",
          "testString":
            "assert.equal(maxCombine(tests[0]),554331,'<code>maxCombine('+JSON.stringify(tests[0])+')</code> should return <code>554331</code>.');"
        },
        {
          "text":
            "'<code>maxCombine('+JSON.stringify(tests[1])+')</code> should return <code>71545423</code>.'",
          "testString":
            "assert.equal(maxCombine(tests[1]),71545423,'<code>maxCombine('+JSON.stringify(tests[1])+')</code> should return <code>71545423</code>.');"
        },
        {
          "text":
            "'<code>maxCombine('+JSON.stringify(tests[2])+')</code> should return <code>55534314114</code>.'",
          "testString":
            "assert.equal(maxCombine(tests[2]),55534314114,'<code>maxCombine('+JSON.stringify(tests[2])+')</code> should return <code>55534314114</code>.');"
        },
        {
          "text":
            "'<code>maxCombine('+JSON.stringify(tests[3])+')</code> should return <code>998764543431</code>.'",
          "testString":
            "assert.equal(maxCombine(tests[3]),998764543431,'<code>maxCombine('+JSON.stringify(tests[3])+')</code> should return <code>998764543431</code>.');"
        },
        {
          "text":
            "'<code>maxCombine('+JSON.stringify(tests[4])+')</code> should return <code>6054854654</code>.'",
          "testString":
            "assert.equal(maxCombine(tests[4]),6054854654,'<code>maxCombine('+JSON.stringify(tests[4])+')</code> should return <code>6054854654</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7edb",
      "challengeType": 5,
      "releasedOn": "June 26, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function maxCombine (xs) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "var tests=[",
            "[1,3,3,4,55],",
            "[71,45,23,4,5],",
            "[14,43,53,114,55],",
            "[1,34,3,98,9,76,45,4],",
            "[54,546,548,60]",
            "]"
          ]
        }
      }
    },
    {
      "title": "Last Friday of each month",
      "description": [
        "Write a function that returns the date of the last Friday of a given month for a given year."
      ],
      "solutions": [
        "function lastFriday (year, month) {\n  var i, last_day;\n  i = 0;\n  while (true) {\n    last_day = new Date(year, month, i);\n    if (last_day.getDay() === 5) {\n      return last_day.getDate();\n    }\n    i -= 1;\n  }\n};\n"
      ],
      "tests": [
        {
          "text": "'<code>lastFriday</code> should be a function.'",
          "testString":
            "assert(typeof lastFriday=='function','<code>lastFriday</code> should be a function.');"
        },
        {
          "text": "'<code>lastFriday(2018, 1)</code> should return a number.'",
          "testString":
            "assert(typeof lastFriday(2018, 1)=='number','<code>lastFriday(2018, 1)</code> should return a number.');"
        },
        {
          "text":
            "'<code>lastFriday(2018, 1)</code> should return <code>26</code>.'",
          "testString":
            "assert.equal(lastFriday(2018, 1),26,'<code>lastFriday(2018, 1)</code> should return <code>26</code>.');"
        },
        {
          "text":
            "'<code>lastFriday(2017, 2)</code> should return <code>24</code>.'",
          "testString":
            "assert.equal(lastFriday(2017, 2),24,'<code>lastFriday(2017, 2)</code> should return <code>24</code>.');"
        },
        {
          "text":
            "'<code>lastFriday(2012, 3)</code> should return <code>30</code>.'",
          "testString":
            "assert.equal(lastFriday(2012, 3),30,'<code>lastFriday(2012, 3)</code> should return <code>30</code>.');"
        },
        {
          "text":
            "'<code>lastFriday(1900, 4)</code> should return <code>27</code>.'",
          "testString":
            "assert.equal(lastFriday(1900, 4),27,'<code>lastFriday(1900, 4)</code> should return <code>27</code>.');"
        },
        {
          "text":
            "'<code>lastFriday(2000, 5)</code> should return <code>26</code>.'",
          "testString":
            "assert.equal(lastFriday(2000, 5),26,'<code>lastFriday(2000, 5)</code> should return <code>26</code>.');"
        },
        {
          "text":
            "'<code>lastFriday(2006, 6)</code> should return <code>30</code>.'",
          "testString":
            "assert.equal(lastFriday(2006, 6),30,'<code>lastFriday(2006, 6)</code> should return <code>30</code>.');"
        },
        {
          "text":
            "'<code>lastFriday(2010, 7)</code> should return <code>30</code>.'",
          "testString":
            "assert.equal(lastFriday(2010, 7),30,'<code>lastFriday(2010, 7)</code> should return <code>30</code>.');"
        },
        {
          "text":
            "'<code>lastFriday(2005, 8)</code> should return <code>26</code>.'",
          "testString":
            "assert.equal(lastFriday(2005, 8),26,'<code>lastFriday(2005, 8)</code> should return <code>26</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7edc",
      "challengeType": 5,
      "releasedOn": "June 26, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function lastFriday (year, month) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Last letter-first letter",
      "description": [
        "A certain children's game involves starting with a word in a particular category.  Each participant in turn says a word, but that word must begin with the final letter of the previous word.  Once a word has been given, it cannot be repeated.  If an opponent cannot give a word in the category, they fall out of the game.",
        "For example, with  \"animals\"  as the category,",
        "<pre>",
        "Child 1: dog",
        "Child 2: goldfish",
        "Child 1: hippopotamus",
        "Child 2: snake",
        "...",
        "</pre>",
        "Write a function that takes an input array of words. The function should return an array of words where the first letter of each word is the same as the last letter of the previous word. The first word in the return array can be anything. Use only the words in the input array, and once a word is used it cannot be repeated. The words in the return array should be selected and sequenced so that that the length of the array is maximized."
      ],
      "solutions": [
        "function findLongestChain (items) {\n  function Ref(index, first_char, last_char) {\n    this.index = index;\n    this.first_char = first_char;\n    this.last_char = last_char;\n  }\n\n  var items_len = items.length\n  var refs_len = items_len;\n  var refs = []\n\n  // enough space for all items\n  var longest_path_refs_len = 0;\n  var longest_path_refs = new Array(items_len)\n\n  function search(curr_len) {\n    if (curr_len > longest_path_refs_len) {\n      longest_path_refs_len = curr_len;\n\n      for (var i = 0; i < curr_len; i++) {\n        longest_path_refs[i] = refs[i];\n      }\n    }\n\n    // recursive search\n    var last_char = refs[curr_len - 1].last_char;\n    for (var i = curr_len; i < refs_len; i++)\n      if (refs[i].first_char == last_char) {\n        var aux = refs[curr_len];\n        refs[curr_len] = refs[i];\n        refs[i] = aux;\n        search(curr_len + 1);\n        refs[i] = refs[curr_len];\n        refs[curr_len] = aux;\n      }\n  }\n\n  for (var i = 0; i < items_len; i++) {\n    var itemsi_len = items[i].length;\n    refs.push(new Ref(i, items[i][0], items[i][itemsi_len - 1]))\n  }\n\n  // try each item as possible start\n  for (var i = 0; i < items_len; i++) {\n    var aux = refs[0];\n    refs[0] = refs[i];\n    refs[i] = aux;\n    search(1);\n    refs[i] = refs[0];\n    refs[0] = aux;\n  }\n\n  var longest_path_len = longest_path_refs_len;\n  var longest_path = new Array(longest_path_len)\n  // calloc(longest_path_len, sizeof(const char*));\n  for (var i = 0; i < longest_path_len; i++)\n    longest_path[i] = items[longest_path_refs[i].index];\n\n  return longest_path\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>findLongestChain</code> should be a function.'",
          "testString":
            "assert(typeof findLongestChain=='function','<code>findLongestChain</code> should be a function.');"
        },
        {
          "text":
            "'<code>findLongestChain('+JSON.stringify(tests[0])+')</code> should return an array.'",
          "testString":
            "assert(Array.isArray(findLongestChain(tests[0])),'<code>findLongestChain('+JSON.stringify(tests[0])+')</code> should return an array.');"
        },
        {
          "text":
            "'<code>findLongestChain('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(findLongestChain(tests[0]),results[0],'<code>findLongestChain('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>findLongestChain('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(findLongestChain(tests[1]),results[1],'<code>findLongestChain('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>findLongestChain('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(findLongestChain(tests[2]),results[2],'<code>findLongestChain('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>findLongestChain('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(findLongestChain(tests[3]),results[3],'<code>findLongestChain('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>findLongestChain('+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(findLongestChain(tests[4]),results[4],'<code>findLongestChain('+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7edd",
      "challengeType": 5,
      "releasedOn": "June 30, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function findLongestChain (items) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var tests = [",
            "[\"certain\",\"each\",\"game\",\"involves\",\"starting\",\"with\",\"word\"],",
            "[\"audino\",\"bagon\",\"kangaskhan\",\"banette\",\"bidoof\",\"braviary\",\"exeggcute\",\"yamask\"],",
            "[\"harp\",\"poliwrath\",\"poochyena\",\"porygon2\",\"porygonz\",\"archana\"],",
            "[\"scolipede\",\"elephant\",\"zeaking\",\"sealeo\",\"silcoon\",\"tigers\"],",
            "[\"loudred\",\"lumineon\",\"lunatone\",\"machamp\",\"magnezone\",\"nosepass\",\"petilil\",\"pidgeotto\",\"pikachu\"]",
            "]",
            "var results=[",
            "['involves','starting','game','each'],",
            "['braviary','yamask','kangaskhan'],",
            "['poliwrath','harp','poochyena','archana'],",
            "['scolipede','elephant','tigers','sealeo'],",
            "['machamp','petilil','lumineon','nosepass']",
            "]"
          ]
        }
      }
    },
    {
      "title": "Leap year",
      "description": [
        "Determine whether a given year is a leap year in the Gregorian calendar."
      ],
      "solutions": [
        "function isLeapYear (year) {\n  return (year % 100 === 0) ? (year % 400 === 0) : (year % 4 === 0);\n};\n"
      ],
      "tests": [
        {
          "text":
            "assert(typeof isLeapYear == 'function', '<code>isLeapYear</code> should be a function.'",
          "testString":
            "assert(typeof isLeapYear == 'function', '<code>isLeapYear</code> should be a function.');"
        },
        {
          "text":
            "assert(typeof isLeapYear(2018) == 'boolean', '<code>isLeapYear()</code> should return a boolean.'",
          "testString":
            "assert(typeof isLeapYear(2018) == 'boolean', '<code>isLeapYear()</code> should return a boolean.');"
        },
        {
          "text":
            "assert.equal(isLeapYear(2018), false, '<code>isLeapYear(2018)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isLeapYear(2018), false, '<code>isLeapYear(2018)</code> should return <code>false</code>.');"
        },
        {
          "text":
            "assert.equal(isLeapYear(2016), true, '<code>isLeapYear(2016)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isLeapYear(2016), true, '<code>isLeapYear(2016)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "assert.equal(isLeapYear(2000), true, '<code>isLeapYear(2000)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isLeapYear(2000), true, '<code>isLeapYear(2000)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "assert.equal(isLeapYear(1900), false, '<code>isLeapYear(1900)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isLeapYear(1900), false, '<code>isLeapYear(1900)</code> should return <code>false</code>.');"
        },
        {
          "text":
            "assert.equal(isLeapYear(1996), true, '<code>isLeapYear(1996)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isLeapYear(1996), true, '<code>isLeapYear(1996)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "assert.equal(isLeapYear(1800), false, '<code>isLeapYear(1800)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isLeapYear(1800), false, '<code>isLeapYear(1800)</code> should return <code>false</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7ede",
      "challengeType": 5,
      "releasedOn": "June 30, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function isLeapYear (year) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Least common multiple",
      "description": [
        "Compute the least common multiple of an array of intergers.",
        "Given  <i>m</i>  and  <i>n</i>,  the least common multiple is the smallest positive integer that has both  <i>m</i>  and  <i>n</i>  as factors.",
        "The least common multiple of 12 and 18 is 36, because 12 is a factor (12 &times; 3 = 36), and 18 is a factor (18 &times; 2 = 36), and there is no positive integer less than 36 that has both factors.  As a special case, if either  <i>m</i>  or  <i>n</i>  is zero, then the least common multiple is zero.",
        "One way to calculate the least common multiple is to iterate all the multiples of  <i>m</i>,  until you find one that is also a multiple of  <i>n</i>.",
        "If you already have  <i>gcd</i>  for <a href=\"http://rosettacode.org/wiki/greatest common divisor\">greatest common divisor</a>,  then this formula calculates  <i>lcm</i>.",
        "\\( \\operatorname{lcm}(m, n) = \\frac{|m \\times n|}{\\operatorname{gcd}(m, n)} \\)"
      ],
      "solutions": [
        "function LCM (A) {\n    var n = A.length, a = Math.abs(A[0]);\n    for (var i = 1; i < n; i++)\n     { var b = Math.abs(A[i]), c = a;\n       while (a && b){ a > b ? a %= b : b %= a; }\n       a = Math.abs(c*A[i])/(a+b);\n     }\n    return a;\n}\n\nvar tests=[\n[2,4,8],\n[4,8,12],\n[3,4,5,12,40],\n[11,33,90],\n[-50,25,-45,-18,90,447]\n]\n"
      ],
      "tests": [
        {
          "text": "'<code>LCM</code> should be a function.'",
          "testString":
            "assert(typeof LCM=='function','<code>LCM</code> should be a function.');"
        },
        {
          "text":
            "'<code>LCM('+JSON.stringify(tests[0])+')</code> should return a number.'",
          "testString":
            "assert(typeof LCM(tests[0])=='number','<code>LCM('+JSON.stringify(tests[0])+')</code> should return a number.');"
        },
        {
          "text":
            "'<code>LCM('+JSON.stringify(tests[0])+')</code> should return <code>8</code>.'",
          "testString":
            "assert.equal(LCM(tests[0]),8,'<code>LCM('+JSON.stringify(tests[0])+')</code> should return <code>8</code>.');"
        },
        {
          "text":
            "'<code>LCM('+JSON.stringify(tests[1])+')</code> should return <code>24</code>.'",
          "testString":
            "assert.equal(LCM(tests[1]),24,'<code>LCM('+JSON.stringify(tests[1])+')</code> should return <code>24</code>.');"
        },
        {
          "text":
            "'<code>LCM('+JSON.stringify(tests[2])+')</code> should return <code>120</code>.'",
          "testString":
            "assert.equal(LCM(tests[2]),120,'<code>LCM('+JSON.stringify(tests[2])+')</code> should return <code>120</code>.');"
        },
        {
          "text":
            "'<code>LCM('+JSON.stringify(tests[3])+')</code> should return <code>990</code>.'",
          "testString":
            "assert.equal(LCM(tests[3]),990,'<code>LCM('+JSON.stringify(tests[3])+')</code> should return <code>990</code>.');"
        },
        {
          "text":
            "'<code>LCM('+JSON.stringify(tests[4])+')</code> should return <code>67050</code>.'",
          "testString":
            "assert.equal(LCM(tests[4]),67050,'<code>LCM('+JSON.stringify(tests[4])+')</code> should return <code>67050</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7edf",
      "challengeType": 5,
      "releasedOn": "June 30, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function LCM (A) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Left factorials",
      "description": [
        "<b>Left factorials</b>,  $ !n $,  may refer to either  <i>subfactorials</i>  or to  <i>factorial sums</i>. The same notation can be confusingly seen used for the two different definitions. Sometimes,  <i>subfactorials</i>  (also known as <i>derangements</i>)  may use any of the notations:",
        "$$!n`$$",
        "$$!n$$",
        "$$n¡$$",
        "(It may not be visually obvious, but the last example uses an upside-down exclamation mark.) This task will be using this formula for <b>left factorial</b>:",
        "$$ !n = \\sum_{k=0}^{n-1} k! $$",
        "where $!0 = 0$",
        "Write a function to calculate the left factorial of a given number."
      ],
      "solutions": [
        "function leftFactorial (n) {\n  if(n==0)\n    return 0\n  if(n==1)\n    return 1;\n\n  // Note: for n>=20, the result may not be correct.\n  // This is because Javascript uses 53 bit integers and\n  // for n>=20 result becomes too large.\n\n  let res=2,fact=2;\n  for(var i=2;i<n;i++){\n    res+=fact;\n    fact*=(i+1);\n  }\n\n  return res;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>leftFactorial</code> should be a function.'",
          "testString":
            "assert(typeof leftFactorial=='function','<code>leftFactorial</code> should be a function.');"
        },
        {
          "text": "'<code>leftFactorial(0)</code> should return a number.'",
          "testString":
            "assert(typeof leftFactorial(0)=='number','<code>leftFactorial(0)</code> should return a number.');"
        },
        {
          "text":
            "'<code>leftFactorial(0)</code> should return <code>0</code>.'",
          "testString":
            "assert.equal(leftFactorial(0),0,'<code>leftFactorial(0)</code> should return <code>0</code>.');"
        },
        {
          "text":
            "'<code>leftFactorial(1)</code> should return <code>1</code>.'",
          "testString":
            "assert.equal(leftFactorial(1),1,'<code>leftFactorial(1)</code> should return <code>1</code>.');"
        },
        {
          "text":
            "'<code>leftFactorial(2)</code> should return <code>2</code>.'",
          "testString":
            "assert.equal(leftFactorial(2),2,'<code>leftFactorial(2)</code> should return <code>2</code>.');"
        },
        {
          "text":
            "'<code>leftFactorial(3)</code> should return <code>4</code>.'",
          "testString":
            "assert.equal(leftFactorial(3),4,'<code>leftFactorial(3)</code> should return <code>4</code>.');"
        },
        {
          "text":
            "'<code>leftFactorial(10)</code> should return <code>409114</code>.'",
          "testString":
            "assert.equal(leftFactorial(10),409114,'<code>leftFactorial(10)</code> should return <code>409114</code>.');"
        },
        {
          "text":
            "'<code>leftFactorial(17)</code> should return <code>22324392524314</code>.'",
          "testString":
            "assert.equal(leftFactorial(17),22324392524314,'<code>leftFactorial(17)</code> should return <code>22324392524314</code>.');"
        },
        {
          "text":
            "'<code>leftFactorial(19)</code> should return <code>6780385526348314</code>.'",
          "testString":
            "assert.equal(leftFactorial(19),6780385526348314,'<code>leftFactorial(19)</code> should return <code>6780385526348314</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7ee0",
      "challengeType": 5,
      "releasedOn": "June 30, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function leftFactorial (n) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Letter frequency",
      "description": [
        "Write a function to count the occurrences of each character in a given string.",
        "All characters should be counted. This includes lower and upper case letters, digits, whitespace, special characters, or any other distinct characters.",
        "The function should return a 2D array with each of the elements in the following form: <code>['char', freq]</code>. The character should be a string with a length of 1, and frequency is a number denoting the count.",
        "For example, given the string \"ab\", your function should return <code>[['a', 1], ['b', 1]]</code>."
      ],
      "solutions": [
        "function letterFrequency (txt) {\n    var cs = txt.split(''),\n        i = cs.length,\n        dct =  {},\n        c = '',\n        keys;\n\n    while (i--) {\n        c = cs[i];\n        dct[c] = (dct[c] || 0) + 1;\n    }\n\n    keys = Object.keys(dct);\n    keys.sort();\n    return keys.map(function (c) { return [c, dct[c]]; });\n}\n\n"
      ],
      "tests": [
        {
          "text": "'<code>letterFrequency</code> should be a function.'",
          "testString":
            "assert(typeof letterFrequency=='function','<code>letterFrequency</code> should be a function.');"
        },
        {
          "text":
            "'<code>letterFrequency('+JSON.stringify(tests[0])+')</code> should return an array.'",
          "testString":
            "assert(Array.isArray(letterFrequency(tests[0])),'<code>letterFrequency('+JSON.stringify(tests[0])+')</code> should return an array.');"
        },
        {
          "text":
            "'<code>letterFrequency('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(letterFrequency(tests[0]),results[0],'<code>letterFrequency('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>letterFrequency('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(letterFrequency(tests[1]),results[1],'<code>letterFrequency('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>letterFrequency('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(letterFrequency(tests[2]),results[2],'<code>letterFrequency('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>letterFrequency('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(letterFrequency(tests[3]),results[3],'<code>letterFrequency('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>letterFrequency('+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(letterFrequency(tests[4]),results[4],'<code>letterFrequency('+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        },
        {
          "text":
            "'<code>letterFrequency('+JSON.stringify(tests[5])+')</code> should return <code>'+JSON.stringify(results[5])+'</code>.'",
          "testString":
            "assert.deepEqual(letterFrequency(tests[5]),results[5],'<code>letterFrequency('+JSON.stringify(tests[5])+')</code> should return <code>'+JSON.stringify(results[5])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7ee1",
      "challengeType": 5,
      "releasedOn": "June 30, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function letterFrequency (txt) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var tests=[",
            "  \"Not all that Mrs. Bennet, however\",",
            "  \"daughters, could ask on the \",",
            "  \"husband any satisfactory description\",",
            "  \"in various ways--with barefaced\",",
            "  \"distant surmises; but he eluded\",",
            "  \"last obliged to accept the second-hand,\",",
            "]",
            "var results=[",
            "[[' ',5],[',',1],['.',1],['B',1],['M',1],['N',1],['a',2],['e',4],['h',2],['l',2],['n',2],['o',2],['r',2],['s',1],['t',4],['v',1],['w',1]],",
            "[[' ',5],[',',1],['a',2],['c',1],['d',2],['e',2],['g',1],['h',2],['k',1],['l',1],['n',1],['o',2],['r',1],['s',2],['t',2],['u',2]],",
            "[[' ',3],['a',4],['b',1],['c',2],['d',2],['e',1],['f',1],['h',1],['i',3],['n',3],['o',2],['p',1],['r',2],['s',4],['t',3],['u',1],['y',2]],",
            "[[' ',3],['-',2],['a',4],['b',1],['c',1],['d',1],['e',2],['f',1],['h',1],['i',3],['n',1],['o',1],['r',2],['s',2],['t',1],['u',1],['v',1],['w',2],['y',1]],",
            "[[' ',4],[';',1],['a',1],['b',1],['d',3],['e',4],['h',1],['i',2],['l',1],['m',1],['n',1],['r',1],['s',4],['t',3],['u',3]],",
            "[[' ',5],[',',1],['-',1],['a',3],['b',1],['c',3],['d',3],['e',4],['g',1],['h',2],['i',1],['l',2],['n',2],['o',3],['p',1],['s',2],['t',4]]",
            "]"
          ]
        }
      }
    },
    {
      "title": "Levenshtein distance",
      "description": [
        "In information theory and computer science, the <b>Levenshtein distance</b> is a <a href=\"https://en.wikipedia.org/wiki/string metric\">metric</a> for measuring the amount of difference between two sequences (i.e. an <a href=\"https://en.wikipedia.org/wiki/edit distance\">edit distance</a>). The Levenshtein distance between two strings is defined as the minimum number of edits needed to transform one string into the other, with the allowable edit operations being insertion, deletion, or substitution of a single character.",
        "Example:",
        "The Levenshtein distance between \"<b>kitten</b>\" and \"<b>sitting</b>\" is 3, since the following three edits change one into the other, and there isn't a way to do it with fewer than three edits:",
        "<b>k</b>itten   <b>s</b>itten      (substitution of 'k' with 's')</b>",
        "sitt<b>e</b>n   sitt<b>i</b>n      (substitution of 'e' with 'i')</b>",
        "sittin         sittin<b>g</b>     (insert 'g' at the end).</b>",
        "''The Levenshtein distance between  \"<b>rosettacode</b>\",  \"<b>raisethysword</b>\"  is  <b>8</b>.",
        "<i>The distance between two strings is same as that when both strings are reversed.</i>",
        "Write a function that returns the Levenshtein distance between two strings given as parameters ."
      ],
      "solutions": [
        "function levenshtein (a, b) {\n  var t = [], u, i, j, m = a.length, n = b.length;\n  if (!m) { return n; }\n  if (!n) { return m; }\n  for (j = 0; j <= n; j++) { t[j] = j; }\n  for (i = 1; i <= m; i++) {\n    for (u = [i], j = 1; j <= n; j++) {\n      u[j] = a[i - 1] === b[j - 1] ? t[j - 1] : Math.min(t[j - 1], t[j], u[j - 1]) + 1;\n    } t = u;\n  } return u[n];\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>levenshtein</code> should be a function.'",
          "testString":
            "assert(typeof levenshtein=='function','<code>levenshtein</code> should be a function.');"
        },
        {
          "text":
            "'<code>levenshtein('+tests[0][0]+','+tests[0][1]+')</code> should return a number.'",
          "testString":
            "assert(typeof levenshtein(tests[0][0],tests[0][1])=='number','<code>levenshtein('+tests[0][0]+','+tests[0][1]+')</code> should return a number.');"
        },
        {
          "text":
            "'<code>levenshtein('+tests[0][0]+','+tests[0][1]+')</code> should return <code>'+tests[0][2]+'</code>.'",
          "testString":
            "assert.equal(levenshtein(tests[0][0],tests[0][1]),tests[0][2],'<code>levenshtein('+tests[0][0]+','+tests[0][1]+')</code> should return <code>'+tests[0][2]+'</code>.');"
        },
        {
          "text":
            "'<code>levenshtein('+tests[1][0]+','+tests[1][1]+')</code> should return <code>'+tests[1][2]+'</code>.'",
          "testString":
            "assert.equal(levenshtein(tests[1][0],tests[1][1]),tests[1][2],'<code>levenshtein('+tests[1][0]+','+tests[1][1]+')</code> should return <code>'+tests[1][2]+'</code>.');"
        },
        {
          "text":
            "'<code>levenshtein('+tests[2][0]+','+tests[2][1]+')</code> should return <code>'+tests[2][2]+'</code>.'",
          "testString":
            "assert.equal(levenshtein(tests[2][0],tests[2][1]),tests[2][2],'<code>levenshtein('+tests[2][0]+','+tests[2][1]+')</code> should return <code>'+tests[2][2]+'</code>.');"
        },
        {
          "text":
            "'<code>levenshtein('+tests[3][0]+','+tests[3][1]+')</code> should return <code>'+tests[3][2]+'</code>.'",
          "testString":
            "assert.equal(levenshtein(tests[3][0],tests[3][1]),tests[3][2],'<code>levenshtein('+tests[3][0]+','+tests[3][1]+')</code> should return <code>'+tests[3][2]+'</code>.');"
        },
        {
          "text":
            "'<code>levenshtein('+tests[4][0]+','+tests[4][1]+')</code> should return <code>'+tests[4][2]+'</code>.'",
          "testString":
            "assert.equal(levenshtein(tests[4][0],tests[4][1]),tests[4][2],'<code>levenshtein('+tests[4][0]+','+tests[4][1]+')</code> should return <code>'+tests[4][2]+'</code>.');"
        },
        {
          "text":
            "'<code>levenshtein('+tests[5][0]+','+tests[5][1]+')</code> should return <code>'+tests[5][2]+'</code>.'",
          "testString":
            "assert.equal(levenshtein(tests[5][0],tests[5][1]),tests[5][2],'<code>levenshtein('+tests[5][0]+','+tests[5][1]+')</code> should return <code>'+tests[5][2]+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7ee2",
      "challengeType": 5,
      "releasedOn": "June 30, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function levenshtein (a, b) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "var tests=[",
            "['mist','dist',1],",
            "['tier','tor',2],",
            "['kitten','sitting',3],",
            "['stop','tops',2],",
            "['rosettacode','raisethysword',8],",
            "['mississippi','swiss miss',8]]"
          ]
        }
      }
    },
    {
      "title": "Linear congruential generator",
      "description": [
        "The <a href=\"https://en.wikipedia.org/wiki/linear congruential generator\">linear congruential generator</a> is a very simple example of a <a href=\"http://rosettacode.org/wiki/random number generator\">random number generator</a>. All linear congruential generators use this formula:",
        "$$r_{n + 1} = a \\times r_n + c \\pmod m$$",
        "Where:",
        "<ul>",
        "<li>$ r_0 $ is a seed.</li>",
        "<li>$r_1$, $r_2$, $r_3$, ..., are the random numbers.</li>",
        "<li>$a$, $c$, $m$ are constants.</li>",
        "</ul>",
        "If one chooses the values of $a$, $c$ and $m$ with care, then the generator produces a uniform distribution of integers from $0$ to $m - 1$.",
        "LCG numbers have poor quality. $r_n$ and $r_{n + 1}$ are not independent, as true random numbers would be. Anyone who knows $r_n$ can predict $r_{n + 1}$, therefore LCG is not cryptographically secure. The LCG is still good enough for simple tasks like <a href=\"http://rosettacode.org/wiki/Miller-Rabin primality test\">Miller-Rabin primality test</a>, or <a href=\"http://rosettacode.org/wiki/deal cards for FreeCell\">FreeCell deals</a>. Among the benefits of the LCG, one can easily reproduce a sequence of numbers, from the same $r_0$. One can also reproduce such sequence with a different programming language, because the formula is so simple.",
        "Write a function that takes $r_0,a,c,m,n$ as parameters and returns $r_n$."
      ],
      "solutions": [
        "\nfunction linearCongGenerator (r0, a, c, m, n) {\n  for(var i=0;i<n;i++){\n    r0=(a*r0+c)%m\n  }\n  return r0\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>linearCongGenerator</code> should be a function.'",
          "testString":
            "assert(typeof linearCongGenerator=='function','<code>linearCongGenerator</code> should be a function.');"
        },
        {
          "text":
            "'<code>linearCongGenerator(324, 1145, 177, 2148, 3)</code> should return a number.'",
          "testString":
            "assert(typeof linearCongGenerator(324, 1145, 177, 2148, 3)=='number','<code>linearCongGenerator(324, 1145, 177, 2148, 3)</code> should return a number.');"
        },
        {
          "text":
            "'<code>linearCongGenerator(324, 1145, 177, 2148, 3)</code> should return <code>855</code>.'",
          "testString":
            "assert.equal(linearCongGenerator(324, 1145, 177, 2148, 3),855,'<code>linearCongGenerator(324, 1145, 177, 2148, 3)</code> should return <code>855</code>.');"
        },
        {
          "text":
            "'<code>linearCongGenerator(234, 11245, 145, 83648, 4)</code> should return <code>1110</code>.'",
          "testString":
            "assert.equal(linearCongGenerator(234, 11245, 145, 83648, 4),1110,'<code>linearCongGenerator(234, 11245, 145, 83648, 4)</code> should return <code>1110</code>.');"
        },
        {
          "text":
            "'<code>linearCongGenerator(85, 11, 1234, 214748, 5)</code> should return <code>62217</code>.'",
          "testString":
            "assert.equal(linearCongGenerator(85, 11, 1234, 214748, 5),62217,'<code>linearCongGenerator(85, 11, 1234, 214748, 5)</code> should return <code>62217</code>.');"
        },
        {
          "text":
            "'<code>linearCongGenerator(0, 1103515245, 12345, 2147483648, 1)</code> should return <code>12345</code>.'",
          "testString":
            "assert.equal(linearCongGenerator(0, 1103515245, 12345, 2147483648, 1),12345,'<code>linearCongGenerator(0, 1103515245, 12345, 2147483648, 1)</code> should return <code>12345</code>.');"
        },
        {
          "text":
            "'<code>linearCongGenerator(0, 1103515245, 12345, 2147483648, 2)</code> should return <code>1406932606</code>.'",
          "testString":
            "assert.equal(linearCongGenerator(0, 1103515245, 12345, 2147483648, 2),1406932606,'<code>linearCongGenerator(0, 1103515245, 12345, 2147483648, 2)</code> should return <code>1406932606</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7ee3",
      "challengeType": 5,
      "releasedOn": "July 4, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function linearCongGenerator (r0, a, c, m, n) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Long multiplication",
      "description": [
        "Explicitly implement  <a href=\"https://en.wikipedia.org/wiki/long multiplication\">long multiplication</a>.",
        "This is one possible approach to arbitrary-precision integer algebra.",
        "Write a function that takes two strings of large numbers as parameters. Your function should return the product of these two large numbers as a string.",
        "Note: In JavaScript, arithmetic operations are inaccurate with large numbers, so you will have to implement precise multiplication yourself."
      ],
      "solutions": [
        "function mult(strNum1, strNum2) {\n    var a1 = strNum1.split(\"\").reverse();\n    var a2 = strNum2.toString().split(\"\").reverse();\n    var aResult = new Array;\n\n    for ( var iterNum1 = 0; iterNum1 < a1.length; iterNum1++ ) {\n        for ( var iterNum2 = 0; iterNum2 < a2.length; iterNum2++ ) {\n            var idxIter = iterNum1 + iterNum2;    // Get the current array position.\n            aResult[idxIter] = a1[iterNum1] * a2[iterNum2] + ( idxIter >= aResult.length ? 0 : aResult[idxIter] );\n\n            if ( aResult[idxIter] > 9 ) {    // Carrying\n                aResult[idxIter + 1] = Math.floor( aResult[idxIter] / 10 ) + ( idxIter + 1 >= aResult.length ? 0 : aResult[idxIter + 1] );\n                aResult[idxIter] %= 10;\n            }\n        }\n    }\n    return aResult.reverse().join(\"\");\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>mult</code> should be a function.'",
          "testString":
            "assert(typeof mult=='function','<code>mult</code> should be a function.');"
        },
        {
          "text":
            "'<code>mult(\"18446744073709551616\", \"18446744073709551616\")</code> should return a string.'",
          "testString":
            "assert(typeof mult(\"18446744073709551616\", \"18446744073709551616\")=='string','<code>mult(\"18446744073709551616\", \"18446744073709551616\")</code> should return a string.');"
        },
        {
          "text":
            "'<code>mult(\"18446744073709551616\", \"18446744073709551616\")</code> should return <code>\"340282366920938463463374607431768211456\"</code>.'",
          "testString":
            "assert.equal(mult(\"18446744073709551616\", \"18446744073709551616\"),\"340282366920938463463374607431768211456\",'<code>mult(\"18446744073709551616\", \"18446744073709551616\")</code> should return <code>\"340282366920938463463374607431768211456\"</code>.');"
        },
        {
          "text":
            "'<code>mult(\"31844674073709551616\", \"1844674407309551616\")</code> should return <code>\"58743055272886011737990786529368211456\"</code>.'",
          "testString":
            "assert.equal(mult(\"31844674073709551616\", \"1844674407309551616\"),\"58743055272886011737990786529368211456\",'<code>mult(\"31844674073709551616\", \"1844674407309551616\")</code> should return <code>\"58743055272886011737990786529368211456\"</code>.');"
        },
        {
          "text":
            "'<code>mult(\"1846744073709551616\", \"44844644073709551616\")</code> should return <code>\"82816580680737279241781007431768211456\"</code>.'",
          "testString":
            "assert.equal(mult(\"1846744073709551616\", \"44844644073709551616\"),\"82816580680737279241781007431768211456\",'<code>mult(\"1846744073709551616\", \"44844644073709551616\")</code> should return <code>\"82816580680737279241781007431768211456\"</code>.');"
        },
        {
          "text":
            "'<code>mult(\"1844674407370951616\", \"1844674407709551616\")</code> should return <code>\"3402823669833978308014392742590611456\"</code>.'",
          "testString":
            "assert.equal(mult(\"1844674407370951616\", \"1844674407709551616\"),\"3402823669833978308014392742590611456\",'<code>mult(\"1844674407370951616\", \"1844674407709551616\")</code> should return <code>\"3402823669833978308014392742590611456\"</code>.');"
        },
        {
          "text":
            "'<code>mult(\"2844674407370951616\", \"1844674407370955616\")</code> should return <code>\"5247498076580334548376218009219475456\"</code>.'",
          "testString":
            "assert.equal(mult(\"2844674407370951616\", \"1844674407370955616\"),\"5247498076580334548376218009219475456\",'<code>mult(\"2844674407370951616\", \"1844674407370955616\")</code> should return <code>\"5247498076580334548376218009219475456\"</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7eec",
      "challengeType": 5,
      "releasedOn": "July 4, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function mult (strNum1, strNum2) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Longest common subsequence",
      "description": [
        "The <b>longest common subsequence</b> (or <a href=\"http://en.wikipedia.org/wiki/Longest_common_subsequence_problem\"><b>LCS</b></a>) of groups A and B is the longest group of elements from A and B that are common between the two groups and in the same order in each group. For example, the sequences \"1234\" and \"1224533324\" have an LCS of \"1234\":",
        "<b><u>1234</u></b>",
        "<b><u>12</u></b>245<b><u>3</u></b>332<b><u>4</u></b>",
        "For a string example, consider the sequences \"thisisatest\" and \"testing123testing\". An LCS would be \"tsitest\":",
        "<b><u>t</u></b>hi<b><u>si</u></b>sa<b><u>test</u></b>",
        "<b><u>t</u></b>e<b><u>s</u></b>t<b><u>i</u></b>ng123<b><u>test</u></b>ing",
        "In this puzzle, your code only needs to deal with strings. Write a function which returns an LCS of two strings (case-sensitive). You don't need to show multiple LCS's.",
        "For more information on this problem please see <a href=\"https://en.wikipedia.org/wiki/Longest_common_subsequence_problem\">Wikipedia</a>."
      ],
      "solutions": [
        "function lcs (a, b) {\n  var aSub = a.substr(0, a.length - 1);\n  var bSub = b.substr(0, b.length - 1);\n\n  if (a.length === 0 || b.length === 0) {\n    return '';\n  } else if (a.charAt(a.length - 1) === b.charAt(b.length - 1)) {\n    return lcs(aSub, bSub) + a.charAt(a.length - 1);\n  } else {\n    var x = lcs(a, bSub);\n    var y = lcs(aSub, b);\n    return (x.length > y.length) ? x : y;\n  }\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>lcs</code> should be a function.'",
          "testString":
            "assert(typeof lcs=='function','<code>lcs</code> should be a function.');"
        },
        {
          "text":
            "'<code>lcs(\"thisisatest\",\"testing123testing\")</code> should return a string.'",
          "testString":
            "assert(typeof lcs(\"thisisatest\",\"testing123testing\")=='string','<code>lcs(\"thisisatest\",\"testing123testing\")</code> should return a string.');"
        },
        {
          "text":
            "'<code>lcs(\"thisisatest\",\"testing123testing\")</code> should return <code>\"tsitest\"</code>.'",
          "testString":
            "assert.equal(lcs(\"thisisatest\",\"testing123testing\"),\"tsitest\",'<code>lcs(\"thisisatest\",\"testing123testing\")</code> should return <code>\"tsitest\"</code>.');"
        },
        {
          "text":
            "'<code>lcs(\"ABCDGH\",\"AEDFHR\")</code> should return <code>\"ADH\"</code>.'",
          "testString":
            "assert.equal(lcs(\"ABCDGH\",\"AEDFHR\"),\"ADH\",'<code>lcs(\"ABCDGH\",\"AEDFHR\")</code> should return <code>\"ADH\"</code>.');"
        },
        {
          "text":
            "'<code>lcs(\"AGGTAB\",\"GXTXAYB\")</code> should return <code>\"GTAB\"</code>.'",
          "testString":
            "assert.equal(lcs(\"AGGTAB\",\"GXTXAYB\"),\"GTAB\",'<code>lcs(\"AGGTAB\",\"GXTXAYB\")</code> should return <code>\"GTAB\"</code>.');"
        },
        {
          "text":
            "'<code>lcs(\"BACDB\",\"BDCB\")</code> should return <code>\"BCB\"</code>.'",
          "testString":
            "assert.equal(lcs(\"BACDB\",\"BDCB\"),\"BCB\",'<code>lcs(\"BACDB\",\"BDCB\")</code> should return <code>\"BCB\"</code>.');"
        },
        {
          "text":
            "'<code>lcs(\"ABAZDC\",\"BACBAD\")</code> should return <code>\"ABAD\"</code>.'",
          "testString":
            "assert.equal(lcs(\"ABAZDC\",\"BACBAD\"),\"ABAD\",'<code>lcs(\"ABAZDC\",\"BACBAD\")</code> should return <code>\"ABAD\"</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7ee9",
      "challengeType": 5,
      "releasedOn": "July 4, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function lcs (a, b) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Longest increasing subsequence",
      "description": [
        "Calculate and show here a <a href=\"https://en.wikipedia.org/wiki/Longest increasing subsequence\">longest increasing subsequence</a> of the list:",
        "$\\{3, 2, 6, 4, 5, 1\\}$",
        "And of the list:",
        "$\\{0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15\\}$",
        "Write a function that takes an array of numbers as a parameter and returns the longest increasing subsequence."
      ],
      "solutions": [
        "function findSequence (input) {\n\tvar len = input.length;\n\tvar result = []\n  for(var i=0;i<len;i++) result.push(1)\n\n\tfor(var i=0; i<len; i++)\n\t\tfor(var j=i-1;j>=0;j--)\n\t\t\tif(input[i] > input[j] && result[j] >= result[i])\n\t\t\t\tresult[i] = result[j]+1;\n\n\tvar maxValue = Math.max.apply(null, result);\n\tvar maxIndex = result.indexOf(Math.max.apply(Math, result));\n\tvar output = [];\n\toutput.push(input[maxIndex]);\n\tfor(var i = maxIndex ; i >= 0; i--){\n\t\tif(maxValue==0)break;\n\t\tif(input[maxIndex] > input[i]  && result[i] == maxValue-1){\n\t\t\toutput.push(input[i]);\n\t\t\tmaxValue--;\n\t\t}\n\t}\n\toutput.reverse();\n\treturn output;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>findSequence</code> should be a function.'",
          "testString":
            "assert(typeof findSequence=='function','<code>findSequence</code> should be a function.');"
        },
        {
          "text":
            "'<code>findSequence('+JSON.stringify(tests[0])+')</code> should return a array.'",
          "testString":
            "assert(Array.isArray(findSequence(tests[0])),'<code>findSequence('+JSON.stringify(tests[0])+')</code> should return a array.');"
        },
        {
          "text":
            "'<code>findSequence('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(findSequence(tests[0]),results[0],'<code>findSequence('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>findSequence('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(findSequence(tests[1]),results[1],'<code>findSequence('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>findSequence('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(findSequence(tests[2]),results[2],'<code>findSequence('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>findSequence('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(findSequence(tests[3]),results[3],'<code>findSequence('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>findSequence('+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(findSequence(tests[4]),results[4],'<code>findSequence('+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7eea",
      "challengeType": 5,
      "releasedOn": "July 4, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function findSequence (input) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var tests=[[3,10,2,1,20],",
            "[2,4,7,3,5,8],",
            "[3,2,6,4,5,1],",
            "[10,22,9,33,21,50,60,80],",
            "[0,7,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15]]",
            "var results=[[3,10,20],",
            "[2,3,5,8],",
            "[2,4,5],",
            "[10,22,33,50,60,80],",
            "[0,2,6,9,11,15]]"
          ]
        }
      }
    },
    {
      "title": "Longest string challenge",
      "description": [
        "Write a function that takes an array of strings and returns the strings that have length equal to the longest length."
      ],
      "solutions": [
        "function longestString (strings) {\n  var mx=0;\n  var result=[]\n  strings.forEach(function (e) {\n    if(e.length>mx){\n      mx=e.length\n      result=[e]\n    }else if(e.length==mx)\n      result.push(e)\n  })\n\n  return result\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>longestString</code> should be a function.'",
          "testString":
            "assert(typeof longestString=='function','<code>longestString</code> should be a function.');"
        },
        {
          "text":
            "'<code>longestString('+JSON.stringify(tests[0])+')</code> should return a array.'",
          "testString":
            "assert(Array.isArray(longestString(tests[0])),'<code>longestString('+JSON.stringify(tests[0])+')</code> should return a array.');"
        },
        {
          "text":
            "'<code>longestString('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(longestString(tests[0]),results[0],'<code>longestString('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>longestString('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(longestString(tests[1]),results[1],'<code>longestString('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>longestString('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(longestString(tests[2]),results[2],'<code>longestString('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>longestString('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(longestString(tests[3]),results[3],'<code>longestString('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>longestString('+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(longestString(tests[4]),results[4],'<code>longestString('+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7eeb",
      "challengeType": 5,
      "releasedOn": "July 4, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function longestString (strings) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var tests=[",
            "[\"a\",\"bb\",\"ccc\",\"ee\",\"f\",\"ggg\"],",
            "[\"afedg\",\"bb\",\"sdccc\",\"efdee\",\"f\",\"geegg\"],",
            "[\"a\",\"bhghgb\",\"ccc\",\"efde\",\"fssdrr\",\"ggg\"],",
            "[\"ahgfhg\",\"bdsfsb\",\"ccc\",\"ee\",\"f\",\"ggdsfg\"],",
            "[\"a\",\"bbdsf\",\"ccc\",\"edfe\",\"gzzzgg\"]]",
            "var results=[",
            "[\"ccc\",\"ggg\"],",
            "[\"afedg\",\"sdccc\",\"efdee\",\"geegg\"],",
            "[\"bhghgb\",\"fssdrr\"],",
            "[\"ahgfhg\",\"bdsfsb\",\"ggdsfg\"],",
            "[\"gzzzgg\"]]"
          ]
        }
      }
    },
    {
      "title": "Look-and-say sequence",
      "description": [
        "The  <a href=\"https://en.wikipedia.org/wiki/Look and say sequence\">Look and say sequence</a>  is a recursively defined sequence of numbers studied most notably by  <a href=\"https://en.wikipedia.org/wiki/John Horton Conway\">John Conway</a>.",
        "Sequence Definition",
        "<ul><li>Take a decimal number</li>",
        "<li><span>Look</span> at the number, visually grouping consecutive runs of the same digit.</li>",
        "<li><span>Say</span> the number, from left to right, group by group; as how many of that digit there are - followed by the digit grouped.</li></ul><span> This becomes the next number of the sequence.</span>",
        "<span>An example:</span>",
        "<ul><li>Starting with the number 1,  you have <span>one</span> 1 which produces 11</li>",
        "<li>Starting with 11,  you have <span>two</span> 1's.  I.E.:  21</li>",
        "<li>Starting with 21,  you have <span>one</span> 2, then <span>one</span> 1.  I.E.:  (12)(11) which becomes 1211</li>",
        "<li>Starting with 1211,  you have <span>one</span> 1, <span>one</span> 2, then <span>two</span> 1's.  I.E.:  (11)(12)(21) which becomes 111221</li></ul>",
        "Write a function that takes a string as parameter. This string has the number that should be processed as mentioned above. The function should return the resultant string."
      ],
      "solutions": [
        "function lookAndSay (str) {\n    return str.replace(/(.)\\1*/g, function(seq, p1){return seq.length.toString() + p1})\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>lookAndSay</code> should be a function.'",
          "testString":
            "assert(typeof lookAndSay=='function','<code>lookAndSay</code> should be a function.');"
        },
        {
          "text": "'<code>lookAndSay(\"1\")</code> should return a string.'",
          "testString":
            "assert(typeof lookAndSay(\"1\") == 'string','<code>lookAndSay(\"1\")</code> should return a string.');"
        },
        {
          "text":
            "'<code>lookAndSay(\"1\")</code> should return <code>\"11\"</code>.'",
          "testString":
            "assert.equal(lookAndSay(\"1\"),\"11\",'<code>lookAndSay(\"1\")</code> should return <code>\"11\"</code>.');"
        },
        {
          "text":
            "'<code>lookAndSay(\"11\")</code> should return <code>\"21\"</code>.'",
          "testString":
            "assert.equal(lookAndSay(\"11\"),\"21\",'<code>lookAndSay(\"11\")</code> should return <code>\"21\"</code>.');"
        },
        {
          "text":
            "'<code>lookAndSay(\"21\")</code> should return <code>\"1211\"</code>.'",
          "testString":
            "assert.equal(lookAndSay(\"21\"),\"1211\",'<code>lookAndSay(\"21\")</code> should return <code>\"1211\"</code>.');"
        },
        {
          "text":
            "'<code>lookAndSay(\"1211\")</code> should return <code>\"111221\"</code>.'",
          "testString":
            "assert.equal(lookAndSay(\"1211\"),\"111221\",'<code>lookAndSay(\"1211\")</code> should return <code>\"111221\"</code>.');"
        },
        {
          "text":
            "'<code>lookAndSay(\"3542\")</code> should return <code>\"13151412\"</code>.'",
          "testString":
            "assert.equal(lookAndSay(\"3542\"),\"13151412\",'<code>lookAndSay(\"3542\")</code> should return <code>\"13151412\"</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7eed",
      "challengeType": 5,
      "releasedOn": "July 10, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function lookAndSay (str) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Loop over multiple arrays simultaneously",
      "description": [
        "Loop over multiple arrays and create a new array whose $i^{th}$ element is the concatenation of $i^{th}$  element of each of the given.",
        "For this example, if you are given this array of arrays:",
        "<code>[ [\"a\",\"b\",\"c\"],[\"A\",\"B\",\"C\"],[1,2,3] ]</code>",
        "the output should be:",
        "<code>[\"aA1\",\"bB2\",\"cC3\"]</code>"
      ],
      "solutions": [
        "function loopSimult (A) {\n  var res=[],output\n  for (var i = 0; i < A[0].length; i += 1) {\n    output=\"\"\n    for(var j=0;j<A.length;j++)\n      output += A[j][i];\n    res.push(output)\n  }\n  return res\n}\n\n"
      ],
      "tests": [
        {
          "text": "'<code>loopSimult</code> should be a function.'",
          "testString":
            "assert(typeof loopSimult=='function','<code>loopSimult</code> should be a function.');"
        },
        {
          "text":
            "'<code>loopSimult('+JSON.stringify(tests[0])+')</code> should return a array.'",
          "testString":
            "assert(Array.isArray(loopSimult(tests[0])),'<code>loopSimult('+JSON.stringify(tests[0])+')</code> should return a array.');"
        },
        {
          "text":
            "'<code>loopSimult('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(loopSimult(tests[0]),results[0],'<code>loopSimult('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>loopSimult('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(loopSimult(tests[1]),results[1],'<code>loopSimult('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>loopSimult('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(loopSimult(tests[2]),results[2],'<code>loopSimult('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>loopSimult('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(loopSimult(tests[3]),results[3],'<code>loopSimult('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>loopSimult('+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(loopSimult(tests[4]),results[4],'<code>loopSimult('+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7eee",
      "challengeType": 5,
      "releasedOn": "July 10, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function loopSimult (A) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "var tests=[",
            "[[\"a\",\"b\",\"c\"],[\"A\",\"B\",\"C\"],[1,2,3]],",
            "[[\"c\",\"b\",\"c\"],[\"4\",\"5\",\"C\"],[7,7,3]],",
            "[[\"a\",\"b\",\"c\",\"d\"],[\"A\",\"B\",\"C\",\"d\"],[1,2,3,4]],",
            "[[\"a\",\"b\"],[\"A\",\"B\"],[1,2]],",
            "[[\"b\",\"c\"],[\"B\",\"C\"],[2,3]]]",
            "var results=[",
            "[\"aA1\",\"bB2\",\"cC3\"],",
            "[\"c47\",\"b57\",\"cC3\"],",
            "[\"aA1\",\"bB2\",\"cC3\",\"dd4\"],",
            "[\"aA1\",\"bB2\"],",
            "[\"bB2\",\"cC3\"]]"
          ]
        }
      }
    },
    {
      "title": "LU decomposition",
      "description": [
        "Every square matrix $A$ can be decomposed into a product of a lower triangular matrix $L$ and a upper triangular matrix $U$, as described in <a href=\"https://en.wikipedia.org/wiki/LU decomposition\">LU decomposition</a>.",
        "$A = LU$",
        "It is a modified form of Gaussian elimination.",
        "While the <a href=\"http://rosettacode.org/wiki/Cholesky decomposition\">Cholesky decomposition</a> only works for symmetric, positive definite matrices, the more general LU decomposition works for any square matrix.",
        "There are several algorithms for calculating $L$ and $U$.",
        "To derive <i>Crout's algorithm</i> for a 3x3 example, we have to solve the following system:",
        "\\begin{align}A = \\begin{pmatrix} a_{11} & a_{12} & a_{13}\\\\ a_{21} & a_{22} & a_{23}\\\\ a_{31} & a_{32} & a_{33}\\\\ \\end{pmatrix}= \\begin{pmatrix} l_{11} & 0 & 0 \\\\ l_{21} & l_{22} & 0 \\\\ l_{31} & l_{32} & l_{33}\\\\ \\end{pmatrix} \\begin{pmatrix} u_{11} & u_{12} & u_{13} \\\\ 0 & u_{22} & u_{23} \\\\ 0 & 0 & u_{33} \\end{pmatrix} = LU\\end{align}",
        "We now would have to solve 9 equations with 12 unknowns. To make the system uniquely solvable, usually the diagonal elements of $L$ are set to 1",
        "$l_{11}=1$",
        "$l_{22}=1$",
        "$l_{33}=1$",
        "so we get a solvable system of 9 unknowns and 9 equations.",
        "\\begin{align}A = \\begin{pmatrix} a_{11} & a_{12} & a_{13}\\\\ a_{21} & a_{22} & a_{23}\\\\ a_{31} & a_{32} & a_{33}\\\\ \\end{pmatrix} = \\begin{pmatrix} 1      & 0      & 0 \\\\ l_{21} & 1      & 0 \\\\ l_{31} & l_{32} & 1\\\\ \\end{pmatrix} \\begin{pmatrix} u_{11} & u_{12} & u_{13} \\\\ 0 & u_{22} & u_{23} \\\\ 0 & 0 & u_{33} \\end{pmatrix} = \\begin{pmatrix} u_{11}        & u_{12}                    & u_{13}              \\\\ u_{11}l_{21}  & u_{12}l_{21}+u_{22}       & u_{13}l_{21}+u_{23} \\\\ u_{11}l_{31}  & u_{12}l_{31}+u_{22}l_{32} & u_{13}l_{31} + u_{23}l_{32}+u_{33} \\end{pmatrix} = LU\\end{align}",
        "Solving for the other $l$ and $u$, we get the following equations:",
        "$u_{11}=a_{11}$",
        "$u_{12}=a_{12}$",
        "$u_{13}=a_{13}$",
        "$u_{22}=a_{22} - u_{12}l_{21}$",
        "$u_{23}=a_{23} - u_{13}l_{21}$",
        "$u_{33}=a_{33} - (u_{13}l_{31} + u_{23}l_{32})$",
        "and for $l$:",
        "$l_{21}=\\frac{1}{u_{11}} a_{21}$",
        "$l_{31}=\\frac{1}{u_{11}} a_{31}$",
        "$l_{32}=\\frac{1}{u_{22}} (a_{32} - u_{12}l_{31})$",
        "We see that there is a calculation pattern, which can be expressed as the following formulas, first for $U$",
        "$u_{ij} = a_{ij} - \\sum_{k=1}^{i-1} u_{kj}l_{ik}$",
        "and then for $L$",
        "$l_{ij} = \\frac{1}{u_{jj}} (a_{ij} - \\sum_{k=1}^{j-1} u_{kj}l_{ik})$",
        "We see in the second formula that to get the $l_{ij}$ below the diagonal, we have to divide by the diagonal element (pivot) $u_{jj}$, so we get problems when $u_{jj}$ is either 0 or very small, which leads to numerical instability.",
        "The solution to this problem is <i>pivoting</i> $A$, which means rearranging the rows of $A$, prior to the $LU$ decomposition, in a way that the largest element of each column gets onto the diagonal of $A$. Rearranging the rows means to multiply $A$ by a permutation matrix $P$:",
        "$PA \\Rightarrow A'$",
        "Example:",
        "\\begin{align} \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix} \\begin{pmatrix} 1 & 4 \\\\ 2 & 3 \\end{pmatrix} \\Rightarrow \\begin{pmatrix} 2 & 3 \\\\ 1 & 4 \\end{pmatrix} \\end{align}",
        "The decomposition algorithm is then applied on the rearranged matrix so that",
        "$PA = LU$",
        "<b>Task description</b>",
        "The task is to implement a routine which will take a square nxn matrix $A$ and return a lower triangular matrix $L$, a upper triangular matrix $U$ and a permutation matrix $P$, so that the above equation is fullfilled. The returned value should be in the form <code>[L,U,P]</code>."
      ],
      "solutions": [
        "function luDecomposition (A) {\n\n  function dotProduct(a,b) {\n    var sum=0;\n    for(var i=0;i<a.length;i++)\n      sum+=a[i]*b[i]\n    return sum;\n  }\n\n  function matrixMul(A,B) {\n    var result=new Array(A.length);\n    for(var i=0;i<A.length;i++)\n      result[i]=new Array(B[0].length)\n    var aux = new Array(B.length);\n\n    for (var j = 0; j < B[0].length; j++) {\n\n        for (var k = 0; k < B.length; k++)\n            aux[k] = B[k][j];\n\n        for (var i = 0; i < A.length; i++)\n            result[i][j] = dotProduct(A[i], aux);\n    }\n    return result;\n  }\n\n  function pivotize(m) {\n    var n = m.length;\n    var id=new Array(n);\n    for(var i=0;i<n;i++){\n      id[i]=new Array(n);\n      id[i].fill(0)\n      id[i][i]=1;\n    }\n\n    for (var i = 0; i < n; i++) {\n        var maxm = m[i][i];\n        var row = i;\n        for (var j = i; j < n; j++)\n            if (m[j][i] > maxm) {\n                maxm = m[j][i];\n                row = j;\n            }\n\n        if (i != row) {\n            var tmp = id[i];\n            id[i] = id[row];\n            id[row] = tmp;\n        }\n    }\n    return id;\n  }\n\n  var n = A.length;\n  var L=new Array(n);\n  for(var i=0;i<n;i++){ L[i]=new Array(n); L[i].fill(0) }\n  var U=new Array(n);\n  for(var i=0;i<n;i++){ U[i]=new Array(n); U[i].fill(0) }\n  var P = pivotize(A);\n  var A2 = matrixMul(P, A);\n\n  for (var j = 0; j < n; j++) {\n      L[j][j] = 1;\n      for (var i = 0; i < j + 1; i++) {\n          var s1 = 0;\n          for (var k = 0; k < i; k++)\n              s1 += U[k][j] * L[i][k];\n          U[i][j] = A2[i][j] - s1;\n      }\n      for (var i = j; i < n; i++) {\n          var s2 = 0;\n          for (var k = 0; k < j; k++)\n              s2 += U[k][j] * L[i][k];\n          L[i][j] = (A2[i][j] - s2) / U[j][j];\n      }\n  }\n  return [L, U, P];\n}\n\n"
      ],
      "tests": [
        {
          "text": "'<code>luDecomposition</code> should be a function.'",
          "testString":
            "assert(typeof luDecomposition=='function','<code>luDecomposition</code> should be a function.');"
        },
        {
          "text":
            "'<code>luDecomposition('+JSON.stringify(tests[0])+')</code> should return a array.'",
          "testString":
            "assert(Array.isArray(luDecomposition(tests[0])),'<code>luDecomposition('+JSON.stringify(tests[0])+')</code> should return a array.');"
        },
        {
          "text":
            "'<code>luDecomposition('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(luDecomposition(tests[0]),results[0],'<code>luDecomposition('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>luDecomposition('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(luDecomposition(tests[1]),results[1],'<code>luDecomposition('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>luDecomposition('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(luDecomposition(tests[2]),results[2],'<code>luDecomposition('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>luDecomposition('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(luDecomposition(tests[3]),results[3],'<code>luDecomposition('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7efb",
      "challengeType": 5,
      "releasedOn": "July 10, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function luDecomposition (A) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var tests=[",
            "[[1,3,5],[2,4,7],[1,1,0]],",
            "[[11,9,24,2],[1,5,2,6],[3,17,18,1],[2,5,7,1]],",
            "[[1,1,1],[4,3,-1],[3,5,3]],",
            "[[1,-2,3],[2,-5,12],[0,2,-10]]]",
            "var results=[",
            "[[[1,0,0],[0.5,1,0],[0.5,-1,1]],[[2,4,7],[0,1,1.5],[0,0,-2]],[[0,1,0],[1,0,0],[0,0,1]]],",
            "[[[1,0,0,0],[0.2727272727272727,1,0,0],[0.09090909090909091,0.2875,1,0],[0.18181818181818182,0.23124999999999996,0.0035971223021580693,1]],[[11,9,24,2],[0,14.545454545454547,11.454545454545455,0.4545454545454546],[0,0,-3.4749999999999996,5.6875],[0,0,0,0.510791366906476]],[[1,0,0,0],[0,0,1,0],[0,1,0,0],[0,0,0,1]]],",
            "[[[1,0,0],[0.75,1,0],[0.25,0.09090909090909091,1]],[[4,3,-1],[0,2.75,3.75],[0,0,0.9090909090909091]],[[0,1,0],[0,0,1],[1,0,0]]],",
            "[[[1,0,0],[0,1,0],[0.5,0.25,1]],[[2,-5,12],[0,2,-10],[0,0,-0.5]],[[0,1,0],[0,0,1],[1,0,0]]]]"
          ]
        }
      }
    },
    {
      "title": "Lucas-Lehmer test",
      "description": [
        "Lucas-Lehmer Test: for $p$ an odd prime, the Mersenne number $2^p-1$ is prime if and only if $2^p-1$ divides $S(p-1)$ where $S(n+1)=(S(n))^2-2$, and $S(1)=4$.",
        "Write a function that returns true if given Mersenne number is prime otherwise returns false."
      ],
      "solutions": [
        "function lucasLehmer (p) {\n  function isPrime(p) {\n    if (p == 2)\n      return true;\n    else if (p <= 1 || p % 2 == 0)\n      return false;\n    else {\n      var to = Math.sqrt(p);\n      for (var i = 3; i <= to; i += 2)\n        if (p % i == 0)\n          return false;\n      return true;\n    }\n  }\n\n  function isMersennePrime(p) {\n    if (p == 2)\n      return true;\n    else {\n      var m_p = Math.pow(2,p)-1\n      var s = 4;\n      for (var i = 3; i <= p; i++)\n        s = (s*s - 2) %m_p\n      return s==0;\n    }\n  }\n\n  return isPrime(p) && isMersennePrime(p)\n}\n\n"
      ],
      "tests": [
        {
          "text": "'<code>lucasLehmer</code> should be a function.'",
          "testString":
            "assert(typeof lucasLehmer=='function','<code>lucasLehmer</code> should be a function.');"
        },
        {
          "text": "'<code>lucasLehmer(11)</code> should return a boolean.'",
          "testString":
            "assert(typeof lucasLehmer(11) == 'boolean','<code>lucasLehmer(11)</code> should return a boolean.');"
        },
        {
          "text":
            "'<code>lucasLehmer(11)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(lucasLehmer(11),false,'<code>lucasLehmer(11)</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>lucasLehmer(15)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(lucasLehmer(15),false,'<code>lucasLehmer(15)</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>lucasLehmer(13)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(lucasLehmer(13),true,'<code>lucasLehmer(13)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>lucasLehmer(17)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(lucasLehmer(17),true,'<code>lucasLehmer(17)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>lucasLehmer(19)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(lucasLehmer(19),true,'<code>lucasLehmer(19)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>lucasLehmer(21)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(lucasLehmer(21),false,'<code>lucasLehmer(21)</code> should return <code>false</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7efa",
      "challengeType": 5,
      "releasedOn": "July 10, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function lucasLehmer (p) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Ludic numbers",
      "description": [
        "<a href=\"https://oeis.org/wiki/Ludic_numbers\">Ludic numbers</a>  are related to prime numbers as they are generated by a sieve quite like the <a href=\"http://rosettacode.org/wiki/Sieve of Eratosthenes\">Sieve of Eratosthenes</a> is used to generate prime numbers.",
        "The first ludic number is  <span style=\"color:blue;font-weight:bold\">1</span>.",
        "To generate succeeding ludic numbers create an array of increasing integers starting from  <span style=\"color:blue;font-weight:bold\">2</span>.",
        "<code><span style=\"color:blue;font-weight:bold\">2</span> 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ...</code>",
        "(Loop)",
        "<ul><li>Take the first member of the resultant array as the next ludic number  <span style=\"color:blue;font-weight:bold\">2</span>.</li>",
        "<li>Remove every  <span>2<sup>nd</sup></span>  indexed item from the array (including the first).</li></ul><span>:<code><span style=\"color:blue;font-weight:bold\"><s>2</s></span> 3 <s>4</s> 5 <s>6</s> 7 <s>8</s> 9 <s>10</s> 11 <s>12</s> 13 <s>14</s> 15 <s>16</s> 17 <s>18</s> 19 <s>20</s> 21 <s>22</s> 23 <s>24</s> 25 <s>26</s> ...</code></span>",
        "<ul><li>(Unrolling a few loops...)</li>",
        "<li>Take the first member of the resultant array as the next ludic number  <span style=\"color:blue;font-weight:bold\">3</span>.</li>",
        "<li>Remove every  <span>3<sup>rd</sup></span>  indexed item from the array (including the first).</li></ul><span>:<code><span style=\"color:blue;font-weight:bold\"><s>3</s></span> 5 7 <s>9</s> 11 13 <s>15</s> 17 19 <s>21</s> 23 25 <s>27</s> 29 31 <s>33</s> 35 37 <s>39</s> 41 43 <s>45</s> 47 49 <s>51</s> ...</code></span>",
        "<ul><li>Take the first member of the resultant array as the next ludic number  <span style=\"color:blue;font-weight:bold\">5</span>.</li>",
        "<li>Remove every  <span>5<sup>th</sup></span>  indexed item from the array (including the first).</li></ul><span>:<code><span style=\"color:blue;font-weight:bold\"><s>5</s></span> 7 11 13 17 <s>19</s> 23 25 29 31 <s>35</s> 37 41 43 47 <s>49</s> 53 55 59 61 <s>65</s> 67 71 73 77 ...</code></span>",
        "<ul><li>Take the first member of the resultant array as the next ludic number  <span style=\"color:blue;font-weight:bold\">7</span>.</li>",
        "<li>Remove every  <span>7<sup>th</sup></span>  indexed item from the array (including the first).</li></ul><span>:<code><span style=\"color:blue;font-weight:bold\"><s>7</s></span> 11 13 17 23 25 29 <s>31</s> 37 41 43 47 53 55 <s>59</s> 61 67 71 73 77 83 <s>85</s> 89 91 97 ...</code></span>",
        "<ul><li><big><b> ... </b></big></li>",
        "<li>Take the first member of the current array as the next ludic number  <span style=\"color:blue;font-weight:bold\">L</span>.</li>",
        "<li>Remove every  <span>L<sup>th</sup></span>  indexed item from the array (including the first).</li>",
        "<li><big><b> ... </b></big></li></ul>",
        "Write a function that returns all the ludic numbers that do not exceed the given number."
      ],
      "solutions": [
        "function ludic (n) {\n  const makeArr = (s, e) => new Array(e + 1 - s).fill(s).map((e, i) => e + i);\n\n  const filterAtInc = (arr, n) => arr.filter((e, i) => (i + 1) % n);\n\n  const makeLudic = (arr, result) => {\n    const iter = arr.shift();\n    result.push(iter);\n    return arr.length ? makeLudic(filterAtInc(arr, iter), result) : result;\n  };\n\n  const ludicResult = makeLudic(makeArr(2, n), [1]);\n\n  return ludicResult\n}\n\n"
      ],
      "tests": [
        {
          "text": "'<code>ludic</code> should be a function.'",
          "testString":
            "assert(typeof ludic=='function','<code>ludic</code> should be a function.');"
        },
        {
          "text": "'<code>ludic(2)</code> should return a array.'",
          "testString":
            "assert(Array.isArray(ludic(2)),'<code>ludic(2)</code> should return a array.');"
        },
        {
          "text":
            "'<code>ludic(2)</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(ludic(2),results[0],'<code>ludic(2)</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>ludic(3)</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(ludic(3),results[1],'<code>ludic(3)</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>ludic(5)</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(ludic(5),results[2],'<code>ludic(5)</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>ludic(20)</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(ludic(20),results[3],'<code>ludic(20)</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>ludic(26)</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(ludic(26),results[4],'<code>ludic(26)</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7efc",
      "challengeType": 5,
      "releasedOn": "July 10, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function ludic (n) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "var results=[",
            "[1,2],",
            "[1,2,3],",
            "[1,2,3,5],",
            "[1,2,3,5,7,11,13,17],",
            "[1,2,3,5,7,11,13,17,23,25]]"
          ]
        }
      }
    },
    {
      "title": "Luhn test of credit card numbers",
      "description": [
        "The <a href=\"https://en.wikipedia.org/wiki/Luhn algorithm\">Luhn test</a> is used by some credit card companies to distinguish valid credit card numbers from what could be a random selection of digits.",
        "Those companies using credit card numbers that can be validated by the Luhn test have numbers that pass the following test:",
        "<ol><li> Reverse the order of the digits in the number.</li>",
        "<li> Take the first, third, ... and every other odd digit in the reversed digits and sum them to form the partial sum s1</li>",
        "<li> Taking the second, fourth ... and every other even digit in the reversed digits:</li></ol>",
        "#  Multiply each digit by two and sum the digits if the answer is greater than nine to form partial sums for the even digits",
        "#  Sum the partial sums of the even digits to form s2",
        "If s1 + s2 ends in zero then the original number is in the form of a valid credit card number as verified by the Luhn test.",
        "///",
        "For example, if the trial number is 49927398716:",
        "Reverse the digits:",
        "61789372994",
        "Sum the odd digits:",
        "6 + 7 + 9 + 7 + 9 + 4 = 42 = s1",
        "The even digits:",
        "1,  8,  3,  2,  9",
        "Two times each even digit:",
        "2, 16,  6,  4, 18",
        "Sum the digits of each multiplication:",
        "2,  7,  6,  4,  9",
        "Sum the last:",
        "2 + 7 + 6 + 4 + 9 = 28 = s2s1 + s2 = 70 which ends in zero which means that 49927398716 passes the Luhn test",
        "Write a function that will validate a number with the Luhn test. Return true if it's a valid number. Otherwise, return false."
      ],
      "solutions": [
        "function luhnTest (str) {\n\tvar luhnArr = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9];\n  var counter = 0;\n  var incNum;\n  var odd = false;\n  var temp = String(str).replace(/[^\\d]/g, \"\");\n  if (temp.length == 0)\n    return false;\n  for (var i = temp.length - 1; i >= 0; --i) {\n    incNum = parseInt(temp.charAt(i), 10);\n    counter += (odd = !odd) ? incNum : luhnArr[incNum];\n  }\n  return (counter % 10 == 0);\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>luhnTest</code> should be a function.'",
          "testString":
            "assert(typeof luhnTest=='function','<code>luhnTest</code> should be a function.');"
        },
        {
          "text":
            "'<code>luhnTest(\"4111111111111111\")</code> should return a boolean.'",
          "testString":
            "assert(typeof luhnTest(\"4111111111111111\") == 'boolean','<code>luhnTest(\"4111111111111111\")</code> should return a boolean.');"
        },
        {
          "text":
            "'<code>luhnTest(\"4111111111111111\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(luhnTest(\"4111111111111111\"),true,'<code>luhnTest(\"4111111111111111\")</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>luhnTest(\"4111111111111112\")</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(luhnTest(\"4111111111111112\"),false,'<code>luhnTest(\"4111111111111112\")</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>luhnTest(\"49927398716\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(luhnTest(\"49927398716\"),true,'<code>luhnTest(\"49927398716\")</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>luhnTest(\"49927398717\")</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(luhnTest(\"49927398717\"),false,'<code>luhnTest(\"49927398717\")</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>luhnTest(\"1234567812345678\")</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(luhnTest(\"1234567812345678\"),false,'<code>luhnTest(\"1234567812345678\")</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>luhnTest(\"1234567812345670\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(luhnTest(\"1234567812345670\"),true,'<code>luhnTest(\"1234567812345670\")</code> should return <code>true</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7efd",
      "challengeType": 5,
      "releasedOn": "July 10, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function luhnTest (str) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Lychrel numbers",
      "description": [
        "<ol><li>Take an integer n, greater than zero.</li>",
        "<li>Form the next n of its series by reversing the digits of the current n and adding the result to the current n.</li>",
        "<li>Stop when n becomes palindromic - i.e. the digits of n in reverse order == n.</li></ol>",
        "The above recurrence relation when applied to most starting numbers n = 1, 2, ... terminates in a palindrome quite quickly, for example if n<sub>0</sub> = 12 we get",
        "12",
        "12 + 21 = 33, a palindrome!",
        "And if n<sub>0</sub> = 55 we get",
        "55",
        "55 + 55 = 110",
        "110 + 011 = 121, a palindrome!",
        "Notice that the check for a palindrome happens <i>after</i> an addition.",
        "Some starting numbers seem to go on forever; the recurrence relation for 196 has been calculated for millions of repetitions forming numbers with millions of digits, without forming a palindrome. These numbers that do not end in a palindrome are called <b>Lychrel numbers</b>.",
        "For the purposes of this task a Lychrel number is any starting number that does not form a palindrome within 500 (or more) iterations.",
        "Seed and related Lychrel numbers:>",
        "Any integer produced in the sequence of a Lychrel number is also a Lychrel number.",
        "In general, any sequence from one Lychrel number <i>might</i> converge to join the sequence from a prior Lychrel number candidate; for example the sequences for the numbers 196 and then 689 begin:",
        "196",
        "196 + 691 = 887",
        "887 + 788 = 1675",
        "1675 + 5761 = 7436",
        "7436 + 6347 = 13783",
        "13783 + 38731 = 52514",
        "52514 + 41525 = 94039",
        "...",
        "689",
        "689 + 986 = 1675",
        "1675 + 5761 = 7436",
        "...",
        "So we see that the sequence starting with 689 converges to, and continues with the same numbers as that for 196. Because of this we can further split the Lychrel numbers into true <b>Seed</b> Lychrel number candidates, and <b>Related</b> numbers that produce no palindromes but have integers in their sequence seen as part of the sequence generated from a lower Lychrel number.",
        "Write a function that takes a number as a parameter. Return true if the number is a Lynchrel number. Otherwise, return false. The iteration limit is 500."
      ],
      "solutions": [
        "function isLychrel (n) {\n  function reverse(num) {\n    return parseInt(num.toString().split('').reverse().join(''))\n  }\n\n  var i;\n  for (i = 0; i < 500; i++) {\n    n = n + reverse(n)\n    if (n == reverse(n))\n      break\n  }\n\n  return i == 500\n}\n"
      ],
      "tests": [
        {
          "text":
            "assert(typeof isLychrel == 'function', '<code>isLychrel</code> should be a function.'",
          "testString":
            "assert(typeof isLychrel == 'function', '<code>isLychrel</code> should be a function.');"
        },
        {
          "text":
            "assert(typeof isLychrel(12) == 'boolean', '<code>isLychrel(12)</code> should return a boolean.'",
          "testString":
            "assert(typeof isLychrel(12) == 'boolean', '<code>isLychrel(12)</code> should return a boolean.');"
        },
        {
          "text":
            "assert.equal(isLychrel(12), false, '<code>isLychrel(12)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isLychrel(12), false, '<code>isLychrel(12)</code> should return <code>false</code>.');"
        },
        {
          "text":
            "assert.equal(isLychrel(55), false, '<code>isLychrel(55)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isLychrel(55), false, '<code>isLychrel(55)</code> should return <code>false</code>.');"
        },
        {
          "text":
            "assert.equal(isLychrel(196), true, '<code>isLychrel(196)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isLychrel(196), true, '<code>isLychrel(196)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "assert.equal(isLychrel(879), true, '<code>isLychrel(879)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isLychrel(879), true, '<code>isLychrel(879)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "assert.equal(isLychrel(44987), false, '<code>isLychrel(44987)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isLychrel(44987), false, '<code>isLychrel(44987)</code> should return <code>false</code>.');"
        },
        {
          "text":
            "assert.equal(isLychrel(7059), true, '<code>isLychrel(7059)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isLychrel(7059), true, '<code>isLychrel(7059)</code> should return <code>true</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7efe",
      "challengeType": 5,
      "releasedOn": "July 10, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function isLychrel (n) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "LZW compression",
      "description": [
        "The Lempel-Ziv-Welch (LZW) algorithm provides loss-less data compression.",
        "You can read a complete description of it in the  <a href=\"https://en.wikipedia.org/wiki/Lempel-Ziv-Welch\">Wikipedia article</a>  on the subject.  It was patented, but it entered the public domain in 2004.",
        "Write a function that takes two parameters. The first parameter is a boolean. True indicates compress and false indicates decompress. The second parameter is either a string or an array to be compressed or decompressed, respectively. If it is a string to be compressed, return an array of numbers. If it's an array of numbers to be decompressed, return a string."
      ],
      "solutions": [
        "function LZW (compressData, input) {\n  function compress(uncompressed) {\n    // Build the dictionary.\n    var i,\n      dictionary = {},\n      c,\n      wc,\n      w = \"\",\n      result = [],\n      dictSize = 256;\n    for (i = 0; i < 256; i += 1) {\n      dictionary[String.fromCharCode(i)] = i;\n    }\n\n    for (i = 0; i < uncompressed.length; i += 1) {\n      c = uncompressed.charAt(i);\n      wc = w + c;\n      //Do not use dictionary[wc] because javascript arrays\n      //will return values for array['pop'], array['push'] etc\n      // if (dictionary[wc]) {\n      if (dictionary.hasOwnProperty(wc)) {\n        w = wc;\n      } else {\n        result.push(dictionary[w]);\n        // Add wc to the dictionary.\n        dictionary[wc] = dictSize++;\n        w = String(c);\n      }\n    }\n\n    // Output the code for w.\n    if (w !== \"\") {\n      result.push(dictionary[w]);\n    }\n    return result;\n  }\n\n\n  function decompress(compressed) {\n    // Build the dictionary.\n    var i,\n      dictionary = [],\n      w,\n      result,\n      k,\n      entry = \"\",\n      dictSize = 256;\n    for (i = 0; i < 256; i += 1) {\n      dictionary[i] = String.fromCharCode(i);\n    }\n\n    w = String.fromCharCode(compressed[0]);\n    result = w;\n    for (i = 1; i < compressed.length; i += 1) {\n      k = compressed[i];\n      if (dictionary[k]) {\n        entry = dictionary[k];\n      } else {\n        if (k === dictSize) {\n          entry = w + w.charAt(0);\n        } else {\n          return null;\n        }\n      }\n\n      result += entry;\n\n      // Add w+entry[0] to the dictionary.\n      dictionary[dictSize++] = w + entry.charAt(0);\n\n      w = entry;\n    }\n    return result;\n  }\n\n  if(compressData){\n    return compress(input)\n  }else{\n    return decompress(input)\n  }\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>LZW</code> should be a function.'",
          "testString":
            "assert(typeof LZW=='function','<code>LZW</code> should be a function.');"
        },
        {
          "text":
            "'<code>LZW(true,\\\"'+tests[0]+'\\\")</code> should return a array.'",
          "testString":
            "assert(Array.isArray(LZW(true,tests[0])),'<code>LZW(true,\\\"'+tests[0]+'\\\")</code> should return a array.');"
        },
        {
          "text":
            "'<code>LZW(true,'+JSON.stringify(tests[0])+')</code> should return a string.'",
          "testString":
            "assert(typeof LZW(false,tests[1]) == 'string','<code>LZW(true,'+JSON.stringify(tests[0])+')</code> should return a string.');"
        },
        {
          "text":
            "'<code>LZW(true,\\\"'+tests[0]+'\\\")</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(LZW(true,tests[0]),results[0],'<code>LZW(true,\\\"'+tests[0]+'\\\")</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>LZW(false,'+JSON.stringify(tests[1])+')</code> should return <code>\\\"'+results[1]+'\\\"</code>.'",
          "testString":
            "assert.equal(LZW(false,tests[1]),results[1],'<code>LZW(false,'+JSON.stringify(tests[1])+')</code> should return <code>\\\"'+results[1]+'\\\"</code>.');"
        },
        {
          "text":
            "'<code>LZW(true,\\\"'+tests[2]+'\\\")</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(LZW(true,tests[2]),results[2],'<code>LZW(true,\\\"'+tests[2]+'\\\")</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>LZW(false,'+JSON.stringify(tests[3])+')</code> should return <code>\\\"'+results[3]+'\\\"</code>.'",
          "testString":
            "assert.equal(LZW(false,tests[3]),results[3],'<code>LZW(false,'+JSON.stringify(tests[3])+')</code> should return <code>\\\"'+results[3]+'\\\"</code>.');"
        },
        {
          "text":
            "'<code>LZW(true,\\\"'+tests[4]+'\\\")</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(LZW(true,tests[4]),results[4],'<code>LZW(true,\\\"'+tests[4]+'\\\")</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        },
        {
          "text":
            "'<code>LZW(false,'+JSON.stringify(tests[5])+')</code> should return <code>\\\"'+results[5]+'\\\"</code>.'",
          "testString":
            "assert.equal(LZW(false,tests[5]),results[5],'<code>LZW(false,'+JSON.stringify(tests[5])+')</code> should return <code>\\\"'+results[5]+'\\\"</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7eff",
      "challengeType": 5,
      "releasedOn": "July 10, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function LZW (compressData, input) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var tests=[",
            "\"TOBEORNOTTOBEORTOBEORNOT\",",
            "[84,79,66,69,79,82,78,79,84,256,258,260,265,259,261,263],",
            "\"0123456789\",",
            "[48,49,50,51,52,53,54,55,56,57],",
            "\"BABAABAAA\",",
            "[66,65,256,257,65,260]]",
            "var results=[",
            "[84,79,66,69,79,82,78,79,84,256,258,260,265,259,261,263],",
            "\"TOBEORNOTTOBEORTOBEORNOT\",",
            "[48,49,50,51,52,53,54,55,56,57],",
            "\"0123456789\",",
            "[66,65,256,257,65,260],",
            "\"BABAABAAA\"]"
          ]
        }
      }
    },
    {
      "title": "Magic squares of doubly even order",
      "description": [
        "A <a href=\"https://en.wikipedia.org/wiki/Magic_square\">magic square</a> is an $N &times; N$ square matrix whose numbers consist of consecutive numbers arranged so that the sum of each row and column, <i>and</i> both diagonals are equal to the same sum (which is called the <i>magic number</i> or <i>magic constant</i>).",
        "A magic square of doubly even order has a size that is a multiple of four (e.g. 4, 8, 12). This means that the subsquares also have an even size, which plays a role in the construction.",
        "\\begin{bmatrix} 1 & 2 & 62 & 61 & 60 & 59 & 7 & 8 \\\\ 9 & 10 & 54 & 53 & 52 & 51 & 15 & 16 \\\\ 48 & 47 & 19 & 20 & 21 & 22 & 42 & 41 \\\\ 40 & 39 & 27 & 28 & 29 & 30 & 34 & 33 \\\\ 32 & 31 & 35 & 36 & 37 & 38 & 26 & 25 \\\\ 24 & 23 & 43 & 44 & 45 & 46 & 18 & 17 \\\\ 49 & 50 & 14 & 13 & 12 & 11 & 55 & 56 \\\\ 57 & 58 & 6 & 5 & 4 & 3 & 63 & 64 \\\\ \\end{bmatrix}",
        "Write a function that takes $N$ as parameter and returns the resultant matrix."
      ],
      "solutions": [
        "function doubleEvenMagicSquare (n) {\n  // flatten :: Tree a -> [a]\n  const flatten = t => (t instanceof Array ? concatMap(flatten, t) : [t]);\n\n  // concatMap :: (a -> [b]) -> [a] -> [b]\n  const concatMap = (f, xs) => [].concat.apply([], xs.map(f));\n\n  // splitEvery :: Int -> [a] -> [][a]]\n  const splitEvery = (n, xs) => {\n    if (xs.length <= n) return [xs];\n    const [h, t] = [xs.slice(0, n), xs.slice(n)];\n    return [h].concat(splitEvery(n, t));\n  }\n\n  // curry :: ((a, b) -> c) -> a -> b -> c\n  const curry = f => a => b => f(a, b);\n\n  // replicate :: Int -> a -> [a]\n  const replicate = (n, a) => {\n    let v = [a],\n      o = [];\n    if (n < 1) return o;\n    while (n > 1) {\n      if (n & 1) o = o.concat(v);\n      n >>= 1;\n      v = v.concat(v);\n    }\n    return o.concat(v);\n  };\n\n  // isInt :: Int -> Bool\n  const isInt = x => x === Math.floor(x);\n\n  if (n % 4 > 0) return undefined;\n\n  // truthSeries :: Int -> [Int]\n  const truthSeries = n => {\n    if (n <= 0) return [true];\n    const xs = truthSeries(n - 1);\n    return xs.concat(xs.map(x => !x));\n  };\n\n  const sqr = n * n,\n    scale = curry(replicate)(n / 4),\n    power = Math.log2(sqr),\n    sequence = isInt(power) ? truthSeries(power) : (\n      flatten(\n        scale(\n          splitEvery(4, truthSeries(4))\n          .map(scale)\n        )\n      )\n    );\n\n  return splitEvery(n, sequence\n    .map((x, i) => x ? i + 1 : sqr - i));\n}\n\n\n"
      ],
      "tests": [
        {
          "text": "'<code>doubleEvenMagicSquare</code> should be a function.'",
          "testString":
            "assert(typeof doubleEvenMagicSquare=='function','<code>doubleEvenMagicSquare</code> should be a function.');"
        },
        {
          "text":
            "'<code>doubleEvenMagicSquare(4)</code> should return a array.'",
          "testString":
            "assert(Array.isArray(doubleEvenMagicSquare(4)),'<code>doubleEvenMagicSquare(4)</code> should return a array.');"
        },
        {
          "text":
            "'<code>isCorrect(doubleEvenMagicSquare(4),4)</code> should return <code>true</code>.'",
          "testString":
            "assert(isCorrect(doubleEvenMagicSquare(4),4),'<code>isCorrect(doubleEvenMagicSquare(4),4)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isCorrect(doubleEvenMagicSquare(8),8)</code> should return <code>true</code>.'",
          "testString":
            "assert(isCorrect(doubleEvenMagicSquare(8),8),'<code>isCorrect(doubleEvenMagicSquare(8),8)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isCorrect(doubleEvenMagicSquare(12),12)</code> should return <code>true</code>.'",
          "testString":
            "assert(isCorrect(doubleEvenMagicSquare(12),12),'<code>isCorrect(doubleEvenMagicSquare(12),12)</code> should return <code>true</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f03",
      "challengeType": 5,
      "releasedOn": "July 14, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function doubleEvenMagicSquare (n) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "function isCorrect(mat, n) {",
            "  if (mat == undefined || !Array.isArray(mat) || mat.length != n)",
            "    return false",
            "",
            "  const magic_constant = n * (n * n + 1) / 2",
            "",
            "  var sumDiag1 = 0,",
            "    sumDiag2 = 0,",
            "    rsum, csum = new Array(n)",
            "",
            "  csum.fill(0)",
            "  for (var i = 0, k = n - 1; i < n; i++, k--) {",
            "    if (!Array.isArray(mat[i]) || mat[i].length != n) {",
            "      return false",
            "    }",
            "",
            "    rsum = 0",
            "    sumDiag1 += mat[i][i]",
            "    sumDiag2 += mat[i][k]",
            "    for (var j = 0; j < n; j++) {",
            "      rsum += mat[i][j]",
            "      csum[i] += mat[i][j]",
            "    }",
            "",
            "    // check row sum",
            "    if (rsum != magic_constant)",
            "      return false",
            "  }",
            "",
            "  // check diagonal sums",
            "  if (sumDiag1 != magic_constant || sumDiag2 != magic_constant)",
            "    return false",
            "",
            "  // check column sums",
            "  for (var i = 0; i < csum.length; i++) {",
            "    if (csum[i] != magic_constant)",
            "      return false",
            "  }",
            "",
            "  return true",
            "}"
          ]
        }
      }
    },
    {
      "title": "Magic squares of odd order",
      "description": [
        "A magic square is an  $ N &times; N$  square matrix whose numbers (usually integers) consist of consecutive numbers arranged so that the sum of each row and column,  <i>and</i>  both long (main) diagonals are equal to the same sum (which is called the  <i>magic number</i>  or  <i>magic constant</i>).",
        "The numbers are usually (but not always) the first $N^2$  positive integers.",
        "A magic square whose rows and columns add up to a magic number but whose main diagonals do not, is known as a <i>semimagic square</i>.",
        "\\begin{bmatrix} 8 & 1 & 6 \\\\ 3 & 5 & 7 \\\\ 4 & 9 & 2 \\\\ \\end{bmatrix}",
        "Write a function that takes $N$ as parameter , <a href=\"https://en.wikipedia.org/wiki/Magic square#Method_for_constructing_a_magic_square_of_odd_order\">generate a magic square</a>, and returns the resultant matrix."
      ],
      "solutions": [
        "function magic (n) {\n  // [[a]] -> [[a]]\n  function rotation(lst) {\n    return lst.map(function (row, i) {\n      return rotated(\n        row, ((row.length + 1) / 2) - (i + 1)\n      );\n    })\n  }\n\n  // [[a]] -> [[a]]\n  function transposed(lst) {\n    return lst[0].map(function (col, i) {\n      return lst.map(function (row) {\n        return row[i];\n      })\n    });\n  }\n\n  // [a] -> n -> [a]\n  function rotated(lst, n) {\n    var lng = lst.length,\n      m = (typeof n === 'undefined') ? 1 : (\n        n < 0 ? lng + n : (n > lng ? n % lng : n)\n      );\n\n    return m ? (\n      lst.slice(-m).concat(lst.slice(0, lng - m))\n    ) : lst;\n  }\n\n  // n -> [[n]]\n  function table(n) {\n    var rngTop = rng(1, n);\n\n    return rng(0, n - 1).map(function (row) {\n      return rngTop.map(function (x) {\n        return row * n + x;\n      });\n    });\n  }\n\n  // [m..n]\n  function rng(m, n) {\n    return Array.apply(null, Array(n - m + 1)).map(\n      function (x, i) {\n        return m + i;\n      });\n  }\n\n  return n % 2 ? rotation(\n    transposed(\n      rotation(\n        table(n)\n      )\n    )\n  ) : null;\n}\n\n"
      ],
      "tests": [
        {
          "text": "'<code>magic</code> should be a function.'",
          "testString":
            "assert(typeof magic=='function','<code>magic</code> should be a function.');"
        },
        {
          "text": "'<code>magic(3)</code> should return a array.'",
          "testString":
            "assert(Array.isArray(magic(3)),'<code>magic(3)</code> should return a array.');"
        },
        {
          "text":
            "'<code>isCorrect(magic(3),3)</code> should return <code>true</code>.'",
          "testString":
            "assert(isCorrect(magic(3),3),'<code>isCorrect(magic(3),3)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isCorrect(magic(5),5)</code> should return <code>true</code>.'",
          "testString":
            "assert(isCorrect(magic(5),5),'<code>isCorrect(magic(5),5)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isCorrect(magic(7),7)</code> should return <code>true</code>.'",
          "testString":
            "assert(isCorrect(magic(7),7),'<code>isCorrect(magic(7),7)</code> should return <code>true</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f04",
      "challengeType": 5,
      "releasedOn": "July 14, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function magic (n) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "function isCorrect(mat, n) {",
            "  if (mat == undefined || !Array.isArray(mat) || mat.length != n)",
            "    return false",
            "",
            "  const magic_constant = n * (n * n + 1) / 2",
            "",
            "  var sumDiag1 = 0,",
            "    sumDiag2 = 0,",
            "    rsum, csum = new Array(n)",
            "",
            "  csum.fill(0)",
            "  for (var i = 0, k = n - 1; i < n; i++, k--) {",
            "    if (!Array.isArray(mat[i]) || mat[i].length != n) {",
            "      return false",
            "    }",
            "",
            "    rsum = 0",
            "    sumDiag1 += mat[i][i]",
            "    sumDiag2 += mat[i][k]",
            "    for (var j = 0; j < n; j++) {",
            "      rsum += mat[i][j]",
            "      csum[i] += mat[i][j]",
            "    }",
            "",
            "    // check row sum",
            "    if (rsum != magic_constant)",
            "      return false",
            "  }",
            "",
            "  // check diagonal sums",
            "  if (sumDiag1 != magic_constant || sumDiag2 != magic_constant)",
            "    return false",
            "",
            "  // check column sums",
            "  for (var i = 0; i < csum.length; i++) {",
            "    if (csum[i] != magic_constant)",
            "      return false",
            "  }",
            "",
            "  return true",
            "}"
          ]
        }
      }
    },
    {
      "title": "Magic squares of singly even order",
      "description": [
        "A <a href=\"https://en.wikipedia.org/wiki/Magic_square\">magic square</a> is an $ N &times; N $ square matrix whose numbers consist of consecutive numbers arranged so that the sum of each row and column, <i>and</i> both diagonals are equal to the same sum (which is called the <i>magic number</i> or <i>magic constant</i>).",
        "A  magic square of singly even order has a size that is a multiple of 4, plus 2 (e.g. 6, 10, 14). This means that the subsquares have an odd size, which plays a role in the construction.",
        "Write a function that takes $N$ as parameter and returns the resultant matrix."
      ],
      "solutions": [
        "function singlyEvenMagicSquare (n) {\n\n  function oddMagicSquare(n) {\n    if (n < 3 || n % 2 == 0)\n      return;\n\n    var value = 0;\n    var squareSize = n * n;\n    var c = Math.floor(n / 2),\n      r = 0,\n      i;\n\n    var result = new Array(n)\n    for (var i = 0; i < result.length; i++) {\n      result[i] = new Array(n)\n      result[i].fill(0)\n    }\n\n    while (++value <= squareSize) {\n      result[r][c] = value;\n      if (r == 0) {\n        if (c == n - 1) {\n          r++;\n        } else {\n          r = n - 1;\n          c++;\n        }\n      } else if (c == n - 1) {\n        r--;\n        c = 0;\n      } else if (result[r - 1][c + 1] == 0) {\n        r--;\n        c++;\n      } else {\n        r++;\n      }\n    }\n    return result;\n  }\n\n  if (n < 6 || (n - 2) % 4 != 0)\n    return null;\n\n  var size = n * n;\n  var halfN = Math.floor(n / 2);\n  var subGridSize = Math.floor(size / 4),\n    i;\n\n  var subGrid = oddMagicSquare(halfN);\n  var gridFactors = [0, 2, 3, 1];\n  var result = new Array(n)\n  for (var i = 0; i < result.length; i++) {\n    result[i] = new Array(n)\n    result[i].fill(0)\n  }\n\n  for (var r = 0; r < n; r++) {\n    for (var c = 0; c < n; c++) {\n      var grid = Math.floor(r / halfN) * 2 + Math.floor(c / halfN);\n      result[r][c] = subGrid[r % halfN][c % halfN];\n      result[r][c] += gridFactors[grid] * subGridSize;\n    }\n  }\n\n  var nColsLeft = Math.floor(halfN / 2);\n  var nColsRight = nColsLeft - 1;\n\n  for (var r = 0; r < halfN; r++)\n    for (var c = 0; c < n; c++) {\n      if (c < nColsLeft || c >= n - nColsRight ||\n        (c == nColsLeft && r == nColsLeft)) {\n\n        if (c == 0 && r == nColsLeft)\n          continue;\n\n        var tmp = result[r][c];\n        result[r][c] = result[r + halfN][c];\n        result[r + halfN][c] = tmp;\n      }\n    }\n\n  return result;\n}\n\n\n"
      ],
      "tests": [
        {
          "text": "'<code>singlyEvenMagicSquare</code> should be a function.'",
          "testString":
            "assert(typeof singlyEvenMagicSquare=='function','<code>singlyEvenMagicSquare</code> should be a function.');"
        },
        {
          "text":
            "'<code>singlyEvenMagicSquare(6)</code> should return a array.'",
          "testString":
            "assert(Array.isArray(singlyEvenMagicSquare(6)),'<code>singlyEvenMagicSquare(6)</code> should return a array.');"
        },
        {
          "text":
            "'<code>isCorrect(singlyEvenMagicSquare(6),6)</code> should return <code>true</code>.'",
          "testString":
            "assert(isCorrect(singlyEvenMagicSquare(6),6),'<code>isCorrect(singlyEvenMagicSquare(6),6)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isCorrect(singlyEvenMagicSquare(10),10)</code> should return <code>true</code>.'",
          "testString":
            "assert(isCorrect(singlyEvenMagicSquare(10),10),'<code>isCorrect(singlyEvenMagicSquare(10),10)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isCorrect(singlyEvenMagicSquare(14),14)</code> should return <code>true</code>.'",
          "testString":
            "assert(isCorrect(singlyEvenMagicSquare(14),14),'<code>isCorrect(singlyEvenMagicSquare(14),14)</code> should return <code>true</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f05",
      "challengeType": 5,
      "releasedOn": "July 14, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function singlyEvenMagicSquare (n) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "function isCorrect(mat, n) {",
            "  if (mat == undefined || !Array.isArray(mat) || mat.length != n)",
            "    return false",
            "",
            "  const magic_constant = n * (n * n + 1) / 2",
            "",
            "  var sumDiag1 = 0,",
            "    sumDiag2 = 0,",
            "    rsum, csum = new Array(n)",
            "",
            "  csum.fill(0)",
            "  for (var i = 0, k = n - 1; i < n; i++, k--) {",
            "    if (!Array.isArray(mat[i]) || mat[i].length != n) {",
            "      return false",
            "    }",
            "",
            "    rsum = 0",
            "    sumDiag1 += mat[i][i]",
            "    sumDiag2 += mat[i][k]",
            "    for (var j = 0; j < n; j++) {",
            "      rsum += mat[i][j]",
            "      csum[i] += mat[i][j]",
            "    }",
            "",
            "    // check row sum",
            "    if (rsum != magic_constant)",
            "      return false",
            "  }",
            "",
            "  // check diagonal sums",
            "  if (sumDiag1 != magic_constant || sumDiag2 != magic_constant)",
            "    return false",
            "",
            "  // check column sums",
            "  for (var i = 0; i < csum.length; i++) {",
            "    if (csum[i] != magic_constant)",
            "      return false",
            "  }",
            "",
            "  return true",
            "}"
          ]
        }
      }
    },
    {
      "title": "Main step of GOST 28147-89",
      "description": [
        "<a href=\"https://en.wikipedia.org/wiki/GOST (block cipher)\">GOST 28147-89</a> is a standard symmetric encryption based on a <a href=\"https://en.wikipedia.org/wiki/Feistel cipher\">Feistel network</a>. Structure of the algorithm consists of three levels:",
        "<ol><li>encryption modes - simple replacement, application range, imposing a range of feedback and authentication code generation;</li>",
        "<li>cycles - 32-З, 32-Р and 16-З, is a repetition of the main step;</li>",
        "<li><i>main step</i>, a function that takes a 64-bit block of text and one of the eight 32-bit encryption key elements, and uses the replacement table (8x16 matrix of 4-bit values), and returns encrypted block.</li></ol>",
        "Write a function that takes input and key as parameters and returns the result of the main step."
      ],
      "solutions": [
        "function mainStep (input, key) {\n  var s = [\n    [ 4, 10,  9,  2, 13,  8,  0, 14,  6, 11,  1, 12,  7, 15,  5,  3],\n    [14, 11,  4, 12,  6, 13, 15, 10,  2,  3,  8,  1,  0,  7,  5,  9],\n    [ 5,  8,  1, 13, 10,  3,  4,  2, 14, 15, 12,  7,  6,  0,  9, 11],\n    [ 7, 13, 10,  1,  0,  8,  9, 15, 14,  4,  6, 12, 11,  2,  5,  3],\n    [ 6, 12,  7,  1,  5, 15, 13,  8,  4, 10,  9, 14,  0,  3, 11,  2],\n    [ 4, 11, 10,  0,  7,  2,  1, 13,  3,  6,  8,  5,  9, 12, 15, 14],\n    [13, 11,  4,  1,  3, 15,  5,  9,  0, 10, 14,  7,  6,  8,  2, 12],\n    [ 1, 15, 13,  0,  5,  7, 10,  4,  9,  2,  3, 14,  6, 11,  8, 12]];\n  var N = input.slice(0);\n  var X = key;\n  var S = (N[0] + X) & 0xFFFFFFFF;\n  var av; var hob = 0;\n  for (var c = 0; c < 4; c++) {\n    av = (S >>> (c << 3)) & 0xFF;\n    hob += (s[c*2][av & 0x0F] + (s[c*2+1][av >>> 4] << 4)) << (c << 3);\n  }\n  S = (((hob << 11) + (hob >>> 21)) & 0xFFFFFFFF) ^ N[1];\n  N[1] = N[0]; N[0] = S;\n  return N;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>mainStep</code> should be a function.'",
          "testString":
            "assert(typeof mainStep=='function','<code>mainStep</code> should be a function.');"
        },
        {
          "text":
            "'<code>mainStep('+JSON.stringify(tests[0])+',3804300536)</code> should return a array.'",
          "testString":
            "assert(Array.isArray(mainStep(tests[0],3804300536)),'<code>mainStep('+JSON.stringify(tests[0])+',3804300536)</code> should return a array.');"
        },
        {
          "text":
            "'<code>mainStep('+JSON.stringify(tests[0])+',3804300536)</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(mainStep(tests[0],3804300536),results[0],'<code>mainStep('+JSON.stringify(tests[0])+',3804300536)</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>mainStep('+JSON.stringify(tests[1])+',3804300537)</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(mainStep(tests[1],3804300537),results[1],'<code>mainStep('+JSON.stringify(tests[1])+',3804300537)</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>mainStep('+JSON.stringify(tests[2])+',3804300538)</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(mainStep(tests[2],3804300538),results[2],'<code>mainStep('+JSON.stringify(tests[2])+',3804300538)</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>mainStep('+JSON.stringify(tests[3])+',3804300538)</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(mainStep(tests[3],3804300538),results[3],'<code>mainStep('+JSON.stringify(tests[3])+',3804300538)</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>mainStep('+JSON.stringify(tests[4])+',3804299562)</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(mainStep(tests[4],3804299562),results[4],'<code>mainStep('+JSON.stringify(tests[4])+',3804299562)</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f06",
      "challengeType": 5,
      "releasedOn": "July 14, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function mainStep (input, key) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var tests=[",
            "[70976545,70386736],",
            "[70997025,137495601],",
            "[70988833,70386736],",
            "[70988833,70386736],",
            "[70329377,70464560]]",
            "var results=[",
            "[131061791,70976545],",
            "[206538782,70997025],",
            "[80732191,70988833],",
            "[80732191,70988833],",
            "[958943263,70329377]]"
          ]
        }
      }
    },
    {
      "title": "Map range",
      "description": [
        "Given two <a href=\"https://en.wikipedia.org/wiki/Interval (mathematics)\">ranges</a>:",
        "$[a_1,a_2]$  and",
        "$[b_1,b_2]$;",
        "then a value  $s$  in range  $[a_1,a_2]$",
        "is linearly mapped to a value  $t$  in range  $[b_1,b_2]$",
        "  where:",
        "$$t = b_1 + {(s - a_1)(b_2 - b_1) \\over (a_2 - a_1)}$$",
        "Write a function that takes two ranges, and returns the mapping of the real number from the first to the second range."
      ],
      "solutions": [
        "function mapRange (fromRange,toRange) {\n  var val = function(from, to, s) {\n    return to[0] + (s - from[0]) * (to[1] - to[0]) / (from[1] - from[0]);\n  };\n\n  var rangeVals=new Array(fromRange[1]-fromRange[0]+1)\n\n  for (var i = 0; i < rangeVals.length; i++) {\n    rangeVals[i]=fromRange[0]+i\n  }\n  for (var i = 0; i < rangeVals.length; i++) {\n    rangeVals[i] = val(fromRange, toRange, rangeVals[i]);\n  }\n\n  return rangeVals\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>mapRange</code> should be a function.'",
          "testString":
            "assert(typeof mapRange=='function','<code>mapRange</code> should be a function.');"
        },
        {
          "text":
            "'<code>mapRange('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return a array.'",
          "testString":
            "assert(Array.isArray(mapRange(tests[0][0],tests[0][1])),'<code>mapRange('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return a array.');"
        },
        {
          "text":
            "'<code>mapRange('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(mapRange(tests[0][0],tests[0][1]),results[0],'<code>mapRange('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>mapRange('+JSON.stringify(tests[1][0])+','+JSON.stringify(tests[1][1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(mapRange(tests[1][0],tests[1][1]),results[1],'<code>mapRange('+JSON.stringify(tests[1][0])+','+JSON.stringify(tests[1][1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>mapRange('+JSON.stringify(tests[2][0])+','+JSON.stringify(tests[2][1])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(mapRange(tests[2][0],tests[2][1]),results[2],'<code>mapRange('+JSON.stringify(tests[2][0])+','+JSON.stringify(tests[2][1])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>mapRange('+JSON.stringify(tests[3][0])+','+JSON.stringify(tests[3][1])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(mapRange(tests[3][0],tests[3][1]),results[3],'<code>mapRange('+JSON.stringify(tests[3][0])+','+JSON.stringify(tests[3][1])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>mapRange('+JSON.stringify(tests[4][0])+','+JSON.stringify(tests[4][1])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(mapRange(tests[4][0],tests[4][1]),results[4],'<code>mapRange('+JSON.stringify(tests[4][0])+','+JSON.stringify(tests[4][1])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f0a",
      "challengeType": 5,
      "releasedOn": "July 14, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function mapRange (fromRange,toRange) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var tests=[",
            "[[2,4],[-1,0]],",
            "[[2,10],[-1,0]],",
            "[[0,10],[0,120]],",
            "[[1,10],[1,100]],",
            "[[15,20],[0,1]]]",
            "var results=[",
            "[-1,-0.5,0],",
            "[-1,-0.875,-0.75,-0.625,-0.5,-0.375,-0.25,-0.125,0],",
            "[0,12,24,36,48,60,72,84,96,108,120],",
            "[1,12,23,34,45,56,67,78,89,100],",
            "[0,0.2,0.4,0.6,0.8,1]]"
          ]
        }
      }
    },
    {
      "title": "Matrix arithmetic",
      "description": [
        "For a given matrix, return the <a href=\"https://en.wikipedia.org/wiki/Determinant\">determinant</a> and the <a href=\"https://en.wikipedia.org/wiki/Permanent\">permanent</a> of the matrix.",
        "The determinant is given by",
        "$\\det(A) = \\sum_\\sigma sgn(\\sigma)\\prod_{i=1}^n M_{i,\\sigma_i}$",
        "while the permanent is given by",
        "$ \\operatorname{perm}(A)=\\sum_\\sigma\\prod_{i=1}^n M_{i,\\sigma_i}$",
        "In both cases the sum is over the permutations $\\sigma$ of the permutations of 1, 2, ..., <i>n</i>. (A permutation's sign is 1 if there are an even number of inversions and -1 otherwise; see <a href=\"https://en.wikipedia.org/wiki/Parity of a permutation\">parity of a permutation</a>.)",
        "More efficient algorithms for the determinant are known: <a href=\"http://rosettacode.org/wiki/LU decomposition\">LU decomposition</a>. Efficient methods for calculating the permanent are not known.",
        "Write a function that takes a matrix as a parameter and returns the determinant and the permanent in the form: <code>[det,perm]</code>."
      ],
      "solutions": [
        "function matArith (mat) {\n  function minor(a,x,y) {\n    var length = a.length - 1;\n    var result = new Array(length);\n    for (var i = 0; i < result.length; i++) {\n      result[i]=new Array(length)\n    }\n\n    for (var i = 0; i < length; i++)\n      for (var j = 0; j < length; j++) {\n        if (i < x && j < y) {\n          result[i][j] = a[i][j];\n        } else if (i >= x && j < y) {\n          result[i][j] = a[i + 1][j];\n        } else if (i < x && j >= y) {\n          result[i][j] = a[i][j + 1];\n        } else { //i>x && j>y\n          result[i][j] = a[i + 1][j + 1];\n        }\n      }\n    return result;\n  }\n\n  function det(a) {\n    if (a.length == 1) {\n      return a[0][0];\n    } else {\n      var sign = 1;\n      var sum = 0;\n      for (var i = 0; i < a.length; i++) {\n        sum += sign * a[0][i] * det(minor(a, 0, i));\n        sign *= -1;\n      }\n      return sum;\n    }\n  }\n\n  function perm(a) {\n    if (a.length == 1) {\n      return a[0][0];\n    } else {\n      var sum = 0;\n      for (var i = 0; i < a.length; i++) {\n        sum += a[0][i] * perm(minor(a, 0, i));\n      }\n      return sum;\n    }\n  }\n  return [det(mat),perm(mat)]\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>matArith</code> should be a function.'",
          "testString":
            "assert(typeof matArith=='function','<code>matArith</code> should be a function.');"
        },
        {
          "text":
            "'<code>matArith('+JSON.stringify(tests[0])+')</code> should return a array.'",
          "testString":
            "assert(Array.isArray(matArith(tests[0])),'<code>matArith('+JSON.stringify(tests[0])+')</code> should return a array.');"
        },
        {
          "text":
            "'<code>matArith('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(matArith(tests[0]),results[0],'<code>matArith('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>matArith('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(matArith(tests[1]),results[1],'<code>matArith('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>matArith('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(matArith(tests[2]),results[2],'<code>matArith('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>matArith('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(matArith(tests[3]),results[3],'<code>matArith('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>matArith('+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(matArith(tests[4]),results[4],'<code>matArith('+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f0b",
      "challengeType": 5,
      "releasedOn": "July 14, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function matArith (mat) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "var tests=[",
            "[[1,2],[3,4]],",
            "[[1,2,3,4],[4,5,6,7],[7,8,9,10],[10,11,12,13]],",
            "[[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19],[20,21,22,23,24]],",
            "[[2,9,4],[7,5,3],[6,1,8]],",
            "[[4,3],[2,5]]]",
            "var results=[",
            "[-2,10],",
            "[0,29556],",
            "[0,6778800],",
            "[-360,900],",
            "[14,26]]"
          ]
        }
      }
    },
    {
      "title": "Matrix multiplication",
      "description": [
        "Write a function that takes two matrices as parameter and returns the multiplication of the two matrices.",
        "They can be of any dimensions, so long as the number of columns of the first matrix is equal to the number of rows of the second matrix."
      ],
      "solutions": [
        "function matrixMult (mat1, mat2) {\n  var result = [];\n  for (var i = 0; i < mat1.length; i++) {\n      result[i] = [];\n      for (var j = 0; j < mat2[0].length; j++) {\n          var sum = 0;\n          for (var k = 0; k < mat1[0].length; k++) {\n              sum += mat1[i][k] * mat2[k][j];\n          }\n          result[i][j] = sum;\n      }\n  }\n  return result;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>matrixMult</code> should be a function.'",
          "testString":
            "assert(typeof matrixMult=='function','<code>matrixMult</code> should be a function.');"
        },
        {
          "text":
            "'<code>matrixMult('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return a array.'",
          "testString":
            "assert(Array.isArray(matrixMult(tests[0][0],tests[0][1])),'<code>matrixMult('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return a array.');"
        },
        {
          "text":
            "'<code>matrixMult('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(matrixMult(tests[0][0],tests[0][1]),results[0],'<code>matrixMult('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>matrixMult('+JSON.stringify(tests[1][0])+','+JSON.stringify(tests[1][1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(matrixMult(tests[1][0],tests[1][1]),results[1],'<code>matrixMult('+JSON.stringify(tests[1][0])+','+JSON.stringify(tests[1][1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>matrixMult('+JSON.stringify(tests[2][0])+','+JSON.stringify(tests[2][1])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(matrixMult(tests[2][0],tests[2][1]),results[2],'<code>matrixMult('+JSON.stringify(tests[2][0])+','+JSON.stringify(tests[2][1])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>matrixMult('+JSON.stringify(tests[3][0])+','+JSON.stringify(tests[3][1])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(matrixMult(tests[3][0],tests[3][1]),results[3],'<code>matrixMult('+JSON.stringify(tests[3][0])+','+JSON.stringify(tests[3][1])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>matrixMult('+JSON.stringify(tests[4][0])+','+JSON.stringify(tests[4][1])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(matrixMult(tests[4][0],tests[4][1]),results[4],'<code>matrixMult('+JSON.stringify(tests[4][0])+','+JSON.stringify(tests[4][1])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f0d",
      "challengeType": 5,
      "releasedOn": "July 14, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function matrixMult (mat1, mat2) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var tests=[",
            "[[[1,2],[3,4]],[[-3,-8,3],[-2,1,4]]],",
            "[[[-1,1,4],[6,-4,2],[-3,5,0],[3,7,-2]],[[-1,1,4,8],[6,9,10,2],[11,-4,5,-3]]],",
            "[[[1,2,3],[4,5,6]],[[1,2],[3,4],[5,6]]],",
            "[[[1,2],[3,4]],[[5,6],[7,8]]],",
            "[[[11,12],[31,14]],[[1,0],[0,1]]]]",
            "var results=[",
            "[[-7,-6,11],[-17,-20,25]],",
            "[[51,-8,26,-18],[-8,-38,-6,34],[33,42,38,-14],[17,74,72,44]],",
            "[[22,28],[49,64]],",
            "[[19,22],[43,50]],",
            "[[11,12],[31,14]]]"
          ]
        }
      }
    },
    {
      "title": "Matrix transposition",
      "description": [
        "Write a function to <a href=\"https://en.wikipedia.org/wiki/Transpose\">transpose</a> an arbitrarily sized rectangular <a href=\"https://en.wikipedia.org/wiki/Matrix (mathematics)\">Matrix</a>."
      ],
      "solutions": [
        "function transpose (mat) {\n  return mat[0].map(function(_, iCol) {\n    return mat.map(function(row) {\n      return row[iCol];\n    })\n  });\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>transpose</code> should be a function.'",
          "testString":
            "assert(typeof transpose=='function','<code>transpose</code> should be a function.');"
        },
        {
          "text":
            "'<code>transpose('+JSON.stringify(tests[0])+')</code> should return a array.'",
          "testString":
            "assert(Array.isArray(transpose(tests[0])),'<code>transpose('+JSON.stringify(tests[0])+')</code> should return a array.');"
        },
        {
          "text":
            "'<code>transpose('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(transpose(tests[0]),results[0],'<code>transpose('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>transpose('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(transpose(tests[1]),results[1],'<code>transpose('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>transpose('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(transpose(tests[2]),results[2],'<code>transpose('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>transpose('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(transpose(tests[3]),results[3],'<code>transpose('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>transpose('+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(transpose(tests[4]),results[4],'<code>transpose('+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f0e",
      "challengeType": 5,
      "releasedOn": "July 14, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function transpose (mat) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "var tests=[",
            "[[1,2],[3,4]],",
            "[[1,2,3],[4,5,6]],",
            "[[1,1,1,1],[2,4,8,16],[3,9,27,81]],",
            "[[1,2,3],[1,4,9],[1,8,27],[1,16,81]],",
            "[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]]",
            "var results=[",
            "[[1,3],[2,4]],",
            "[[1,4],[2,5],[3,6]],",
            "[[1,2,3],[1,4,9],[1,8,27],[1,16,81]],",
            "[[1,1,1,1],[2,4,8,16],[3,9,27,81]],",
            "[[1,4,7,10],[2,5,8,11],[3,6,9,12]]]"
          ]
        }
      }
    },
    {
      "title": "Matrix-exponentiation operator",
      "description": [
        "Write a function that takes a matrix and a number as parameters and returns the exponentiated matrix (multiply with itself)."
      ],
      "solutions": [
        "function matExp (mat, exp) {\n  function IdentityMatrix(n) {\n    var I=[]\n    for (var i = 0; i < n; i++) {\n        I[i] = [];\n        for (var j = 0; j < n; j++) {\n            I[i][j] = (i == j ? 1 : 0);\n        }\n    }\n    return I\n  }\n\n  function matrixMult(mat1,mat2) {\n    var result = [];\n    for (var i = 0; i < mat1.length; i++) {\n        result[i] = [];\n        for (var j = 0; j < mat2[0].length; j++) {\n            var sum = 0;\n            for (var k = 0; k < mat1[0].length; k++) {\n                sum += mat1[i][k] * mat2[k][j];\n            }\n            result[i][j] = sum;\n        }\n    }\n    return result;\n  }\n\n  var result = IdentityMatrix(mat.length);\n  for (var i = 1; i <= exp; i++) {\n      result = matrixMult(result,mat);\n  }\n  return result;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>matExp</code> should be a function.'",
          "testString":
            "assert(typeof matExp=='function','<code>matExp</code> should be a function.');"
        },
        {
          "text":
            "'<code>matExp('+JSON.stringify(tests[0])+',2)</code> should return a array.'",
          "testString":
            "assert(Array.isArray(matExp(tests[0],2)),'<code>matExp('+JSON.stringify(tests[0])+',2)</code> should return a array.');"
        },
        {
          "text":
            "'<code>matExp('+JSON.stringify(tests[0])+',2)</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(matExp(tests[0],2),results[0],'<code>matExp('+JSON.stringify(tests[0])+',2)</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>matExp('+JSON.stringify(tests[1])+',3)</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(matExp(tests[1],3),results[1],'<code>matExp('+JSON.stringify(tests[1])+',3)</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>matExp('+JSON.stringify(tests[2])+',10)</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(matExp(tests[2],10),results[2],'<code>matExp('+JSON.stringify(tests[2])+',10)</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>matExp('+JSON.stringify(tests[3])+',3)</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(matExp(tests[3],3),results[3],'<code>matExp('+JSON.stringify(tests[3])+',3)</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>matExp('+JSON.stringify(tests[4])+',4)</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(matExp(tests[4],4),results[4],'<code>matExp('+JSON.stringify(tests[4])+',4)</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f0c",
      "challengeType": 5,
      "releasedOn": "July 14, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function matExp (mat, exp) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "var tests=[",
            "[[3,2],[2,1]],",
            "[[3,2],[2,1]],",
            "[[1,1],[1,0]],",
            "[[1,1,1],[1,2,3],[7,8,9]],",
            "[[1,2],[3,4]]]",
            "var results=[",
            "[[13,8],[8,5]],",
            "[[55,34],[34,21]],",
            "[[89,55],[55,34]],",
            "[[111,135,159],[291,354,417],[957,1164,1371]],",
            "[[199,290],[435,634]]]"
          ]
        }
      }
    },
    {
      "title": "Maximum triangle path sum",
      "description": [
        "Starting from the top of a pyramid of numbers like this, you can walk down going one step on the right or on the left, until you reach the bottom row:",
        "<pre>",
        "                          55",
        "                        94 48",
        "                       95 30 96",
        "                     77 71 26 67",
        "</pre>",
        "One of such walks is 55 - 94 - 30 - 26.",
        "You can compute the total of the numbers you have seen in such walk, in this case it's 205.",
        "Your problem is to find the maximum total among all possible paths from the top to the bottom row of the triangle. In the little example above it's 321."
      ],
      "solutions": [
        "function maxTrianglePathSum (tri) {\n  while (tri.length !== 1) {\n    var len = tri.length;\n    var row = [];\n    var current = tri[len-2];\n    var currentLen = current.length - 1;\n    var end = tri[len-1];\n\n    for ( var i = 0; i <= currentLen; i++ ) {\n      row.push(Math.max(current[i] + end[i] || 0, current[i] + end[i+1] || 0) )\n    }\n\n    tri.pop();\n    tri.pop();\n\n    tri.push(row);\n  }\n\n  return tri[0][0]\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>maxTrianglePathSum</code> should be a function.'",
          "testString":
            "assert(typeof maxTrianglePathSum=='function','<code>maxTrianglePathSum</code> should be a function.');"
        },
        {
          "text":
            "'<code>maxTrianglePathSum('+JSON.stringify(tests[0])+')</code> should return a number.'",
          "testString":
            "assert(typeof maxTrianglePathSum(tests[0]) == 'number','<code>maxTrianglePathSum('+JSON.stringify(tests[0])+')</code> should return a number.');"
        },
        {
          "text":
            "'<code>maxTrianglePathSum('+JSON.stringify(tests[0])+')</code> should return <code>321</code>.'",
          "testString":
            "assert.equal(maxTrianglePathSum(tests[0]),321,'<code>maxTrianglePathSum('+JSON.stringify(tests[0])+')</code> should return <code>321</code>.');"
        },
        {
          "text":
            "'<code>maxTrianglePathSum('+JSON.stringify(tests[1])+')</code> should return <code>224</code>.'",
          "testString":
            "assert.equal(maxTrianglePathSum(tests[1]),224,'<code>maxTrianglePathSum('+JSON.stringify(tests[1])+')</code> should return <code>224</code>.');"
        },
        {
          "text":
            "'<code>maxTrianglePathSum('+JSON.stringify(tests[2])+')</code> should return <code>1320</code>.'",
          "testString":
            "assert.equal(maxTrianglePathSum(tests[2]),1320,'<code>maxTrianglePathSum('+JSON.stringify(tests[2])+')</code> should return <code>1320</code>.');"
        },
        {
          "text":
            "'<code>maxTrianglePathSum('+JSON.stringify(tests[3])+')</code> should return <code>368</code>.'",
          "testString":
            "assert.equal(maxTrianglePathSum(tests[3]),368,'<code>maxTrianglePathSum('+JSON.stringify(tests[3])+')</code> should return <code>368</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f0f",
      "challengeType": 5,
      "releasedOn": "July 14, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function maxTrianglePathSum (tri) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var tests=[",
            "[[55],[94,48],[95,30,96],[77,71,26,67]],",
            "[[97],[7,36],[48,7,9],[18,72,79,46]],",
            "[[55],[94,48],[95,30,96],[77,71,26,67],[97,13,76,38,45],[7,36,79,16,37,68],[48,7,9,18,70,26,6],[18,72,79,46,59,79,29,90],[20,76,87,11,32,7,7,49,18],[27,83,58,35,71,11,25,57,29,85],[14,64,36,96,27,11,58,56,92,18,55],[2,90,3,60,48,49,41,46,33,36,47,23],[92,50,48,2,36,59,42,79,72,20,82,77,42],[56,78,38,80,39,75,2,71,66,66,1,3,55,72],[44,25,67,84,71,67,11,61,40,57,58,89,40,56,36],[85,32,25,85,57,48,84,35,47,62,17,1,1,99,89,52],[6,71,28,75,94,48,37,10,23,51,6,48,53,18,74,98,15],[27,2,92,23,8,71,76,84,15,52,92,63,81,10,44,10,69,93]],",
            "[[14],[64,36],[96,27,11],[58,56,92,18],[2,90,3,60,48],[49,41,46,33,36,47]]]"
          ]
        }
      }
    },
    {
      "title": "Maze solving",
      "description": [
        "For a maze, write a function that finds the shortest path between two cells.",
        "Note that because these mazes are generated by the <a href=\"https://en.wikipedia.org/wiki/Maze_generation_algorithm#Depth-first_search\">Depth-first search</a> algorithm, they contain no circular paths, and a simple depth-first tree search can be used.",
        "The function will take a matrix, start location, and end location as parameters. The matrix represents the maze and contains 0s for unoccupied cells and 1s for occupied cells (walls). The start and end locations are represented as an object in the form { x: row, y: column }. Keep in mind that both x and y zero-based numbers. The function should return an array denoting the path from the start location to the end location. The first element of this array should be the start location and the last one should be the end location. Each of the array elements should be an object similar to start and end location objects."
      ],
      "solutions": [
        "function mazeSolver (maze, start, end) {\n  maze=maze.map(e=>e.slice())\n  start=Object.assign({},start)\n  end=Object.assign({},end)\n\n  var rows=maze.length,cols=maze[0].length,stack=[]\n\n  function getFNeighbours(sx, sy, a) {\n    var n = [];\n    if (sx - 1 > 0 && maze[sx - 1][sy] == a) {\n      n.push({\n        x: sx - 1,\n        y: sy\n      });\n    }\n    if (sx + 1 < cols - 1 && maze[sx + 1][sy] == a) {\n      n.push({\n        x: sx + 1,\n        y: sy\n      });\n    }\n    if (sy - 1 > 0 && maze[sx][sy - 1] == a) {\n      n.push({\n        x: sx,\n        y: sy - 1\n      });\n    }\n    if (sy + 1 < rows - 1 && maze[sx][sy + 1] == a) {\n      n.push({\n        x: sx,\n        y: sy + 1\n      });\n    }\n    return n;\n  }\n\n  function solveMaze() {\n    if (start.x == end.x && start.y == end.y) {\n      for (var i = 0; i < cols; i++) {\n        for (var j = 0; j < rows; j++) {\n          switch (maze[i][j]) {\n            case 2:\n              maze[i][j] = 3;\n              break;\n            case 4:\n              maze[i][j] = 0;\n              break;\n          }\n        }\n      }\n      return;\n    }\n    var neighbours = getFNeighbours(start.x, start.y, 0);\n    if (neighbours.length) {\n      stack.push(start);\n      start = neighbours[0];\n      maze[start.x][start.y] = 2;\n    } else {\n      maze[start.x][start.y] = 4;\n      start = stack.pop();\n    }\n\n    solveMaze()\n  }\n\n  solveMaze()\n\n  stack.push(end)\n  return stack\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>mazeSolver</code> should be a function.'",
          "testString":
            "assert(typeof mazeSolver=='function','<code>mazeSolver</code> should be a function.');"
        },
        {
          "text":
            "'<code>mazeSolver('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+','+JSON.stringify(tests[0][2])+')</code> should return a array.'",
          "testString":
            "assert(Array.isArray(mazeSolver(tests[0][0],tests[0][1],tests[0][2])),'<code>mazeSolver('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+','+JSON.stringify(tests[0][2])+')</code> should return a array.');"
        },
        {
          "text":
            "'<code>mazeSolver('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+','+JSON.stringify(tests[0][2])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(mazeSolver(tests[0][0],tests[0][1],tests[0][2]),results[0],'<code>mazeSolver('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+','+JSON.stringify(tests[0][2])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>mazeSolver('+JSON.stringify(tests[1][0])+','+JSON.stringify(tests[1][1])+','+JSON.stringify(tests[1][2])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(mazeSolver(tests[1][0],tests[1][1],tests[1][2]),results[1],'<code>mazeSolver('+JSON.stringify(tests[1][0])+','+JSON.stringify(tests[1][1])+','+JSON.stringify(tests[1][2])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>mazeSolver('+JSON.stringify(tests[2][0])+','+JSON.stringify(tests[2][1])+','+JSON.stringify(tests[2][2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(mazeSolver(tests[2][0],tests[2][1],tests[2][2]),results[2],'<code>mazeSolver('+JSON.stringify(tests[2][0])+','+JSON.stringify(tests[2][1])+','+JSON.stringify(tests[2][2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>mazeSolver('+JSON.stringify(tests[3][0])+','+JSON.stringify(tests[3][1])+','+JSON.stringify(tests[3][2])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(mazeSolver(tests[3][0],tests[3][1],tests[3][2]),results[3],'<code>mazeSolver('+JSON.stringify(tests[3][0])+','+JSON.stringify(tests[3][1])+','+JSON.stringify(tests[3][2])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f11",
      "challengeType": 5,
      "releasedOn": "July 14, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function mazeSolver (maze, start, end) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var tests=[",
            "[[[1,1,1,1,1],[1,0,1,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]],{x:1,y:1},{x:1,y:3}],",
            "[[[1,1,1,1,1],[1,0,0,0,1],[1,1,1,0,1],[1,0,0,0,1],[1,1,1,1,1]],{x:3,y:1},{x:1,y:1}],",
            "[[[1,1,1,1,1,1,1],[1,0,0,0,1,0,1],[1,0,1,1,1,0,1],[1,0,1,0,0,0,1],[1,0,1,0,1,0,1],[1,0,0,0,1,0,1],[1,1,1,1,1,1,1]],{x:3,y:5},{x:1,y:1}],",
            "[[[1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,1,1],[1,0,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,0,0,1,1],[1,1,1,0,1,1,1,0,1,1],[1,0,0,0,1,0,0,0,1,1],[1,0,1,1,1,0,1,0,1,1],[1,0,0,0,0,0,1,0,1,1],[1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1]],{x:1,y:1},{x:7,y:7}]]",
            "var results=[",
            "[{x:1,y:1},{x:2,y:1},{x:3,y:1},{x:3,y:2},{x:3,y:3},{x:2,y:3},{x:1,y:3}],",
            "[{x:3,y:1},{x:3,y:2},{x:3,y:3},{x:2,y:3},{x:1,y:3},{x:1,y:2},{x:1,y:1}],",
            "[{x:3,y:5},{x:2,y:5},{x:3,y:5},{x:3,y:4},{x:3,y:3},{x:4,y:3},{x:5,y:3},{x:5,y:2},{x:5,y:1},{x:4,y:1},{x:3,y:1},{x:2,y:1},{x:1,y:1}],",
            "[{x:1,y:1},{x:2,y:1},{x:1,y:1},{x:1,y:2},{x:1,y:3},{x:1,y:4},{x:1,y:5},{x:2,y:5},{x:3,y:5},{x:3,y:6},{x:3,y:7},{x:4,y:7},{x:5,y:7},{x:6,y:7},{x:7,y:7}]]"
          ]
        }
      }
    },
    {
      "title": "MD4",
      "description": [
        "Find the MD4 message digest of a string of <a href=\"http://rosettacode.org/wiki/octet\">octet</a>s.",
        "<b>MD4</b> is an obsolete hash function that computes a 128-bit message digest that sometimes appears in obsolete protocols.",
        "RFC 1320 specifies the MD4 algorithm. RFC 6150 declares that MD4 is obsolete."
      ],
      "solutions": [
        "function md4 (inputStr) {\n  var hexcase = 0;\n  var b64pad  = \"\";\n  var chrsz   = 8;\n\n  function hex_md4(s){ return binl2hex(core_md4(str2binl(s), s.length * chrsz));}\n  function b64_md4(s){ return binl2b64(core_md4(str2binl(s), s.length * chrsz));}\n  function str_md4(s){ return binl2str(core_md4(str2binl(s), s.length * chrsz));}\n  function hex_hmac_md4(key, data) { return binl2hex(core_hmac_md4(key, data)); }\n  function b64_hmac_md4(key, data) { return binl2b64(core_hmac_md4(key, data)); }\n  function str_hmac_md4(key, data) { return binl2str(core_hmac_md4(key, data)); }\n\n  function core_md4(x, len)\n  {\n    x[len >> 5] |= 0x80 << (len % 32);\n    x[(((len + 64) >>> 9) << 4) + 14] = len;\n\n    var a =  1732584193;\n    var b = -271733879;\n    var c = -1732584194;\n    var d =  271733878;\n\n    for(var i = 0; i < x.length; i += 16)\n    {\n      var olda = a;\n      var oldb = b;\n      var oldc = c;\n      var oldd = d;\n\n      a = md4_ff(a, b, c, d, x[i+ 0], 3 );\n      d = md4_ff(d, a, b, c, x[i+ 1], 7 );\n      c = md4_ff(c, d, a, b, x[i+ 2], 11);\n      b = md4_ff(b, c, d, a, x[i+ 3], 19);\n      a = md4_ff(a, b, c, d, x[i+ 4], 3 );\n      d = md4_ff(d, a, b, c, x[i+ 5], 7 );\n      c = md4_ff(c, d, a, b, x[i+ 6], 11);\n      b = md4_ff(b, c, d, a, x[i+ 7], 19);\n      a = md4_ff(a, b, c, d, x[i+ 8], 3 );\n      d = md4_ff(d, a, b, c, x[i+ 9], 7 );\n      c = md4_ff(c, d, a, b, x[i+10], 11);\n      b = md4_ff(b, c, d, a, x[i+11], 19);\n      a = md4_ff(a, b, c, d, x[i+12], 3 );\n      d = md4_ff(d, a, b, c, x[i+13], 7 );\n      c = md4_ff(c, d, a, b, x[i+14], 11);\n      b = md4_ff(b, c, d, a, x[i+15], 19);\n\n      a = md4_gg(a, b, c, d, x[i+ 0], 3 );\n      d = md4_gg(d, a, b, c, x[i+ 4], 5 );\n      c = md4_gg(c, d, a, b, x[i+ 8], 9 );\n      b = md4_gg(b, c, d, a, x[i+12], 13);\n      a = md4_gg(a, b, c, d, x[i+ 1], 3 );\n      d = md4_gg(d, a, b, c, x[i+ 5], 5 );\n      c = md4_gg(c, d, a, b, x[i+ 9], 9 );\n      b = md4_gg(b, c, d, a, x[i+13], 13);\n      a = md4_gg(a, b, c, d, x[i+ 2], 3 );\n      d = md4_gg(d, a, b, c, x[i+ 6], 5 );\n      c = md4_gg(c, d, a, b, x[i+10], 9 );\n      b = md4_gg(b, c, d, a, x[i+14], 13);\n      a = md4_gg(a, b, c, d, x[i+ 3], 3 );\n      d = md4_gg(d, a, b, c, x[i+ 7], 5 );\n      c = md4_gg(c, d, a, b, x[i+11], 9 );\n      b = md4_gg(b, c, d, a, x[i+15], 13);\n\n      a = md4_hh(a, b, c, d, x[i+ 0], 3 );\n      d = md4_hh(d, a, b, c, x[i+ 8], 9 );\n      c = md4_hh(c, d, a, b, x[i+ 4], 11);\n      b = md4_hh(b, c, d, a, x[i+12], 15);\n      a = md4_hh(a, b, c, d, x[i+ 2], 3 );\n      d = md4_hh(d, a, b, c, x[i+10], 9 );\n      c = md4_hh(c, d, a, b, x[i+ 6], 11);\n      b = md4_hh(b, c, d, a, x[i+14], 15);\n      a = md4_hh(a, b, c, d, x[i+ 1], 3 );\n      d = md4_hh(d, a, b, c, x[i+ 9], 9 );\n      c = md4_hh(c, d, a, b, x[i+ 5], 11);\n      b = md4_hh(b, c, d, a, x[i+13], 15);\n      a = md4_hh(a, b, c, d, x[i+ 3], 3 );\n      d = md4_hh(d, a, b, c, x[i+11], 9 );\n      c = md4_hh(c, d, a, b, x[i+ 7], 11);\n      b = md4_hh(b, c, d, a, x[i+15], 15);\n\n      a = safe_add(a, olda);\n      b = safe_add(b, oldb);\n      c = safe_add(c, oldc);\n      d = safe_add(d, oldd);\n\n    }\n    return Array(a, b, c, d);\n\n  }\n\n  function md4_cmn(q, a, b, x, s, t)\n  {\n    return safe_add(rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);\n  }\n  function md4_ff(a, b, c, d, x, s)\n  {\n    return md4_cmn((b & c) | ((~b) & d), a, 0, x, s, 0);\n  }\n  function md4_gg(a, b, c, d, x, s)\n  {\n    return md4_cmn((b & c) | (b & d) | (c & d), a, 0, x, s, 1518500249);\n  }\n  function md4_hh(a, b, c, d, x, s)\n  {\n    return md4_cmn(b ^ c ^ d, a, 0, x, s, 1859775393);\n  }\n\n  function core_hmac_md4(key, data)\n  {\n    var bkey = str2binl(key);\n    if(bkey.length > 16) bkey = core_md4(bkey, key.length * chrsz);\n\n    var ipad = Array(16), opad = Array(16);\n    for(var i = 0; i < 16; i++)\n    {\n      ipad[i] = bkey[i] ^ 0x36363636;\n      opad[i] = bkey[i] ^ 0x5C5C5C5C;\n    }\n\n    var hash = core_md4(ipad.concat(str2binl(data)), 512 + data.length * chrsz);\n    return core_md4(opad.concat(hash), 512 + 128);\n  }\n\n  function safe_add(x, y)\n  {\n    var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n    return (msw << 16) | (lsw & 0xFFFF);\n  }\n\n  function rol(num, cnt)\n  {\n    return (num << cnt) | (num >>> (32 - cnt));\n  }\n\n  function str2binl(str)\n  {\n    var bin = Array();\n    var mask = (1 << chrsz) - 1;\n    for(var i = 0; i < str.length * chrsz; i += chrsz)\n      bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (i%32);\n    return bin;\n  }\n\n  function binl2str(bin)\n  {\n    var str = \"\";\n    var mask = (1 << chrsz) - 1;\n    for(var i = 0; i < bin.length * 32; i += chrsz)\n      str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & mask);\n    return str;\n  }\n\n  function binl2hex(binarray)\n  {\n    var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\n    var str = \"\";\n    for(var i = 0; i < binarray.length * 4; i++)\n    {\n      str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +\n             hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);\n    }\n    return str;\n  }\n\n  function binl2b64(binarray)\n  {\n    var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    var str = \"\";\n    for(var i = 0; i < binarray.length * 4; i += 3)\n    {\n      var triplet = (((binarray[i   >> 2] >> 8 * ( i   %4)) & 0xFF) << 16)\n                  | (((binarray[i+1 >> 2] >> 8 * ((i+1)%4)) & 0xFF) << 8 )\n                  |  ((binarray[i+2 >> 2] >> 8 * ((i+2)%4)) & 0xFF);\n      for(var j = 0; j < 4; j++)\n      {\n        if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;\n        else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);\n      }\n    }\n    return str;\n  }\n\n  return hex_md4(inputStr)\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>md4</code> should be a function.'",
          "testString":
            "assert(typeof md4=='function','<code>md4</code> should be a function.');"
        },
        {
          "text": "'<code>md4(\"abc\")</code> should return a string.'",
          "testString":
            "assert(typeof md4(\"abc\") == 'string','<code>md4(\"abc\")</code> should return a string.');"
        },
        {
          "text":
            "'<code>md4(\"abc\")</code> should return <code>\"a448017aaf21d8525fc10ae87aa6729d\"</code>.'",
          "testString":
            "assert.equal(md4(\"abc\"),\"a448017aaf21d8525fc10ae87aa6729d\",'<code>md4(\"abc\")</code> should return <code>\"a448017aaf21d8525fc10ae87aa6729d\"</code>.');"
        },
        {
          "text":
            "'<code>md4(\"Rosetta Code\")</code> should return <code>\"a52bcfc6a0d0d300cdc5ddbfbefe478b\"</code>.'",
          "testString":
            "assert.equal(md4(\"Rosetta Code\"),\"a52bcfc6a0d0d300cdc5ddbfbefe478b\",'<code>md4(\"Rosetta Code\")</code> should return <code>\"a52bcfc6a0d0d300cdc5ddbfbefe478b\"</code>.');"
        },
        {
          "text":
            "'<code>md4(\"Goodbye World\")</code> should return <code>\"813b3f911ed80e78224d55eacac3c15f\"</code>.'",
          "testString":
            "assert.equal(md4(\"Goodbye World\"),\"813b3f911ed80e78224d55eacac3c15f\",'<code>md4(\"Goodbye World\")</code> should return <code>\"813b3f911ed80e78224d55eacac3c15f\"</code>.');"
        },
        {
          "text":
            "'<code>md4(\"Hello World\")</code> should return <code>\"77a781b995cf1cfaf39d9e2f5910c2cf\"</code>.'",
          "testString":
            "assert.equal(md4(\"Hello World\"),\"77a781b995cf1cfaf39d9e2f5910c2cf\",'<code>md4(\"Hello World\")</code> should return <code>\"77a781b995cf1cfaf39d9e2f5910c2cf\"</code>.');"
        },
        {
          "text":
            "'<code>md4(\"HEX MD4\")</code> should return <code>\"a2c899b13cf56a839dffa26be7a7e9db\"</code>.'",
          "testString":
            "assert.equal(md4(\"HEX MD4\"),\"a2c899b13cf56a839dffa26be7a7e9db\",'<code>md4(\"HEX MD4\")</code> should return <code>\"a2c899b13cf56a839dffa26be7a7e9db\"</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f12",
      "challengeType": 5,
      "releasedOn": "July 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function md4 (inputStr) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "MD5/Implementation",
      "description": [
        "Encode a string using an MD5 algorithm.  The algorithm can be found on  <a href=\"https://en.wikipedia.org/wiki/Md5#Algorithm\">Wikipedia</a>."
      ],
      "solutions": [
        "function md5 (inputStr) {\n  var hexcase = 0;\n  var b64pad = \"\";\n  var chrsz = 8;\n\n  function hex_md5(s) {\n    return binl2hex(core_md5(str2binl(s), s.length * chrsz));\n  }\n\n  function b64_md5(s) {\n    return binl2b64(core_md5(str2binl(s), s.length * chrsz));\n  }\n\n  function str_md5(s) {\n    return binl2str(core_md5(str2binl(s), s.length * chrsz));\n  }\n\n  function hex_hmac_md5(key, data) {\n    return binl2hex(core_hmac_md5(key, data));\n  }\n\n  function b64_hmac_md5(key, data) {\n    return binl2b64(core_hmac_md5(key, data));\n  }\n\n  function str_hmac_md5(key, data) {\n    return binl2str(core_hmac_md5(key, data));\n  }\n\n  function core_md5(x, len) {\n    x[len >> 5] |= 0x80 << ((len) % 32);\n    x[(((len + 64) >>> 9) << 4) + 14] = len;\n\n    var a = 1732584193;\n    var b = -271733879;\n    var c = -1732584194;\n    var d = 271733878;\n\n    for (var i = 0; i < x.length; i += 16) {\n      var olda = a;\n      var oldb = b;\n      var oldc = c;\n      var oldd = d;\n\n      a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);\n      d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);\n      c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);\n      b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);\n      a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);\n      d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);\n      c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);\n      b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);\n      a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);\n      d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);\n      c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);\n      b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);\n      a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);\n      d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);\n      c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);\n      b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);\n\n      a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);\n      d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);\n      c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);\n      b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);\n      a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);\n      d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);\n      c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);\n      b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);\n      a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);\n      d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);\n      c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);\n      b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);\n      a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);\n      d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);\n      c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);\n      b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);\n\n      a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);\n      d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);\n      c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);\n      b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);\n      a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);\n      d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);\n      c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);\n      b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);\n      a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);\n      d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);\n      c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);\n      b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);\n      a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);\n      d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);\n      c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);\n      b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);\n\n      a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);\n      d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);\n      c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);\n      b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);\n      a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);\n      d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);\n      c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);\n      b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);\n      a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);\n      d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);\n      c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);\n      b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);\n      a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);\n      d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);\n      c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);\n      b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);\n\n      a = safe_add(a, olda);\n      b = safe_add(b, oldb);\n      c = safe_add(c, oldc);\n      d = safe_add(d, oldd);\n    }\n    return Array(a, b, c, d);\n\n  }\n\n  function md5_cmn(q, a, b, x, s, t) {\n    return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);\n  }\n\n  function md5_ff(a, b, c, d, x, s, t) {\n    return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);\n  }\n\n  function md5_gg(a, b, c, d, x, s, t) {\n    return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);\n  }\n\n  function md5_hh(a, b, c, d, x, s, t) {\n    return md5_cmn(b ^ c ^ d, a, b, x, s, t);\n  }\n\n  function md5_ii(a, b, c, d, x, s, t) {\n    return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);\n  }\n\n  function core_hmac_md5(key, data) {\n    var bkey = str2binl(key);\n    if (bkey.length > 16) bkey = core_md5(bkey, key.length * chrsz);\n\n    var ipad = Array(16),\n      opad = Array(16);\n    for (var i = 0; i < 16; i++) {\n      ipad[i] = bkey[i] ^ 0x36363636;\n      opad[i] = bkey[i] ^ 0x5C5C5C5C;\n    }\n\n    var hash = core_md5(ipad.concat(str2binl(data)), 512 + data.length * chrsz);\n    return core_md5(opad.concat(hash), 512 + 128);\n  }\n\n  function safe_add(x, y) {\n    var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n    return (msw << 16) | (lsw & 0xFFFF);\n  }\n\n  function bit_rol(num, cnt) {\n    return (num << cnt) | (num >>> (32 - cnt));\n  }\n\n  function str2binl(str) {\n    var bin = Array();\n    var mask = (1 << chrsz) - 1;\n    for (var i = 0; i < str.length * chrsz; i += chrsz)\n      bin[i >> 5] |= (str.charCodeAt(i / chrsz) & mask) << (i % 32);\n    return bin;\n  }\n\n  function binl2str(bin) {\n    var str = \"\";\n    var mask = (1 << chrsz) - 1;\n    for (var i = 0; i < bin.length * 32; i += chrsz)\n      str += String.fromCharCode((bin[i >> 5] >>> (i % 32)) & mask);\n    return str;\n  }\n\n  function binl2hex(binarray) {\n    var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\n    var str = \"\";\n    for (var i = 0; i < binarray.length * 4; i++) {\n      str += hex_tab.charAt((binarray[i >> 2] >> ((i % 4) * 8 + 4)) & 0xF) +\n        hex_tab.charAt((binarray[i >> 2] >> ((i % 4) * 8)) & 0xF);\n    }\n    return str;\n  }\n\n  function binl2b64(binarray) {\n    var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    var str = \"\";\n    for (var i = 0; i < binarray.length * 4; i += 3) {\n      var triplet = (((binarray[i >> 2] >> 8 * (i % 4)) & 0xFF) << 16) |\n        (((binarray[i + 1 >> 2] >> 8 * ((i + 1) % 4)) & 0xFF) << 8) |\n        ((binarray[i + 2 >> 2] >> 8 * ((i + 2) % 4)) & 0xFF);\n      for (var j = 0; j < 4; j++) {\n        if (i * 8 + j * 6 > binarray.length * 32) str += b64pad;\n        else str += tab.charAt((triplet >> 6 * (3 - j)) & 0x3F);\n      }\n    }\n    return str;\n  }\n\n  return hex_md5(inputStr)\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>md5</code> should be a function.'",
          "testString":
            "assert(typeof md5=='function','<code>md5</code> should be a function.');"
        },
        {
          "text": "'<code>md5(\"\")</code> should return a string.'",
          "testString":
            "assert(typeof md5(\"\") == 'string','<code>md5(\"\")</code> should return a string.');"
        },
        {
          "text":
            "'<code>md5(\"\")</code> should return <code>\"d41d8cd98f00b204e9800998ecf8427e\"</code>.'",
          "testString":
            "assert.equal(md5(\"\"),\"d41d8cd98f00b204e9800998ecf8427e\",'<code>md5(\"\")</code> should return <code>\"d41d8cd98f00b204e9800998ecf8427e\"</code>.');"
        },
        {
          "text":
            "'<code>md5(\"a\")</code> should return <code>\"0cc175b9c0f1b6a831c399e269772661\"</code>.'",
          "testString":
            "assert.equal(md5(\"a\"),\"0cc175b9c0f1b6a831c399e269772661\",'<code>md5(\"a\")</code> should return <code>\"0cc175b9c0f1b6a831c399e269772661\"</code>.');"
        },
        {
          "text":
            "'<code>md5(\"abc\")</code> should return <code>\"900150983cd24fb0d6963f7d28e17f72\"</code>.'",
          "testString":
            "assert.equal(md5(\"abc\"),\"900150983cd24fb0d6963f7d28e17f72\",'<code>md5(\"abc\")</code> should return <code>\"900150983cd24fb0d6963f7d28e17f72\"</code>.');"
        },
        {
          "text":
            "'<code>md5(\"message digest\")</code> should return <code>\"f96b697d7cb7938d525a2f31aaf161d0\"</code>.'",
          "testString":
            "assert.equal(md5(\"message digest\"),\"f96b697d7cb7938d525a2f31aaf161d0\",'<code>md5(\"message digest\")</code> should return <code>\"f96b697d7cb7938d525a2f31aaf161d0\"</code>.');"
        },
        {
          "text":
            "'<code>md5(\"abcdefghijklmnopqrstuvwxyz\")</code> should return <code>\"c3fcd3d76192e4007dfb496cca67e13b\"</code>.'",
          "testString":
            "assert.equal(md5(\"abcdefghijklmnopqrstuvwxyz\"),\"c3fcd3d76192e4007dfb496cca67e13b\",'<code>md5(\"abcdefghijklmnopqrstuvwxyz\")</code> should return <code>\"c3fcd3d76192e4007dfb496cca67e13b\"</code>.');"
        },
        {
          "text":
            "'<code>md5(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\")</code> should return <code>\"d174ab98d277d9f5a5611c2c9f419d9f\"</code>.'",
          "testString":
            "assert.equal(md5(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"),\"d174ab98d277d9f5a5611c2c9f419d9f\",'<code>md5(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\")</code> should return <code>\"d174ab98d277d9f5a5611c2c9f419d9f\"</code>.');"
        },
        {
          "text":
            "'<code>md5(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\")</code> should return <code>\"57edf4a22be3c955ac49da2e2107b67a\"</code>.'",
          "testString":
            "assert.equal(md5(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"),\"57edf4a22be3c955ac49da2e2107b67a\",'<code>md5(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\")</code> should return <code>\"57edf4a22be3c955ac49da2e2107b67a\"</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f13",
      "challengeType": 5,
      "releasedOn": "July 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function md5 (inputStr) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Middle three digits",
      "description": [
        "Write a function that is called with an integer value and returns the middle three digits of the integer.",
        "Note: The order of the middle digits should be preserved."
      ],
      "solutions": [
        "function middleThree (x) {\n  var n=''+Math.abs(x); var l=n.length-1;\n  if(l<2||l%2) return \"\"\n  return n.slice(l/2-1,l/2+2);\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>middleThree</code> should be a function.'",
          "testString":
            "assert(typeof middleThree=='function','<code>middleThree</code> should be a function.');"
        },
        {
          "text": "'<code>middleThree(123)</code> should return a string.'",
          "testString":
            "assert(typeof middleThree(123) == 'string','<code>middleThree(123)</code> should return a string.');"
        },
        {
          "text":
            "'<code>middleThree(123)</code> should return <code>\"123\"</code>.'",
          "testString":
            "assert.equal(middleThree(123),\"123\",'<code>middleThree(123)</code> should return <code>\"123\"</code>.');"
        },
        {
          "text":
            "'<code>middleThree(-10001)</code> should return <code>\"000\"</code>.'",
          "testString":
            "assert.equal(middleThree(-10001),\"000\",'<code>middleThree(-10001)</code> should return <code>\"000\"</code>.');"
        },
        {
          "text":
            "'<code>middleThree(987654321)</code> should return <code>\"654\"</code>.'",
          "testString":
            "assert.equal(middleThree(987654321),\"654\",'<code>middleThree(987654321)</code> should return <code>\"654\"</code>.');"
        },
        {
          "text":
            "'<code>middleThree(-12345)</code> should return <code>\"234\"</code>.'",
          "testString":
            "assert.equal(middleThree(-12345),\"234\",'<code>middleThree(-12345)</code> should return <code>\"234\"</code>.');"
        },
        {
          "text":
            "'<code>middleThree(-100)</code> should return <code>\"100\"</code>.'",
          "testString":
            "assert.equal(middleThree(-100),\"100\",'<code>middleThree(-100)</code> should return <code>\"100\"</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f1c",
      "challengeType": 5,
      "releasedOn": "July 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function middleThree (x) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Modular exponentiation",
      "description": [
        "Write a function that uses a fast algorithm for <a href=\"https://en.wikipedia.org/wiki/Modular exponentiation\">modular exponentiation</a>: $a^b \\mod m$.",
        "The algorithm must work for any integers $a, b, m$ where $b \\ge 0$ and $m > 0$."
      ],
      "solutions": [
        "function modExp (a, b, m) {\n\tvar res=1;\n\tfor(var i=0;i<b;i++)\n\t\tres=res*a%m;\n\n\treturn res;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>modExp</code> should be a function.'",
          "testString":
            "assert(typeof modExp=='function','<code>modExp</code> should be a function.');"
        },
        {
          "text": "'<code>modExp(2,4,6)</code> should return a number.'",
          "testString":
            "assert(typeof modExp(2,4,6) == 'number','<code>modExp(2,4,6)</code> should return a number.');"
        },
        {
          "text": "'<code>modExp(2,4,6)</code> should return <code>4</code>.'",
          "testString":
            "assert.equal(modExp(2,4,6),4,'<code>modExp(2,4,6)</code> should return <code>4</code>.');"
        },
        {
          "text":
            "'<code>modExp(82,4,12)</code> should return <code>4</code>.'",
          "testString":
            "assert.equal(modExp(82,4,12),4,'<code>modExp(82,4,12)</code> should return <code>4</code>.');"
        },
        {
          "text": "'<code>modExp(86,5,9)</code> should return <code>2</code>.'",
          "testString":
            "assert.equal(modExp(86,5,9),2,'<code>modExp(86,5,9)</code> should return <code>2</code>.');"
        },
        {
          "text":
            "'<code>modExp(9,6,19)</code> should return <code>11</code>.'",
          "testString":
            "assert.equal(modExp(9,6,19),11,'<code>modExp(9,6,19)</code> should return <code>11</code>.');"
        },
        {
          "text":
            "'<code>modExp(22,5,53)</code> should return <code>18</code>.'",
          "testString":
            "assert.equal(modExp(22,5,53),18,'<code>modExp(22,5,53)</code> should return <code>18</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f1f",
      "challengeType": 5,
      "releasedOn": "July 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function modExp (a, b, m) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Modular inverse",
      "description": [
        "From <a href=\"http://en.wikipedia.org/wiki/Modular_multiplicative_inverse\">Wikipedia</a>:",
        "In <a href=\"https://en.wikipedia.org/wiki/modular arithmetic\">modular arithmetic</a>,  the <b>modular multiplicative inverse</b> of an <a href=\"http://rosettacode.org/wiki/integer\">integer</a>   <i>a</i>   <a href=\"https://en.wikipedia.org/wiki/modular arithmetic\">modulo</a>   <i>m</i>   is an integer   <i>x</i>   such that",
        "$a\\,x \\equiv 1 \\pmod{m}.$",
        "Or in other words, such that:",
        "$\\exists k \\in Z,\\qquad a\\, x = 1 + k\\,m$",
        "It can be shown that such an inverse exists  if and only if   <i>a</i>   and   <i>m</i>   are <a href=\"https://en.wikipedia.org/wiki/coprime\">coprime</a>,  but we will ignore this for this task.",
        "Write a function that takes $a$ and $m$ as parameters and returns the modulo inverse."
      ],
      "solutions": [
        "function modInverse (a, m) {\n\ta %= m;\n\tfor (var x = 1; x < m; x++) {\n\t\tif ((a*x)%m == 1) {\n\t\t\treturn x;\n\t\t}\n\t}\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>modInverse</code> should be a function.'",
          "testString":
            "assert(typeof modInverse=='function','<code>modInverse</code> should be a function.');"
        },
        {
          "text": "'<code>modInverse(42,2017)</code> should return a number.'",
          "testString":
            "assert(typeof modInverse(42,2017) == 'number','<code>modInverse(42,2017)</code> should return a number.');"
        },
        {
          "text":
            "'<code>modInverse(42,2017)</code> should return <code>1969</code>.'",
          "testString":
            "assert.equal(modInverse(42,2017),1969,'<code>modInverse(42,2017)</code> should return <code>1969</code>.');"
        },
        {
          "text":
            "'<code>modInverse(10,17)</code> should return <code>12</code>.'",
          "testString":
            "assert.equal(modInverse(10,17),12,'<code>modInverse(10,17)</code> should return <code>12</code>.');"
        },
        {
          "text":
            "'<code>modInverse(3,11)</code> should return <code>4</code>.'",
          "testString":
            "assert.equal(modInverse(3,11),4,'<code>modInverse(3,11)</code> should return <code>4</code>.');"
        },
        {
          "text":
            "'<code>modInverse(3,7)</code> should return <code>5</code>.'",
          "testString":
            "assert.equal(modInverse(3,7),5,'<code>modInverse(3,7)</code> should return <code>5</code>.');"
        },
        {
          "text":
            "'<code>modInverse(7,31)</code> should return <code>9</code>.'",
          "testString":
            "assert.equal(modInverse(7,31),9,'<code>modInverse(7,31)</code> should return <code>9</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f20",
      "challengeType": 5,
      "releasedOn": "July 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function modInverse (a, m) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Morse code",
      "description": [
        "<a href=\"https://en.wikipedia.org/wiki/Morse_code\">Morse code</a> is one of the simplest and most versatile methods of telecommunication in existence.",
        "It has been in use for more than 160 years — longer than any other electronic encoding system.",
        "Write a function that takes a string and returns the corresponding Morse Code."
      ],
      "solutions": [
        "function morseCode (data) {\n\tvar code = {\n\t\ta: '._', b: '_...', c: '_._.', d: '_..', e: '.', f: '.._.',\n\t\tg: '__.', h: '....', i: '..', j: '.___', k: '_._', l: '._..',\n\t\tm: '__', n: '_.', o: '___', p: '.__.', q: '__._', r: '._.',\n\t\ts: '...', t: '_', u: '.._', v: '..._', w: '.__', x: '_.._',\n\t\ty: '_.__', z: '__..', 0: '_____', 1: '.____', 2: '..___', 3: '...__',\n\t\t4: '...._', 5: '.....', 6: '_....', 7: '__...', 8: '___..', 9: '____.'\n\t};\n\tvar result=\"\"\n\tfor (var i = 0; i < data.length; i ++) {\n\t\tvar codedata = data.substring(i, i+1);\n\t\tresult += code[codedata];\n\t}\n\treturn result\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>morseCode</code> should be a function.'",
          "testString":
            "assert(typeof morseCode=='function','<code>morseCode</code> should be a function.');"
        },
        {
          "text": "'<code>morseCode(\"a\")</code> should return a string.'",
          "testString":
            "assert(typeof morseCode(\"a\") == 'string','<code>morseCode(\"a\")</code> should return a string.');"
        },
        {
          "text":
            "'<code>morseCode(\"a\")</code> should return <code>\"._\"</code>.'",
          "testString":
            "assert.equal(morseCode(\"a\"),\"._\",'<code>morseCode(\"a\")</code> should return <code>\"._\"</code>.');"
        },
        {
          "text":
            "'<code>morseCode(\"abc\")</code> should return <code>\".__..._._.\"</code>.'",
          "testString":
            "assert.equal(morseCode(\"abc\"),\".__..._._.\",'<code>morseCode(\"abc\")</code> should return <code>\".__..._._.\"</code>.');"
        },
        {
          "text":
            "'<code>morseCode(\"helloworld\")</code> should return <code>\"......_..._..___._____._.._.._..\"</code>.'",
          "testString":
            "assert.equal(morseCode(\"helloworld\"),\"......_..._..___._____._.._.._..\",'<code>morseCode(\"helloworld\")</code> should return <code>\"......_..._..___._____._.._.._..\"</code>.');"
        },
        {
          "text":
            "'<code>morseCode(\"hey123\")</code> should return <code>\"....._.__.____..___...__\"</code>.'",
          "testString":
            "assert.equal(morseCode(\"hey123\"),\"....._.__.____..___...__\",'<code>morseCode(\"hey123\")</code> should return <code>\"....._.__.____..___...__\"</code>.');"
        },
        {
          "text":
            "'<code>morseCode(\"rosetta66\")</code> should return <code>\"._.___....__.__...._....\"</code>.'",
          "testString":
            "assert.equal(morseCode(\"rosetta66\"),\"._.___....__.__...._....\",'<code>morseCode(\"rosetta66\")</code> should return <code>\"._.___....__.__...._....\"</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f23",
      "challengeType": 5,
      "releasedOn": "July 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function morseCode (data) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Move-to-front algorithm",
      "description": [
        "Given a symbol table of a <i>zero-indexed</i> array of all possible input symbols <a href=\"https://en.wikipedia.org/wiki/Move-to-front transform\">this algorithm</a> reversibly transforms a sequence of input symbols into an array of output numbers (indices).",
        "The transform in many cases acts to give frequently repeated input symbols lower indices which is <a href=\"https://en.wikipedia.org/wiki/Move-to-front_transform#Use_in_practical_data_compression_algorithms\"> useful in some compression algorithms</a>.",
        "<pre>",
        "    for each symbol of the input sequence:",
        "        output the index of the symbol in the symbol table",
        "        move that symbol to the front of the symbol table",
        "</pre>",
        "<pre>",
        "    # Using the same starting symbol table",
        "    for each index of the input sequence:",
        "        output the symbol at that index of the symbol table",
        "        move that symbol to the front of the symbol table",
        "</pre>",
        "<table border=1 style='border-collapse:collapse;' cellpadding=5>",
        "<tr>",
        "<th>Input</th>",
        "<th>Output</th>",
        "<th>SymbolTable</th>",
        "</tr>",
        "<tr>",
        "<td><b>b</b>roood</td>",
        "<td>1</td>",
        "<td>'abcdefghijklmnopqrstuvwxyz'</td>",
        "</tr>",
        "<tr>",
        "<td>b<b>r</b>oood</td>",
        "<td>1 17</td>",
        "<td>'bacdefghijklmnopqrstuvwxyz'</td>",
        "</tr>",
        "<tr>",
        "<td>br<b>o</b>ood</td>",
        "<td>1 17 15</td>",
        "<td>'rbacdefghijklmnopqstuvwxyz'</td>",
        "</tr>",
        "<tr>",
        "<td>bro<b>o</b>od</td>",
        "<td>1 17 15 0</td>",
        "<td>'orbacdefghijklmnpqstuvwxyz'</td>",
        "</tr>",
        "<tr>",
        "<td>broo<b>o</b>d</td>",
        "<td>1 17 15 0 0</td>",
        "<td>'orbacdefghijklmnpqstuvwxyz'</td>",
        "</tr>",
        "<tr>",
        "<td>brooo<b>d</b></td>",
        "<td>1 17 15 0 0 5</td>",
        "<td>'orbacdefghijklmnpqstuvwxyz'</td>",
        "</tr>",
        "</table>",
        "Encoding the string of character symbols 'broood' using a symbol table of",
        "the characters 'a'-to-'z'",
        "Decoding the indices back to the original symbol order:",
        "<table border=1 style='border-collapse:collapse;' cellpadding=5>",
        "<tr>",
        "<th>Input</th>",
        "<th>Output</th>",
        "<th>SymbolTable</th>",
        "</tr>",
        "<tr>",
        "<td><b>1</b> 17 15 0 0 5</td>",
        "<td>b</td>",
        "<td>'abcdefghijklmnopqrstuvwxyz'</td>",
        "</tr>",
        "<tr>",
        "<td>1 <b>17</b> 15 0 0 5</td>",
        "<td>br</td>",
        "<td>'bacdefghijklmnopqrstuvwxyz'</td>",
        "</tr>",
        "<tr>",
        "<td>1 17 <b>15</b> 0 0 5</td>",
        "<td>bro</td>",
        "<td>'rbacdefghijklmnopqstuvwxyz'</td>",
        "</tr>",
        "<tr>",
        "<td>1 17 15 <b>0</b> 0 5</td>",
        "<td>broo</td>",
        "<td>'orbacdefghijklmnpqstuvwxyz'</td>",
        "</tr>",
        "<tr>",
        "<td>1 17 15 0 <b>0</b> 5</td>",
        "<td>brooo</td>",
        "<td>'orbacdefghijklmnpqstuvwxyz'</td>",
        "</tr>",
        "<tr>",
        "<td>1 17 15 0 0 <b>5</b></td>",
        "<td>broood</td>",
        "<td>'orbacdefghijklmnpqstuvwxyz'</td>",
        "</tr>",
        "</table>",
        "Write a function that takes two parameters. The first parameter is a boolean. True indicates an encode operation and false indicates a decode operation. The second parameter is either a string or an array to be encoded or decoded, respectively. If it is a string to be encoded, return an array of numbers. If it's an array of numbers to be decoded, return a string."
      ],
      "solutions": [
        "function MTF (encode, data) {\n  var encodeMTF = function(word) {\n    var init = {\n      wordAsNumbers: [],\n      charList: 'abcdefghijklmnopqrstuvwxyz'.split('')\n    };\n\n    return word.split('').reduce(function(acc, char) {\n      var charNum = acc.charList.indexOf(char);\n      acc.wordAsNumbers.push(charNum);\n      acc.charList.unshift(acc.charList.splice(charNum, 1)[0]);\n      return acc;\n    }, init).wordAsNumbers;\n  };\n\n  var decodeMTF = function(numList) {\n    var init = {\n      word: '',\n      charList: 'abcdefghijklmnopqrstuvwxyz'.split('')\n    };\n\n    return numList.reduce(function(acc, num) {\n      acc.word += acc.charList[num];\n      acc.charList.unshift(acc.charList.splice(num, 1)[0]);\n      return acc;\n    }, init).word;\n  };\n\n  return encode ? encodeMTF(data) : decodeMTF(data)\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>MTF</code> should be a function.'",
          "testString":
            "assert(typeof MTF=='function','<code>MTF</code> should be a function.');"
        },
        {
          "text":
            "'<code>MTF(true,'+JSON.stringify(tests[0])+')</code> should return a array.'",
          "testString":
            "assert(Array.isArray(MTF(true,tests[0])),'<code>MTF(true,'+JSON.stringify(tests[0])+')</code> should return a array.');"
        },
        {
          "text":
            "'<code>MTF(true,'+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(MTF(true,tests[0]),results[0],'<code>MTF(true,'+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>MTF(false,'+JSON.stringify(tests[1])+')</code> should return <code>\"broood\"</code>.'",
          "testString":
            "assert.deepEqual(MTF(false,tests[1]),\"broood\",'<code>MTF(false,'+JSON.stringify(tests[1])+')</code> should return <code>\"broood\"</code>.');"
        },
        {
          "text":
            "'<code>MTF(true,'+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(MTF(true,tests[2]),results[1],'<code>MTF(true,'+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>MTF(false,'+JSON.stringify(tests[3])+')</code> should return <code>\"bananaaa\"</code>.'",
          "testString":
            "assert.deepEqual(MTF(false,tests[3]),\"bananaaa\",'<code>MTF(false,'+JSON.stringify(tests[3])+')</code> should return <code>\"bananaaa\"</code>.');"
        },
        {
          "text":
            "'<code>MTF(true,'+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(MTF(true,tests[4]),results[2],'<code>MTF(true,'+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>MTF(false,'+JSON.stringify(tests[5])+')</code> should return <code>\"hiphophiphop\"</code>.'",
          "testString":
            "assert.deepEqual(MTF(false,tests[5]),\"hiphophiphop\",'<code>MTF(false,'+JSON.stringify(tests[5])+')</code> should return <code>\"hiphophiphop\"</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f25",
      "challengeType": 5,
      "releasedOn": "July 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function MTF (encode, data) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "var tests=[",
            "\"broood\",",
            "[1,17,15,0,0,5],",
            "\"bananaaa\",",
            "[1,1,13,1,1,1,0,0],",
            "\"hiphophiphop\",",
            "[7,8,15,2,15,2,2,3,2,2,3,2]]",
            "var results=[",
            "[1,17,15,0,0,5],",
            "[1,1,13,1,1,1,0,0],",
            "[7,8,15,2,15,2,2,3,2,2,3,2]]"
          ]
        }
      }
    },
    {
      "title": "Multifactorial",
      "description": [
        "The factorial of a number, written as $n!$, is defined as $n! = n(n-1)(n-2)...(2)(1)$.",
        "<a href=\"http://mathworld.wolfram.com/Multifactorial.html\">Multifactorials</a> generalize factorials as follows:",
        "$n! = n(n-1)(n-2)...(2)(1)$",
        "$n!! = n(n-2)(n-4)...$",
        "$n!!! = n(n-3)(n-6)...$",
        "$n!!!! = n(n-4)(n-8)...$",
        "$n!!!!! = n(n-5)(n-10)...$",
        "In all cases, the terms in the products are positive integers.",
        "If we define the degree of the multifactorial as the difference in successive terms that are multiplied together for a multifactorial (the number of exclamation marks), then the task is twofold:",
        "Write a function that given n and the degree, calculates the multifactorial."
      ],
      "solutions": [
        "function multiFact (n, deg){\n\tvar result = n;\n\twhile (n >= deg + 1){\n\t\tresult *= (n - deg);\n\t\tn -= deg;\n\t}\n\treturn result;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>multiFact</code> should be a function.'",
          "testString":
            "assert(typeof multiFact=='function','<code>multiFact</code> should be a function.');"
        },
        {
          "text": "'<code>multiFact(10,5)</code> should return a number.'",
          "testString":
            "assert(typeof multiFact(10,5) == 'number','<code>multiFact(10,5)</code> should return a number.');"
        },
        {
          "text":
            "'<code>multiFact(10,5)</code> should return <code>50</code>.'",
          "testString":
            "assert.equal(multiFact(10,5),50,'<code>multiFact(10,5)</code> should return <code>50</code>.');"
        },
        {
          "text":
            "'<code>multiFact(10,1)</code> should return <code>3628800</code>.'",
          "testString":
            "assert.equal(multiFact(10,1),3628800,'<code>multiFact(10,1)</code> should return <code>3628800</code>.');"
        },
        {
          "text":
            "'<code>multiFact(5,2)</code> should return <code>15</code>.'",
          "testString":
            "assert.equal(multiFact(5,2),15,'<code>multiFact(5,2)</code> should return <code>15</code>.');"
        },
        {
          "text":
            "'<code>multiFact(5,1)</code> should return <code>120</code>.'",
          "testString":
            "assert.equal(multiFact(5,1),120,'<code>multiFact(5,1)</code> should return <code>120</code>.');"
        },
        {
          "text":
            "'<code>multiFact(15,10)</code> should return <code>75</code>.'",
          "testString":
            "assert.equal(multiFact(15,10),75,'<code>multiFact(15,10)</code> should return <code>75</code>.');"
        },
        {
          "text":
            "'<code>multiFact(15,2)</code> should return <code>2027025</code>.'",
          "testString":
            "assert.equal(multiFact(15,2),2027025,'<code>multiFact(15,2)</code> should return <code>2027025</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f26",
      "challengeType": 5,
      "releasedOn": "July 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function multiFact (n, deg){", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Multiple regression",
      "description": [
        "Given a set of data vectors in the following format:",
        "$y = \\{ y_1, y_2, ..., y_n \\}\\,$",
        "$X_i = \\{ x_{i1}, x_{i2}, ..., x_{in} \\}, i \\in 1..k\\,$",
        "Compute the vector $\\beta = \\{ \\beta_1, \\beta_2, ..., \\beta_k \\}$ using <a href=\"https://en.wikipedia.org/wiki/Ordinary least squares\">ordinary least squares</a> regression using the following equation:",
        "$y_j = \\Sigma_i \\beta_i \\cdot x_{ij} ,    j \\in 1..n$"
      ],
      "solutions": [
        "function multipleReg (y, x){\n  function Matrix(ary) {\n    this.mtx = ary\n    this.height = ary.length;\n    this.width = ary[0].length;\n  }\n\n  function IdentityMatrix(n) {\n    this.height = n;\n    this.width = n;\n    this.mtx = [];\n    for (var i = 0; i < n; i++) {\n        this.mtx[i] = [];\n        for (var j = 0; j < n; j++) {\n            this.mtx[i][j] = (i == j ? 1 : 0);\n        }\n    }\n  }\n\n  Matrix.prototype.transpose = function() {\n    var transposed = [];\n    for (var i = 0; i < this.width; i++) {\n        transposed[i] = [];\n        for (var j = 0; j < this.height; j++) {\n            transposed[i][j] = this.mtx[j][i];\n        }\n    }\n    return new Matrix(transposed);\n  }\n\n  Matrix.prototype.mult = function(other) {\n    if (this.width != other.height) {\n        throw \"error: incompatible sizes\";\n    }\n\n    var result = [];\n    for (var i = 0; i < this.height; i++) {\n        result[i] = [];\n        for (var j = 0; j < other.width; j++) {\n            var sum = 0;\n            for (var k = 0; k < this.width; k++) {\n                sum += this.mtx[i][k] * other.mtx[k][j];\n            }\n            result[i][j] = sum;\n        }\n    }\n    return new Matrix(result);\n  }\n\n  Matrix.prototype.toReducedRowEchelonForm = function() {\n    var lead = 0;\n    for (var r = 0; r < this.height; r++) {\n        if (this.width <= lead) {\n            return;\n        }\n        var i = r;\n        while (this.mtx[i][lead] == 0) {\n            i++;\n            if (this.height == i) {\n                i = r;\n                lead++;\n                if (this.width == lead) {\n                    return;\n                }\n            }\n        }\n\n        var tmp = this.mtx[i];\n        this.mtx[i] = this.mtx[r];\n        this.mtx[r] = tmp;\n\n        var val = this.mtx[r][lead];\n        for (var j = 0; j < this.width; j++) {\n            this.mtx[r][j] /= val;\n        }\n\n        for (var i = 0; i < this.height; i++) {\n            if (i == r) continue;\n            val = this.mtx[i][lead];\n            for (var j = 0; j < this.width; j++) {\n                this.mtx[i][j] -= val * this.mtx[r][j];\n            }\n        }\n        lead++;\n    }\n    return this;\n  }\n\n  Matrix.prototype.inverse = function() {\n      if (this.height != this.width) {\n          throw \"can't invert a non-square matrix\";\n      }\n\n      var I = new IdentityMatrix(this.height);\n      for (var i = 0; i < this.height; i++)\n          this.mtx[i] = this.mtx[i].concat(I.mtx[i])\n      this.width *= 2;\n\n      this.toReducedRowEchelonForm();\n\n      for (var i = 0; i < this.height; i++)\n          this.mtx[i].splice(0, this.height);\n      this.width /= 2;\n\n      return this;\n  }\n\n  function ColumnVector(ary) {\n      return new Matrix(ary.map(function(v) {return [v]}))\n  }\n\n  ColumnVector.prototype = Matrix.prototype\n\n  Matrix.prototype.regression_coefficients = function(x) {\n      var x_t = x.transpose();\n      return x_t.mult(x).inverse().mult(x_t).mult(this);\n  }\n\n  y = new ColumnVector(y);\n  x = new Matrix(x.map(\n        function(v) {return [Math.pow(v,0), Math.pow(v,1), Math.pow(v,2)]}\n    ));\n\n  return y.regression_coefficients(x).mtx;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>multipleReg</code> should be a function.'",
          "testString":
            "assert(typeof multipleReg=='function','<code>multipleReg</code> should be a function.');"
        },
        {
          "text":
            "'<code>multipleReg('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return a array.'",
          "testString":
            "assert(Array.isArray(multipleReg(tests[0][0],tests[0][1])),'<code>multipleReg('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return a array.');"
        },
        {
          "text":
            "'<code>multipleReg('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(multipleReg(tests[0][0],tests[0][1]),results[0],'<code>multipleReg('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>multipleReg('+JSON.stringify(tests[1][0])+','+JSON.stringify(tests[1][1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(multipleReg(tests[1][0],tests[1][1]),results[1],'<code>multipleReg('+JSON.stringify(tests[1][0])+','+JSON.stringify(tests[1][1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>multipleReg('+JSON.stringify(tests[2][0])+','+JSON.stringify(tests[2][1])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(multipleReg(tests[2][0],tests[2][1]),results[2],'<code>multipleReg('+JSON.stringify(tests[2][0])+','+JSON.stringify(tests[2][1])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>multipleReg('+JSON.stringify(tests[3][0])+','+JSON.stringify(tests[3][1])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(multipleReg(tests[3][0],tests[3][1]),results[3],'<code>multipleReg('+JSON.stringify(tests[3][0])+','+JSON.stringify(tests[3][1])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>multipleReg('+JSON.stringify(tests[4][0])+','+JSON.stringify(tests[4][1])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(multipleReg(tests[4][0],tests[4][1]),results[4],'<code>multipleReg('+JSON.stringify(tests[4][0])+','+JSON.stringify(tests[4][1])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f28",
      "challengeType": 5,
      "releasedOn": "July 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function multipleReg (y, x){", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "var tests=[",
            "[[52.21,53.12,54.48,55.84,57.2,58.57,59.93,61.29,63.11,64.47,66.28,68.1,69.92,72.19,74.46],[1.47,1.5,1.52,1.55,1.57,1.6,1.63,1.65,1.68,1.7,1.73,1.75,1.78,1.8,1.83]],",
            "[[2,10,8,7,9],[1,3,6,6,1]],",
            "[[9,1,5,4,3],[6,10,4,9,6]],",
            "[[5,10,1,7,7,5],[6,5,8,8,4,5]],",
            "[[6,4,2,2,8,8],[5,4,2,7,9,7]]]",
            "var results=[",
            "[[128.8128035798277],[-143.1620228653037],[61.960325442985436]],",
            "[[1.4000000000000359],[4.7166666666666135],[-0.6166666666666599]],",
            "[[-5.161137440757919],[3.7456556082147685],[-0.3096366508688735]],",
            "[[8.716129032259616],[-0.006451612903639159],[-0.07419354838707393]],",
            "[[0.9233390119251643],[0.7455990914252846],[-0.003975014196476778]]]"
          ]
        }
      }
    },
    {
      "title": "Multiplication tables",
      "description": [
        "Produce a $N &times; N$  multiplication table of the kind memorized by rote when in primary (or elementary) school.",
        "Write a function that takes $N$ as a parameter and returns a matrix where $x_{i,j}=i &times; j$ (1-based indexing). If $x_{i,j} is in bottom left triangle, it should be 0."
      ],
      "solutions": [
        "function multTable (r, c) {\n  var res=new Array(r)\n\n  for(var i=0;i<r;i++){\n    res[i]=new Array(c)\n    res[i].fill(0)\n    for(var j=0;j<c;j++){\n      if(i<=j){\n        res[i][j]=(i+1)*(j+1)\n      }\n    }\n  }\n\n  return res\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>multTable</code> should be a function.'",
          "testString":
            "assert(typeof multTable=='function','<code>multTable</code> should be a function.');"
        },
        {
          "text": "'<code>multTable(3,3)</code> should return a array.'",
          "testString":
            "assert(Array.isArray(multTable(3,3)),'<code>multTable(3,3)</code> should return a array.');"
        },
        {
          "text":
            "'<code>multTable(3,3)</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(multTable(3,3),results[0],'<code>multTable(3,3)</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>multTable(4,4)</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(multTable(4,4),results[1],'<code>multTable(4,4)</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>multTable(5,5)</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(multTable(5,5),results[2],'<code>multTable(5,5)</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>multTable(6,6)</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(multTable(6,6),results[3],'<code>multTable(6,6)</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>multTable(7,7)</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(multTable(7,7),results[4],'<code>multTable(7,7)</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f29",
      "challengeType": 5,
      "releasedOn": "July 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function multTable (r, c) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "var results=[",
            "[[1,2,3],[0,4,6],[0,0,9]],",
            "[[1,2,3,4],[0,4,6,8],[0,0,9,12],[0,0,0,16]],",
            "[[1,2,3,4,5],[0,4,6,8,10],[0,0,9,12,15],[0,0,0,16,20],[0,0,0,0,25]],",
            "[[1,2,3,4,5,6],[0,4,6,8,10,12],[0,0,9,12,15,18],[0,0,0,16,20,24],[0,0,0,0,25,30],[0,0,0,0,0,36]],",
            "[[1,2,3,4,5,6,7],[0,4,6,8,10,12,14],[0,0,9,12,15,18,21],[0,0,0,16,20,24,28],[0,0,0,0,25,30,35],[0,0,0,0,0,36,42],[0,0,0,0,0,0,49]]]"
          ]
        }
      }
    },
    {
      "title": "Multiplicative order",
      "description": [
        "The <b>multiplicative order</b> of <i>a</i> relative to <i>m</i> is the least positive integer <i>n</i> such that <i>a^n</i> is 1 (modulo <i>m</i>).",
        "The multiplicative order of 37 relative to 1000 is 100 because 37^100 is 1 (modulo 1000), and no number smaller than 100 would do.",
        "One possible algorithm that is efficient also for large numbers is the following: By the <a href=\"https://en.wikipedia.org/wiki/Chinese_Remainder_Theorem\">Chinese Remainder Theorem</a>, it's enough to calculate the multiplicative order for each prime exponent <i>p^k</i> of <i>m</i>, and combine the results with the <i><a href=\"http://rosettacode.org/wiki/least common multiple\">least common multiple</a></i> operation.",
        "Now the order of <i>a</i> with regard to <i>p^k</i> must divide &Phi;(p^k)</i>. Call this number <i>t</i>, and determine it's factors <i>q^e</i>. Since each multiple of the order will also yield 1 when used as exponent for <i>a</i>, it's enough to find the least d such that <i>(q^d)*(t/(q^e))</i> yields 1 when used as exponent.",
        "Implement a routine to calculate the multiplicative order along these lines.",
        "Show how to compute the order of an element<tt> a </tt>in<tt> (Z/(p))<sup>*</sup> </tt>using<tt> O((lg p)<sup>4</sup>/(lg lg p)) </tt>bit operations.",
        "Let the prime factorization of<tt> p-1 </tt> be<tt> q1<sup>e1</sup>q2<sup>e2</sup>...qk<sup>ek</sup></tt> .We use the following observation:",
        "if<tt> x^((p-1)/qi<sup>fi</sup>) = 1 (mod p)</tt> ,",
        "and<tt> fi=ei </tt>or<tt> x^((p-1)/qi<sup>fi+1</sup>) != 1 (mod p)</tt> ,then<tt> qi<sup>ei-fi</sup>||ord<sub>p</sub> x</tt>.",
        "Hence it suffices to find, for each<tt> i</tt> ,the exponent<tt> fi </tt> such that the condition above holds.",
        "This can be done as follows: first compute<tt> q1<sup>e1</sup>, q2<sup>e2</sup>, ... , qk<sup>ek</sup></tt> .",
        "Next, compute<tt> y1=(p-1)/q1<sup>e1</sup>, ... , yk=(p-1)/qk<sup>ek</sup></tt> .",
        "Now, using the binary method, compute<tt> x1=a<sup>y1</sup>(mod p), ... ,  xk=a<sup>yk</sup>(mod p) </tt>.",
        "This can be done using<tt> O(k(lg p)<sup>3</sup>) </tt>bit operations, and<tt> k=O((lg p)/(lg lg p)) </tt>by Theorem 8.8.10.",
        "Finally, for each<tt> i</tt> ,repeatedly raise<tt> xi </tt>to the<tt> qi</tt>-th power<tt> (mod p) </tt>(as many as<tt> ei-1 </tt> times), checking to see when 1 is obtained.",
        "This can be done using<tt> O((lg p)<sup>3</sup>) </tt>steps.",
        "The total cost is dominated by<tt> O(k(lg p)<sup>3</sup>)</tt> ,which is<tt> O((lg p)<sup>4</sup>/(lg lg p))</tt>.",
        "Write a function that takes $a$ and $m$ as parameters and returns the multiplicative order."
      ],
      "solutions": [
        "function multiOrder (a, m) {\n  var bits = new Array(65536);\n\n  var primes = new Array(7000),\n    n_primes;\n\n  function prime_factor() {\n    this.p;\n    this.e;\n  }\n\n  function sieve() {\n    var i, j;\n    for (var i = 0; i < bits.length; i++) {\n      bits[i] = 1;\n    }\n    bits[0] = bits[1] = 0;\n    for (i = 0; i < 256; i++)\n      if (bits[i])\n        for (j = i * i; j < 65536; j += i)\n          bits[j] = 0;\n\n    for (i = j = 0; i < 65536; i++)\n      if (bits[i]) primes[j++] = i;\n\n    n_primes = j;\n  }\n\n  function get_prime_factors(n, lst) {\n    var i, e, p;\n    var len = 0;\n\n    for (i = 0; i < n_primes; i++) {\n      p = primes[i];\n      if (p * p > n) break;\n      for (e = 0; !(n % p); n /= p, e++);\n      if (e) {\n        lst[len].p = p;\n        lst[len++].e = e;\n      }\n    }\n\n    return n == 1 ? len : (lst[len].p = n, lst[len].e = 1, ++len);\n  }\n\n  function get_factors(n, lst) {\n    var n_f, len, len2, i, j, k, p;\n    var f = new Array(100);\n\n    for (var i = 0; i < f.length; i++) {\n      f[i] = new prime_factor();\n    }\n\n    n_f = get_prime_factors(n, f);\n\n    len2 = len = lst[0] = 1;\n    for (i = 0; i < n_f; i++, len2 = len)\n      for (j = 0, p = f[i].p; j < f[i].e; j++, p *= f[i].p)\n        for (k = 0; k < len2; k++)\n          lst[len++] = lst[k] * p;\n\n    lst.sort(function(e1, e2) {\n      return e1.p > e2.p\n    })\n    return len;\n  }\n\n  function mpow(a, p, m) {\n    var r = 1;\n    while (p) {\n      if ((1 & p)) r = r * a % m;\n      a = a * a % m;\n      p >>= 1;\n    }\n    return r;\n  }\n\n  function ipow(a, p) {\n    var r = 1;\n    while (p) {\n      if ((1 & p)) r = r * a;\n      a *= a;\n      p >>= 1;\n    }\n    return r;\n  }\n\n  function gcd(m, n) {\n    var t;\n    while (m) {\n      t = m;\n      m = n % m;\n      n = t;\n    }\n    return n;\n  }\n\n  function lcm(m, n) {\n    var g = gcd(m, n);\n    return m / g * n;\n  }\n\n  function multi_order_p(a, p, e) {\n    var fac = new Array(10000);\n    var m = ipow(p, e);\n    var t = m / p * (p - 1);\n    var i, len = get_factors(t, fac);\n    for (i = 0; i < len; i++)\n      if (mpow(a, fac[i], m) == 1)\n        return fac[i];\n    return 0;\n  }\n\n  function multi_order(a, m) {\n    var pf = new Array(100);\n\n    for (var i = 0; i < pf.length; i++) {\n      pf[i] = new prime_factor()\n    }\n\n    var i, len = get_prime_factors(m, pf);\n    var res = 1;\n    for (i = 0; i < len; i++)\n      res = lcm(res, multi_order_p(a, pf[i].p, pf[i].e));\n    return res;\n  }\n\n  sieve();\n\n  return multi_order(a,m)\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>multiOrder</code> should be a function.'",
          "testString":
            "assert(typeof multiOrder=='function','<code>multiOrder</code> should be a function.');"
        },
        {
          "text": "'<code>multiOrder(37,1000)</code> should return a number.'",
          "testString":
            "assert(typeof multiOrder(37,1000) == 'number','<code>multiOrder(37,1000)</code> should return a number.');"
        },
        {
          "text":
            "'<code>multiOrder(37,1000)</code> should return <code>100</code>.'",
          "testString":
            "assert.equal(multiOrder(37,1000),100,'<code>multiOrder(37,1000)</code> should return <code>100</code>.');"
        },
        {
          "text":
            "'<code>multiOrder(54,100001)</code> should return <code>9090</code>.'",
          "testString":
            "assert.equal(multiOrder(54,100001),9090,'<code>multiOrder(54,100001)</code> should return <code>9090</code>.');"
        },
        {
          "text":
            "'<code>multiOrder(37,3343)</code> should return <code>1114</code>.'",
          "testString":
            "assert.equal(multiOrder(37,3343),1114,'<code>multiOrder(37,3343)</code> should return <code>1114</code>.');"
        },
        {
          "text":
            "'<code>multiOrder(37,10000)</code> should return <code>500</code>.'",
          "testString":
            "assert.equal(multiOrder(37,10000),500,'<code>multiOrder(37,10000)</code> should return <code>500</code>.');"
        },
        {
          "text":
            "'<code>multiOrder(37,3344)</code> should return <code>20</code>.'",
          "testString":
            "assert.equal(multiOrder(37,3344),20,'<code>multiOrder(37,3344)</code> should return <code>20</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f2a",
      "challengeType": 5,
      "releasedOn": "July 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function multiOrder (a, m) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Multisplit",
      "description": [
        "It is often necessary to split a string into pieces based on several different (potentially multi-character) separator strings, while still retaining the information about which separators were present in the input.",
        "This is particularly useful when doing small parsing tasks.",
        "The task is to write code to demonstrate this.",
        "The function should take an input string and an ordered collection of separators.",
        "The order of the separators is significant:",
        "The delimiter order represents priority in matching, with the first defined delimiter having the highest priority.",
        "In cases where there would be an ambiguity as to which separator to use at a particular point (e.g., because one separator is a prefix of another) the separator with the highest priority should be used.",
        "Delimiters can be reused and the output from the function should be an ordered sequence of substrings."
      ],
      "solutions": [
        "function multisplit (string, seps) {\n  RegExp.escape = function(text) {\n    return text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n  }\n\n  var sep_regex = RegExp(seps.map(function(sep) {\n    return RegExp.escape(sep);\n  }).join('|'));\n  return string.split(sep_regex);\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>multisplit</code> should be a function.'",
          "testString":
            "assert(typeof multisplit=='function','<code>multisplit</code> should be a function.');"
        },
        {
          "text":
            "'<code>multisplit(\"a!===b=!=c\",'+JSON.stringify(delim)+')</code> should return a array.'",
          "testString":
            "assert(Array.isArray(multisplit(\"a!===b=!=c\",delim)),'<code>multisplit(\"a!===b=!=c\",'+JSON.stringify(delim)+')</code> should return a array.');"
        },
        {
          "text":
            "'<code>multisplit(\"a!===b=!=c\",'+JSON.stringify(delim)+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(multisplit(\"a!===b=!=c\",delim),results[0],'<code>multisplit(\"a!===b=!=c\",'+JSON.stringify(delim)+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>multisplit(\"aaa!===bbb=!=ccc\",'+JSON.stringify(delim)+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(multisplit(\"aaa!===bbb=!=ccc\",delim),results[1],'<code>multisplit(\"aaa!===bbb=!=ccc\",'+JSON.stringify(delim)+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>multisplit(\"g!==h=!=i!==k\",'+JSON.stringify(delim)+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(multisplit(\"g!==h=!=i!==k\",delim),results[2],'<code>multisplit(\"g!==h=!=i!==k\",'+JSON.stringify(delim)+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>multisplit(\"var!==h=!=i!==k\",'+JSON.stringify(delim)+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(multisplit(\"var!==h=!=i!==k\",delim),results[3],'<code>multisplit(\"var!==h=!=i!==k\",'+JSON.stringify(delim)+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>multisplit(\"h=!=i!==k\",'+JSON.stringify(delim)+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(multisplit(\"h=!=i!==k\",delim),results[4],'<code>multisplit(\"h=!=i!==k\",'+JSON.stringify(delim)+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f2b",
      "challengeType": 5,
      "releasedOn": "July 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function multisplit (string, seps) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var delim=[\"==\",\"!=\",\"=\"]",
            "var results=[",
            "[\"a\",\"\",\"b\",\"\",\"c\"],",
            "[\"aaa\",\"\",\"bbb\",\"\",\"ccc\"],",
            "[\"g\",\"\",\"h\",\"\",\"i\",\"\",\"k\"],",
            "[\"var\",\"\",\"h\",\"\",\"i\",\"\",\"k\"],",
            "[\"h\",\"\",\"i\",\"\",\"k\"]]"
          ]
        }
      }
    },
    {
      "title": "Mutual recursion",
      "description": [
        "Two functions are said to be mutually recursive if the first calls the second, and in turn the second calls the first.",
        "Write two mutually recursive functions that compute members of the <a href=\"https://en.wikipedia.org/wiki/Hofstadter sequence#Hofstadter Female and Male sequences\">Hofstadter Female and Male sequences</a> defined as:",
        "$ \\begin{align} F(0) & = 1\\ ;\\ M(0)=0 \\\\ F(n) & =n-M(F(n-1)), \\quad n>0 \\\\ M(n) & =n-F(M(n-1)), \\quad n>0. \\end{align} $"
      ],
      "solutions": [
        "function f (num) {\n return (num === 0) ? 1 : num - m(f(num - 1));\n}\nfunction m(num) {\n return (num === 0) ? 0 : num - f(m(num - 1));\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>f</code> should be a function.'",
          "testString":
            "assert(typeof f=='function','<code>f</code> should be a function.');"
        },
        {
          "text": "'<code>f(5)</code> should return a number.'",
          "testString":
            "assert(typeof f(5) == 'number','<code>f(5)</code> should return a number.');"
        },
        {
          "text": "'<code>f(5)</code> should return <code>3</code>.'",
          "testString":
            "assert.equal(f(5),3,'<code>f(5)</code> should return <code>3</code>.');"
        },
        {
          "text": "'<code>f(9)</code> should return <code>6</code>.'",
          "testString":
            "assert.equal(f(9),6,'<code>f(9)</code> should return <code>6</code>.');"
        },
        {
          "text": "'<code>f(11)</code> should return <code>7</code>.'",
          "testString":
            "assert.equal(f(11),7,'<code>f(11)</code> should return <code>7</code>.');"
        },
        {
          "text": "'<code>f(19)</code> should return <code>12</code>.'",
          "testString":
            "assert.equal(f(19),12,'<code>f(19)</code> should return <code>12</code>.');"
        },
        {
          "text": "'<code>f(16)</code> should return <code>10</code>.'",
          "testString":
            "assert.equal(f(16),10,'<code>f(16)</code> should return <code>10</code>.');"
        },
        {
          "text": "'<code>m</code> should be a function.'",
          "testString":
            "assert(typeof m=='function','<code>m</code> should be a function.');"
        },
        {
          "text": "'<code>m(22)</code> should return a number.'",
          "testString":
            "assert(typeof m(22) == 'number','<code>m(22)</code> should return a number.');"
        },
        {
          "text": "'<code>m(22)</code> should return <code>14</code>.'",
          "testString":
            "assert.equal(m(22),14,'<code>m(22)</code> should return <code>14</code>.');"
        },
        {
          "text": "'<code>m(1)</code> should return <code>0</code>.'",
          "testString":
            "assert.equal(m(1),0,'<code>m(1)</code> should return <code>0</code>.');"
        },
        {
          "text": "'<code>m(23)</code> should return <code>14</code>.'",
          "testString":
            "assert.equal(m(23),14,'<code>m(23)</code> should return <code>14</code>.');"
        },
        {
          "text": "'<code>m(18)</code> should return <code>11</code>.'",
          "testString":
            "assert.equal(m(18),11,'<code>m(18)</code> should return <code>11</code>.');"
        },
        {
          "text": "'<code>m(17)</code> should return <code>11</code>.'",
          "testString":
            "assert.equal(m(17),11,'<code>m(17)</code> should return <code>11</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f2d",
      "challengeType": 5,
      "releasedOn": "July 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function f (num) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "N'th",
      "description": [
        "Write a function/method/subroutine/... that when given an integer greater than or equal to zero returns a string of the number followed by an apostrophe then the <a href=\"https://en.wikipedia.org/wiki/Ordinal number (linguistics)\">ordinal suffix</a>.",
        "Example returns would include <code>1'st 2'nd 3'rd 11'th 111'th 1001'st 1012'th</code>"
      ],
      "solutions": [
        "function fnOrdinalForm (n) {\n  var lstSuffix = 'th st nd rd th th th th th th'.split(' ')\n  return n.toString() + \"'\" + (\n    11 <= n % 100 && 13 >= n % 100 ?\n    \"th\" : lstSuffix[n % 10])\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>fnOrdinalForm</code> should be a function.'",
          "testString":
            "assert(typeof fnOrdinalForm=='function','<code>fnOrdinalForm</code> should be a function.');"
        },
        {
          "text": "'<code>fnOrdinalForm(10)</code> should return a string.'",
          "testString":
            "assert(typeof fnOrdinalForm(10) == 'string','<code>fnOrdinalForm(10)</code> should return a string.');"
        },
        {
          "text":
            "'<code>fnOrdinalForm(10)</code> should return <code>\"10\\'th\"</code>.'",
          "testString":
            "assert.equal(fnOrdinalForm(10),\"10'th\",'<code>fnOrdinalForm(10)</code> should return <code>\"10\\'th\"</code>.');"
        },
        {
          "text":
            "'<code>fnOrdinalForm(874)</code> should return <code>\"874\\'th\"</code>.'",
          "testString":
            "assert.equal(fnOrdinalForm(874),\"874'th\",'<code>fnOrdinalForm(874)</code> should return <code>\"874\\'th\"</code>.');"
        },
        {
          "text":
            "'<code>fnOrdinalForm(579)</code> should return <code>\"579\\'th\"</code>.'",
          "testString":
            "assert.equal(fnOrdinalForm(579),\"579'th\",'<code>fnOrdinalForm(579)</code> should return <code>\"579\\'th\"</code>.');"
        },
        {
          "text":
            "'<code>fnOrdinalForm(1001)</code> should return <code>\"1001\\'st\"</code>.'",
          "testString":
            "assert.equal(fnOrdinalForm(1001),\"1001'st\",'<code>fnOrdinalForm(1001)</code> should return <code>\"1001\\'st\"</code>.');"
        },
        {
          "text":
            "'<code>fnOrdinalForm(1002)</code> should return <code>\"1002\\'nd\"</code>.'",
          "testString":
            "assert.equal(fnOrdinalForm(1002),\"1002'nd\",'<code>fnOrdinalForm(1002)</code> should return <code>\"1002\\'nd\"</code>.');"
        },
        {
          "text":
            "'<code>fnOrdinalForm(36003)</code> should return <code>\"36003\\'rd\"</code>.'",
          "testString":
            "assert.equal(fnOrdinalForm(36003),\"36003'rd\",'<code>fnOrdinalForm(36003)</code> should return <code>\"36003\\'rd\"</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f3c",
      "challengeType": 5,
      "releasedOn": "July 28, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function fnOrdinalForm (n) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "N-queens problem",
      "description": [
        "Write a function to solve the <a href=\"http://rosettacode.org/wiki/WP:Eight_queens_puzzle\">eight queens puzzle</a>. It should take the number of rows and columns as parameters. It should return all the possible solutions for the given board size in the form of a 2D array. The length of each element of this array should be equal to the total number of rows. The i<sup>th</sup> element should be the position of the queen in the i<sup>th</sup> row."
      ],
      "solutions": [
        "function queenPuzzle (rows, columns) {\n\n  function addQueen(newRow, columns, prevSolution) {\n    var newSolutions = [];\n    var prev = queenPuzzle(newRow, columns);\n    for (var i = 0; i < prev.length; i++) {\n      var solution = prev[i];\n      for (var newColumn = 0; newColumn < columns; newColumn++) {\n        if (!hasConflict(newRow, newColumn, solution))\n          newSolutions.push(solution.concat([newColumn]))\n      }\n    }\n    return newSolutions;\n  }\n\n  function hasConflict(newRow, newColumn, solution) {\n    for (var i = 0; i < newRow; i++) {\n      if (solution[i] == newColumn ||\n        solution[i] + i == newColumn + newRow ||\n        solution[i] - i == newColumn - newRow) {\n        return true;\n      }\n    }\n    return false;\n  }\n  if (rows <= 0) {\n    return [\n      []\n    ];\n  } else {\n    return addQueen(rows - 1, columns);\n  }\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>queenPuzzle</code> should be a function.'",
          "testString":
            "assert(typeof queenPuzzle=='function','<code>queenPuzzle</code> should be a function.');"
        },
        {
          "text": "'<code>queenPuzzle(4,4)</code> should return a array.'",
          "testString":
            "assert(Array.isArray(queenPuzzle(4,4)),'<code>queenPuzzle(4,4)</code> should return a array.');"
        },
        {
          "text":
            "'<code>queenPuzzle(4,4)</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(queenPuzzle(4,4),results[0],'<code>queenPuzzle(4,4)</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>queenPuzzle(3,4)</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(queenPuzzle(3,4),results[1],'<code>queenPuzzle(3,4)</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>queenPuzzle(2,4)</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(queenPuzzle(2,4),results[2],'<code>queenPuzzle(2,4)</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>queenPuzzle(6,6)</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(queenPuzzle(6,6),results[3],'<code>queenPuzzle(6,6)</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f3b",
      "challengeType": 5,
      "releasedOn": "July 28, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function queenPuzzle (rows, columns) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var results=[",
            "[[1,3,0,2],[2,0,3,1]],",
            "[[0,3,1],[1,3,0],[2,0,3],[3,0,2]],",
            "[[0,2],[0,3],[1,3],[2,0],[3,0],[3,1]],",
            "[[1,3,5,0,2,4],[2,5,1,4,0,3],[3,0,4,1,5,2],[4,2,0,5,3,1]]]"
          ]
        }
      }
    },
    {
      "title": "Narcissistic decimal number",
      "description": [
        "A <a href=\"http://mathworld.wolfram.com/NarcissisticNumber.html\">Narcissistic decimal number</a> is a non-negative integer, $ n $, that is equal to the sum of the $ m^{th} $ powers of each of the digits in the decimal representation of $n$, where $m$ is the number of digits in the decimal representation of $n$.",
        "Narcissistic (decimal) numbers are sometimes called <b>Armstrong</b> numbers, named after Michael F. Armstrong.",
        "if $ n $ is <b>153</b>",
        "then $ m $, (the number of decimal digits) is <b>3</b>",
        "we have  1<sup>3</sup> + 5<sup>3</sup> + 3<sup>3</sup> = 1 + 125 + 27 = <b>153</b>",
        "and so <b>153</b> is a narcissistic decimal number</span>",
        "Write a function that returns true if the given number is Narcissistic. Otherwise, return false."
      ],
      "solutions": [
        "function isNarc (x) {\n  var str = x.toString(),\n    i,\n    sum = 0,\n    l = str.length;\n  if (x < 0) {\n    return false;\n  } else {\n    for (i = 0; i < l; i++) {\n      sum += Math.pow(str.charAt(i), l);\n    }\n  }\n  return sum == x;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>isNarc</code> should be a function.'",
          "testString":
            "assert(typeof isNarc=='function','<code>isNarc</code> should be a function.');"
        },
        {
          "text": "'<code>isNarc(153)</code> should return a boolean.'",
          "testString":
            "assert(typeof isNarc(153) == 'boolean','<code>isNarc(153)</code> should return a boolean.');"
        },
        {
          "text": "'<code>isNarc(153)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isNarc(153),true,'<code>isNarc(153)</code> should return <code>true</code>.');"
        },
        {
          "text": "'<code>isNarc(4)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isNarc(4),true,'<code>isNarc(4)</code> should return <code>true</code>.');"
        },
        {
          "text": "'<code>isNarc(94)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isNarc(94),false,'<code>isNarc(94)</code> should return <code>false</code>.');"
        },
        {
          "text": "'<code>isNarc(370)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isNarc(370),true,'<code>isNarc(370)</code> should return <code>true</code>.');"
        },
        {
          "text": "'<code>isNarc(24)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isNarc(24),false,'<code>isNarc(24)</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>isNarc(172)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isNarc(172),false,'<code>isNarc(172)</code> should return <code>false</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f30",
      "challengeType": 5,
      "releasedOn": "July 28, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function isNarc (x) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Natural sorting",
      "description": [
        "Natural sorting is the sorting of text that does more than rely on the order of individual characters codes to make the finding of individual strings easier for a <i>human</i> reader.",
        "There is no \"one true way\" to do this, but for the purpose of this task 'natural' orderings might include:",
        "<ul><li> Ignore leading, trailing and multiple adjacent spaces</li> <li> Make all whitespace characters equivalent.</li> <li> Sorting without regard to case.</li> <li> Sorting numeric portions of strings in numeric order. That is split the string into fields on numeric boundaries, then sort on each field, with the rightmost fields being the most significant, and numeric fields of integers treated as numbers.</li> <li> Sort ligatures as separate letters.</li></ul>",
        "Write a function that takes an array of strings as parameter and returns the sorted array."
      ],
      "solutions": [
        "function nsort (input) {\n  var e = function(s) {\n    return (' ' + s + ' ').replace(/[\\s]+/g, ' ').toLowerCase().replace(/[\\d]+/, function(d) {\n      d = '' + 1e20 + d;\n      return d.substring(d.length - 20);\n    });\n  };\n  return input.sort(function(a, b) {\n    return e(a).localeCompare(e(b));\n  });\n};\n\n"
      ],
      "tests": [
        {
          "text": "'<code>nsort</code> should be a function.'",
          "testString":
            "assert(typeof nsort=='function','<code>nsort</code> should be a function.');"
        },
        {
          "text":
            "'<code>nsort('+JSON.stringify(tests[0])+')</code> should return a array.'",
          "testString":
            "assert(Array.isArray(nsort(tests[0])),'<code>nsort('+JSON.stringify(tests[0])+')</code> should return a array.');"
        },
        {
          "text":
            "'<code>nsort('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(nsort(tests[0]),results[0],'<code>nsort('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>nsort('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(nsort(tests[1]),results[1],'<code>nsort('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>nsort('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(nsort(tests[2]),results[2],'<code>nsort('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>nsort('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(nsort(tests[3]),results[3],'<code>nsort('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>nsort('+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(nsort(tests[4]),results[4],'<code>nsort('+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f32",
      "challengeType": 5,
      "releasedOn": "July 28, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function nsort (input) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "var tests=[",
            "[\"file10.txt\",\"\\nfile9.txt\",\"File11.TXT\",\"file12.txt\"],",
            "[\"ignore leading spaces: 2-2\",\" ignore leading spaces: 2-1\",\" ignore leading spaces: 2+0\",\" ignore leading spaces: 2+1\"],",
            "[\"Equiv. spaces: 3-3\",\"Equiv.\\rspaces: 3-2\",\"Equiv.\\x0cspaces: 3-1\",\"Equiv.\\x0bspaces: 3+0\",\"Equiv.\\nspaces: 3+1\",\"Equiv.\\tspaces: 3+2\"],",
            "[\"cASE INDEPENENT: 3-2\",\"caSE INDEPENENT: 3-1\",\"casE INDEPENENT: 3+0\",\"case INDEPENENT: 3+1\"],",
            "[\"The Wind in the Willows\",\"The 40th step more\",\"The 39 steps\",\"Wanda\"]]",
            "var results=[",
            "[\"\\nfile9.txt\",\"file10.txt\",\"File11.TXT\",\"file12.txt\"],",
            "[\" ignore leading spaces: 2-1\",\"ignore leading spaces: 2-2\",\" ignore leading spaces: 2+0\",\" ignore leading spaces: 2+1\"],",
            "[\"Equiv.\\fspaces: 3-1\",\"Equiv.\\rspaces: 3-2\",\"Equiv. spaces: 3-3\",\"Equiv.\\u000bspaces: 3+0\",\"Equiv.\\nspaces: 3+1\",\"Equiv.\\tspaces: 3+2\"],",
            "[\"caSE INDEPENENT: 3-1\",\"cASE INDEPENENT: 3-2\",\"casE INDEPENENT: 3+0\",\"case INDEPENENT: 3+1\"],",
            "[\"The 39 steps\",\"The 40th step more\",\"The Wind in the Willows\",\"Wanda\"]]"
          ]
        }
      }
    },
    {
      "title": "Non-continuous subsequences",
      "description": [
        "Consider some sequence of elements. (It differs from a mere set of elements by having an ordering among members.)",
        "A <i>subsequence</i> contains some subset of the elements of this sequence, in the same order.",
        "A <i>continuous</i> subsequence is one in which no elements are missing between the first and last elements of the subsequence.",
        "Note: Subsequences are defined <i>structurally</i>, not by their contents.",
        "So a sequence <i>a,b,c,d</i> will always have the same subsequences and continuous subsequences, no matter which values are substituted; it may even be the same value.",
        "<b>Task</b>: Find all non-continuous subsequences for a given sequence.",
        "Example: For the sequence  <i>1,2,3,4</i>,  there are five non-continuous subsequences, namely:",
        "<i>1,3</i>",
        "<i>1,4</i>",
        "<i>2,4</i>",
        "<i>1,3,4</i>",
        "<i>1,2,4</i>",
        "Wite a function that returns the non-continuous subsequences of the given sequence."
      ],
      "solutions": [
        "function non_continuous_subsequences (ary) {\n  function is_array_continuous(ary) {\n    if (ary.length < 2)\n      return true;\n    for (var j = 1; j < ary.length; j++) {\n      if (ary[j] - ary[j - 1] != 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function powerset(ary) {\n    var ps = [\n      []\n    ];\n    for (var i = 0; i < ary.length; i++) {\n      for (var j = 0, len = ps.length; j < len; j++) {\n        ps.push(ps[j].concat(ary[i]));\n      }\n    }\n    return ps;\n  }\n\n  ary = powerset(ary)\n  var non_continuous = new Array();\n  for (var i = 0; i < ary.length; i++) {\n    if (!is_array_continuous(ary[i])) {\n      non_continuous.push(ary[i]);\n    }\n  }\n  return non_continuous;\n}\n\n"
      ],
      "tests": [
        {
          "text":
            "'<code>non_continuous_subsequences</code> should be a function.'",
          "testString":
            "assert(typeof non_continuous_subsequences=='function','<code>non_continuous_subsequences</code> should be a function.');"
        },
        {
          "text":
            "'<code>non_continuous_subsequences('+JSON.stringify(tests[0])+')</code> should return a array.'",
          "testString":
            "assert(Array.isArray(non_continuous_subsequences(tests[0])),'<code>non_continuous_subsequences('+JSON.stringify(tests[0])+')</code> should return a array.');"
        },
        {
          "text":
            "'<code>non_continuous_subsequences('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(non_continuous_subsequences(tests[0]),results[0],'<code>non_continuous_subsequences('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>non_continuous_subsequences('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(non_continuous_subsequences(tests[1]),results[1],'<code>non_continuous_subsequences('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>non_continuous_subsequences('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(non_continuous_subsequences(tests[2]),results[2],'<code>non_continuous_subsequences('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>non_continuous_subsequences('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(non_continuous_subsequences(tests[3]),results[3],'<code>non_continuous_subsequences('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>non_continuous_subsequences('+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(non_continuous_subsequences(tests[4]),results[4],'<code>non_continuous_subsequences('+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f35",
      "challengeType": 5,
      "releasedOn": "July 28, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function non_continuous_subsequences (ary) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var tests=[",
            "[1,2,3],",
            "[1,2,3,4],",
            "[1,5,9],",
            "[1,2,3,4,5],",
            "[5,18,14]]",
            "var results=[",
            "[[1,3]],",
            "[[1,3],[1,4],[2,4],[1,2,4],[1,3,4]],",
            "[[1,5],[1,9],[5,9],[1,5,9]],",
            "[[1,3],[1,4],[2,4],[1,2,4],[1,3,4],[1,5],[2,5],[1,2,5],[3,5],[1,3,5],[2,3,5],[1,2,3,5],[1,4,5],[2,4,5],[1,2,4,5],[1,3,4,5]],",
            "[[5,18],[5,14],[18,14],[5,18,14]]]"
          ]
        }
      }
    },
    {
      "title": "Nonoblock",
      "description": [
        "Nonoblock is a chip off the old <a href=\"http://rosettacode.org/wiki/Nonogram solver\">Nonogram</a> puzzle.",
        "Given a row of five cells and a block of two cells followed by a block of 1 cell - in that order, the example could be shown as:",
        "[0,0,0,0,0] # 5 cells and [2, 1] blocks",
        "And would expand to the following 3 possible rows of block positions:",
        "[1,1,0,1,0]",
        "[1,1,0,0,1]",
        "[0,1,1,0,1]",
        "Note how the sets of blocks are always separated by a 0.",
        "Write a function that takes a string and a number as parameters. The string contains digits and gives the size of the blocks. For example: \"21\" = [2,1] blocks. The second parameter is the length/number of cells. The function should return an array with all possible solutions. Each element should be a bit array (an array consisting of 0s and 1s) that represents a solution."
      ],
      "solutions": [
        "function Nonoblock (data, len) {\n  function block() {\n    let sumChars = 0;\n\n    for (let i = 0; i < data.length; i++) {\n      sumChars += parseInt(data[i])\n    }\n\n    let a = data.split(\"\");\n\n    let prep = a.filter(x => \"\" != x)\n      .map(x => repeat(parseInt(x), \"1\"))\n\n    var res=[]\n    for (var r of genSequence(prep, len - sumChars + 1))\n      res.push(r.substring(1))\n\n    return res\n  }\n\n  function genSequence(ones, numZeros) {\n    if (ones.length == 0)\n      return [repeat(numZeros, \"0\")]\n\n    let result = [];\n    for (let x = 1; x < numZeros - ones.length + 2; x++) {\n      let skipOne = ones.slice(1, ones.length)\n      let t = genSequence(skipOne, numZeros - x)\n\n      for (let i = 0; i < t.length; i++) {\n        result.push(repeat(x, \"0\") + ones[0] + t[i]);\n      }\n    }\n\n    return result;\n  }\n\n  function repeat(n, s) {\n    let sb = \"\";\n    for (let i = 0; i < n; i++)\n      sb += s\n    return sb;\n  }\n  return block()\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>Nonoblock</code> should be a function.'",
          "testString":
            "assert(typeof Nonoblock=='function','<code>Nonoblock</code> should be a function.');"
        },
        {
          "text": "'<code>Nonoblock(\"21\",5)</code> should return a array.'",
          "testString":
            "assert(Array.isArray(Nonoblock(\"21\",5)),'<code>Nonoblock(\"21\",5)</code> should return a array.');"
        },
        {
          "text":
            "'<code>Nonoblock(\"21\",5)</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(Nonoblock(\"21\",5),results[0],'<code>Nonoblock(\"21\",5)</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>Nonoblock(\"\",5)</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(Nonoblock(\"\",5),results[1],'<code>Nonoblock(\"\",5)</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>Nonoblock(\"8\",10)</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(Nonoblock(\"8\",10),results[2],'<code>Nonoblock(\"8\",10)</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>Nonoblock(\"2323\",15)</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(Nonoblock(\"2323\",15),results[3],'<code>Nonoblock(\"2323\",15)</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>Nonoblock(\"23\",5)</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(Nonoblock(\"23\",5),results[4],'<code>Nonoblock(\"23\",5)</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f39",
      "challengeType": 5,
      "releasedOn": "July 28, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Nonoblock (data, len) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var results=[",
            "[\"11010\",\"11001\",\"01101\"],",
            "[\"00000\"],",
            "[\"1111111100\",\"0111111110\",\"0011111111\"],",
            "[\"110111011011100\",\"110111011001110\",\"110111011000111\",\"110111001101110\",\"110111001100111\",\"110111000110111\",\"110011101101110\",\"110011101100111\",\"110011100110111\",\"110001110110111\",\"011011101101110\",\"011011101100111\",\"011011100110111\",\"011001110110111\",\"001101110110111\"],",
            "[]]"
          ]
        }
      }
    },
    {
      "title": "Nonogram solver",
      "description": [
        "A <a href=\"https://en.wikipedia.org/wiki/Nonogram\">nonogram</a> is a puzzle that provides numeric clues used to fill in a grid of cells, establishing for each cell whether it is filled or not.",
        "The puzzle solution is typically a picture of some kind.",
        "Each row and column of a rectangular grid is annotated with the lengths of its distinct runs of occupied cells.",
        "Using only these lengths you should find a valid configuration of empty and occupied cells.",
        "Problem:",
        ". . . . . . . .  3",
        ". . . . . . . .  2 1",
        ". . . . . . . .  3 2",
        ". . . . . . . .  2 2",
        ". . . . . . . .  6",
        ". . . . . . . .  1 5",
        ". . . . . . . .  6",
        ". . . . . . . .  1",
        ". . . . . . . .  2",
        "1 3 1 7 5 3 4 3",
        "2 1 5 1",
        "Solution:",
        ". # # # . . . .  3",
        "# # . # . . . .  2 1",
        ". # # # . . # #  3 2",
        ". . # # . . # #  2 2",
        ". . # # # # # #  6",
        "# . # # # # # .  1 5",
        "# # # # # # . .  6",
        ". . . . # . . .  1",
        ". . . # # . . .  2",
        "1 3 1 7 5 3 4 3",
        "2 1 5 1",
        "The problem above could be represented by two lists of lists:",
        "x = [[3], [2,1], [3,2], [2,2], [6], [1,5], [6], [1], [2]]",
        "y = [[1,2], [3,1], [1,5], [7,1], [5], [3], [4], [3]]",
        "A more compact representation of the same problem uses strings,",
        "where the letters represent the numbers, A=1, B=2, etc:",
        "x = \"C BA CB BB F AE F A B\"",
        "y = \"AB CA AE GA E C D C\"",
        "Write a function that takes an array of strings as parameter and returns a 2D bit-matrix as a solution for the given nonogram (represented by the array of strings). Each element of the bit-matrix should be either a 1 for an occupied cell, or a 0 for an unoccupied cell."
      ],
      "solutions": [
        "// noprotect\nfunction NonogramSolver (input){\n  function BitSet(nbits) {\n      var _this = this;\n      if (((typeof nbits === 'number') || nbits === null)) {\n          var __args = Array.prototype.slice.call(arguments);\n          this.bits = null;\n          this.bits = null;\n          (function () {\n              var length = nbits >>> 6;\n              if ((nbits & BitSet.LONG_MASK) !== 0)\n                  ++length;\n              _this.bits = (function (s) { var a = []; while (s-- > 0)\n                  a.push(0); return a; })(length);\n          })();\n      }\n      else if (nbits === undefined) {\n          var __args = Array.prototype.slice.call(arguments);\n          {\n              var __args_1 = Array.prototype.slice.call(arguments);\n              var nbits_1 = 64;\n              this.bits = null;\n              this.bits = null;\n              (function () {\n                  var length = nbits_1 >>> 6;\n                  if ((nbits_1 & BitSet.LONG_MASK) !== 0)\n                      ++length;\n                  _this.bits = (function (s) { var a = []; while (s-- > 0)\n                      a.push(0); return a; })(length);\n              })();\n          }\n      }\n      else\n          throw new Error('invalid overload');\n  }\n  BitSet.LONG_MASK = 63;\n  BitSet.prototype.and = function (bs) {\n      var max = Math.min(this.bits.length, bs.bits.length);\n      var i;\n      for (i = 0; i < max; ++i)\n          this.bits[i] &= bs.bits[i];\n      while ((i < this.bits.length))\n          this.bits[i++] = 0;\n  };\n  BitSet.prototype.clear$int = function (pos) {\n      var offset = pos >> 6;\n      this.ensure(offset);\n      this.bits[offset] &= ~(1 << pos);\n  };\n  BitSet.prototype.get = function (pos) {\n      var offset = pos >> 6;\n      if (offset >= this.bits.length)\n          return false;\n      return (this.bits[offset] & (1 << pos)) !== 0;\n  };\n  BitSet.prototype.isEmpty = function () {\n      for (var i = this.bits.length - 1; i >= 0; i--)\n          if (this.bits[i] !== 0)\n              return false;\n      ;\n      return true;\n  };\n  BitSet.prototype.length = function () {\n      var i;\n      for (i = this.bits.length - 1; i >= 0 && this.bits[i] === 0; --i)\n          ;\n      if (i < 0)\n          return 0;\n      var b = this.bits[i];\n      var len = (i + 1) * 64;\n      while ((b >= 0)) {\n          --len;\n          b <<= 1;\n      }\n      ;\n      return len;\n  };\n  BitSet.prototype.or = function (bs) {\n      this.ensure(bs.bits.length - 1);\n      for (var i = bs.bits.length - 1; i >= 0; i--)\n          this.bits[i] |= bs.bits[i];\n  };\n  BitSet.prototype.set$int = function (pos) {\n      var offset = pos >> 6;\n      this.ensure(offset);\n      this.bits[offset] |= 1 << pos;\n  };\n  BitSet.prototype.set$int$boolean = function (index, value) {\n      if (value)\n          this.set$int(index);\n      else\n          this.clear$int(index);\n  };\n  BitSet.prototype.set$int$int = function (from, to) {\n      if (from < 0 || from > to)\n          throw Object.defineProperty(new Error(), '__classes', { configurable: true, value: ['java.lang.Throwable', 'java.lang.IndexOutOfBoundsException', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.Exception'] });\n      if (from === to)\n          return;\n      var lo_offset = from >>> 6;\n      var hi_offset = to >>> 6;\n      this.ensure(hi_offset);\n      if (lo_offset === hi_offset) {\n          this.bits[hi_offset] |= (-1 << from) & ((1 << to) - 1);\n          return;\n      }\n      this.bits[lo_offset] |= -1 << from;\n      this.bits[hi_offset] |= (1 << to) - 1;\n      for (var i = lo_offset + 1; i < hi_offset; i++)\n          this.bits[i] = -1;\n  };\n  BitSet.prototype.size = function () {\n      return this.bits.length * 64;\n  };\n  BitSet.prototype.ensure = function (lastElt) {\n      if (lastElt >= this.bits.length) {\n          var nd = (function (s) { var a = []; while (s-- > 0)\n              a.push(0); return a; })(lastElt + 1);\n          (function (srcPts, srcOff, dstPts, dstOff, size) { if (srcPts !== dstPts || dstOff >= srcOff + size) {\n              while (--size >= 0)\n                  dstPts[dstOff++] = srcPts[srcOff++];\n          }\n          else {\n              var tmp = srcPts.slice(srcOff, srcOff + size);\n              for (var i = 0; i < size; i++)\n                  dstPts[dstOff++] = tmp[i];\n          } })(this.bits, 0, nd, 0, this.bits.length);\n          this.bits = nd;\n      }\n  };\n\n  function newPuzzle(data) {\n      var rowData = data[0].split(/\\s/);\n      var colData = data[1].split(/\\s/);\n      var cols;\n      var rows;\n      rows = getCandidates(rowData, colData.length);\n      cols = getCandidates(colData, rowData.length);\n      var numChanged;\n      do {\n          numChanged = reduceMutual(cols, rows);\n      } while ((numChanged > 0));\n      var o,res=[];\n      for (var j = 0; j < rows.length; j++) {\n          var row = rows[j];\n          {\n              o = [];\n              for (var i = 0; i < cols.length; i++)\n                  o.push(row[0].get(i) ? 1 : 0);\n              res.push(o)\n          }\n      }\n\n      return res;\n  };\n\n  function getCandidates(data, len) {\n      var result = ([]);\n      for (var ii = 0; ii < data.length; ii++) {\n          var s = data[ii];\n          {\n              var lst = ([]);\n              var sumChars = 0;\n              for (var i = 0; i < s.length; i++)\n                  sumChars += (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(s.charAt(i)) - 'A'.charCodeAt(0) + 1;\n              var prep = ([]);\n              {\n                  var arr = s.split(\"\");\n                  for (var index9341 = 0; index9341 < arr.length; index9341++) {\n                      var ss = arr[index9341];\n                      (prep.push(repeat((function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(ss.charAt(0)) - 'A'.charCodeAt(0) + 1, \"1\")) > 0);\n                  }\n              }\n              {\n                  var arr = genSequence(prep, len - sumChars + 1);\n                  for (var j = 0; j < arr.length; j++) {\n                      var r = arr[j];\n                      {\n                          var bits = (r.substring(1)).split('');\n                          var bitset = new BitSet(bits.length);\n                          for (var i = 0; i < bits.length; i++)\n                              bitset.set$int$boolean(i, (function (c) { return c.charCodeAt == null ? c : c.charCodeAt(0); })(bits[i]) == '1'.charCodeAt(0));\n                          (lst.push(bitset) > 0);\n                      }\n                  }\n              }\n              (result.push(lst) > 0);\n          }\n      }\n      return result;\n  };\n\n  function genSequence(ones, numZeros) {\n      if ((ones.length == 0))\n          return [repeat(numZeros, \"0\")];\n      var result = ([]);\n      for (var x = 1; x < numZeros - ones.length + 2; x++) {\n          var skipOne = (ones.slice(0));\n          skipOne.splice(0, 1);\n          {\n              var arr = genSequence(skipOne, numZeros - x);\n              for (var ii = 0; ii < arr.length; ii++) {\n                  var tail = arr[ii];\n                  (result.push(repeat(x, \"0\") + ones[0] + tail) > 0);\n              }\n          }\n      }\n      ;\n      return result;\n  };\n\n  function repeat(n, s) {\n      var sb = { str: \"\", toString: function () { return this.str; } };\n      for (var i = 0; i < n; i++)\n          (function (sb) { sb.str = sb.str.concat(s); return sb; })(sb);\n      return sb.str;\n  };\n\n  function reduceMutual(cols, rows) {\n      var countRemoved1 = reduce(cols, rows);\n      if (countRemoved1 === -1)\n          return -1;\n      var countRemoved2 = reduce(rows, cols);\n      if (countRemoved2 === -1)\n          return -1;\n      return countRemoved1 + countRemoved2;\n  };\n\n  function reduce(a, b) {\n      var countRemoved = 0;\n      for (var i = 0; i < a.length; i++) {\n          var commonOn = new BitSet();\n          commonOn.set$int$int(0, b.length);\n          var commonOff = new BitSet();\n          {\n              var array9348 = a[i];\n              for (var ii = 0; ii < array9348.length; ii++) {\n                  var candidate = array9348[ii];\n                  {\n                      commonOn.and(candidate);\n                      commonOff.or(candidate);\n                  }\n              }\n          }\n          for (var j = 0; j < b.length; j++) {\n              var fi = i;\n              var fj = j;\n              var rm = false;\n              var item = void 0;\n              for (var bi = 0; bi < b[j].length; bi++) {\n                  item = b[j][bi];\n                  if ((commonOn.get(fj) && !item.get(fi)) || (!commonOff.get(fj) && item.get(fi))) {\n                      rm = true;\n                      b[j].splice(bi, 1);\n                      bi--;\n                  }\n              }\n              ;\n              if (rm)\n                  countRemoved++;\n              if ((b[j].length == 0))\n                  return -1;\n          }\n          ;\n      }\n      ;\n      return countRemoved;\n  };\n\n  return newPuzzle(input)\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>NonogramSolver</code> should be a function.'",
          "testString":
            "assert(typeof NonogramSolver=='function','<code>NonogramSolver</code> should be a function.');"
        },
        {
          "text":
            "'<code>NonogramSolver('+JSON.stringify(tests[0])+')</code> should return a array.'",
          "testString":
            "assert(Array.isArray(NonogramSolver(tests[0])),'<code>NonogramSolver('+JSON.stringify(tests[0])+')</code> should return a array.');"
        },
        {
          "text":
            "'<code>NonogramSolver('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(NonogramSolver(tests[0]),results[0],'<code>NonogramSolver('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>NonogramSolver('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(NonogramSolver(tests[1]),results[1],'<code>NonogramSolver('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>NonogramSolver('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(NonogramSolver(tests[2]),results[2],'<code>NonogramSolver('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>NonogramSolver('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(NonogramSolver(tests[3]),results[3],'<code>NonogramSolver('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f3a",
      "challengeType": 5,
      "releasedOn": "July 28, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function NonogramSolver (input){",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var tests=[",
            "[\"C BA CB BB F AE F A B\",\"AB CA AE GA E C D C\"],",
            "[\"F CAC ACAC CN AAA AABB EBB EAA ECCC HCCC\",\"D D AE CD AE A DA BBB CC AAB BAA AAB DA AAB AAA BAB AAA CD BBA DA\"],",
            "[\"CA BDA ACC BD CCAC CBBAC BBBBB BAABAA ABAD AABB BBH BBBD ABBAAA CCEA AACAAB BCACC ACBH DCH ADBE ADBB DBE ECE DAA DB CC\",\"BC CAC CBAB BDD CDBDE BEBDF ADCDFA DCCFB DBCFC ABDBA BBF AAF BADB DBF AAAAD BDG CEF CBDB BBB FC\"],",
            "[\"E BCB BEA BH BEK AABAF ABAC BAA BFB OD JH BADCF Q Q R AN AAN EI H G\",\"E CB BAB AAA AAA AC BB ACC ACCA AGB AIA AJ AJ ACE AH BAF CAG DAG FAH FJ GJ ADK ABK BL CM\"]]",
            "var results=[",
            "[[0,1,1,1,0,0,0,0],",
            "[1,1,0,1,0,0,0,0],",
            "[0,1,1,1,0,0,1,1],",
            "[0,0,1,1,0,0,1,1],",
            "[0,0,1,1,1,1,1,1],",
            "[1,0,1,1,1,1,1,0],",
            "[1,1,1,1,1,1,0,0],",
            "[0,0,0,0,1,0,0,0],",
            "[0,0,0,1,1,0,0,0]],",
            "",
            "[[0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0],",
            "[0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0],",
            "[0,0,0,1,0,0,1,1,1,0,0,0,1,0,0,0,0,1,1,1],",
            "[0,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],",
            "[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1],",
            "[0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1],",
            "[1,1,1,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0],",
            "[1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0],",
            "[1,1,1,1,1,0,0,1,1,1,0,1,1,1,0,1,1,1,0,0],",
            "[1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1]],",
            "",
            "[[0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0],",
            "[0,0,0,0,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,0],",
            "[0,0,0,0,1,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0],",
            "[0,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],",
            "[0,1,1,1,0,1,1,1,0,1,0,0,0,0,1,1,1,0,0,0],",
            "[1,1,1,0,0,1,1,0,1,1,0,0,0,1,0,1,1,1,0,0],",
            "[1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,1,0,0],",
            "[0,0,0,0,1,1,0,1,0,1,0,0,1,1,0,1,0,1,0,0],",
            "[0,0,0,0,1,0,1,1,0,1,0,0,0,1,1,1,1,0,0,0],",
            "[0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,1,1,0,0,0],",
            "[0,0,0,0,0,1,1,0,1,1,0,0,1,1,1,1,1,1,1,1],",
            "[0,0,0,0,1,1,0,1,1,0,0,0,1,1,0,0,1,1,1,1],",
            "[0,0,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1],",
            "[1,1,1,0,0,1,1,1,0,1,1,1,1,1,0,0,0,0,0,1],",
            "[1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1],",
            "[1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,1,0,1,1,1],",
            "[0,1,0,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,0],",
            "[0,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,0,0],",
            "[0,0,0,1,0,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0],",
            "[0,0,0,1,0,1,1,1,1,0,1,1,0,0,0,1,1,0,0,0],",
            "[0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,1,1,1,1,1],",
            "[0,0,0,1,1,1,1,1,0,1,1,1,0,0,0,1,1,1,1,1],",
            "[0,0,0,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,1],",
            "[0,0,1,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],",
            "[0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0]],",
            "",
            "[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1],",
            "[0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1],",
            "[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1],",
            "[1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0],",
            "[1,1,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0],",
            "[1,0,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,1,1,1,1,1,0,0,0],",
            "[1,0,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0],",
            "[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],",
            "[0,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1],",
            "[0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1],",
            "[0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1],",
            "[0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,1,1,0,0,1,1,1,1,1,1],",
            "[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],",
            "[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],",
            "[0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],",
            "[0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],",
            "[0,0,0,0,0,0,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],",
            "[0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1],",
            "[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],",
            "[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1]]]"
          ]
        }
      }
    },
    {
      "title": "Nth root",
      "description": [
        "Write a function  to implement the algorithm to compute the principal <a href=\"https://en.wikipedia.org/wiki/Nth root\"><i>n</i>th root</a> $\\sqrt[n]A$ of a positive real number <i>A</i>, as explained at the <a href=\"https://en.wikipedia.org/wiki/Nth root algorithm\">Wikipedia page</a>. The function should take 3 parameters. The first will be the number whose root is to be found. The second parameter represents the root number and the third parameter is the precision. The function should return the result rounded to 3 decimal places."
      ],
      "solutions": [
        "function nthRoot (A, n, p) {\n\tvar x_prev = A,x = A / n;\n\twhile(Math.abs(x - x_prev) > p) {\n\t\tx_prev = x;\n\t\tx = ((n - 1.0) * x + A / Math.pow(x, n - 1.0)) / n;\n\t}\n\treturn Math.round(x*1000)/1000;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>nthRoot</code> should be a function.'",
          "testString":
            "assert(typeof nthRoot=='function','<code>nthRoot</code> should be a function.');"
        },
        {
          "text": "'<code>nthRoot(4,2,0.1)</code> should return a number.'",
          "testString":
            "assert(typeof nthRoot(4,2,0.1) == 'number','<code>nthRoot(4,2,0.1)</code> should return a number.');"
        },
        {
          "text":
            "'<code>nthRoot(4,2,0.1)</code> should return <code>2</code>.'",
          "testString":
            "assert.equal(nthRoot(4,2,0.1),2,'<code>nthRoot(4,2,0.1)</code> should return <code>2</code>.');"
        },
        {
          "text":
            "'<code>nthRoot(27,3,0.01)</code> should return <code>3</code>.'",
          "testString":
            "assert.equal(nthRoot(27,3,0.01),3,'<code>nthRoot(27,3,0.01)</code> should return <code>3</code>.');"
        },
        {
          "text":
            "'<code>nthRoot(5,4,1)</code> should return <code>1.578</code>.'",
          "testString":
            "assert.equal(nthRoot(5,4,1),1.578,'<code>nthRoot(5,4,1)</code> should return <code>1.578</code>.');"
        },
        {
          "text":
            "'<code>nthRoot(2,5,0.001)</code> should return <code>1.149</code>.'",
          "testString":
            "assert.equal(nthRoot(2,5,0.001),1.149,'<code>nthRoot(2,5,0.001)</code> should return <code>1.149</code>.');"
        },
        {
          "text":
            "'<code>nthRoot(1728,3,0.001)</code> should return <code>12</code>.'",
          "testString":
            "assert.equal(nthRoot(1728,3,0.001),12,'<code>nthRoot(1728,3,0.001)</code> should return <code>12</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f3d",
      "challengeType": 5,
      "releasedOn": "July 28, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function nthRoot (A, n, p) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Number names",
      "description": [
        "Write a function that spells out a given number in English and returns the resultant string. You should support inputs up to at least one million. It should also support negative numbers."
      ],
      "solutions": [
        "function numberName (value) {\n  const divMod = y => x => [Math.floor(y / x), y % x];\n  let name = '';\n  let quotient, remainder;\n  const dm = divMod(value);\n  const units = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven',\n    'eight', 'nine', 'ten', 'eleven', 'twelve', 'thirteen', 'fourteen',\n    'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen'\n  ];\n  const tens = ['', '', 'twenty', 'thirty', 'forty', 'fifty', 'sixty',\n    'seventy', 'eighty', 'ninety'\n  ];\n  const big = [...['', 'thousand'], ...['m', 'b', 'tr', 'quadr', 'quint',\n    'sext', 'sept', 'oct', 'non', 'dec'\n  ].map(e => `${e}illion`)];\n\n  if (value < 0) {\n    name = `negative ${numberName(-value)}`\n  } else if (value < 20) {\n    name = units[value]\n  } else if (value < 100) {\n    [quotient, remainder] = dm(10);\n    name = `${tens[quotient]} ${units[remainder]}`.replace(' zero', '');\n  } else if (value < 1000) {\n    [quotient, remainder] = dm(100);\n    name = `${numberName(quotient)} hundred and ${numberName(remainder)}`\n      .replace(' and zero', '')\n  } else {\n    const chunks = [];\n    const text = [];\n    while (value !== 0) {\n      [value, remainder] = divMod(value)(1000);\n      chunks.push(remainder);\n    }\n    chunks.forEach((e, i) => {\n      if (e > 0) {\n        text.push(`${numberName(e)}${i === 0 ? '' : ' ' + big[i]}`);\n        if (i === 0 && e < 100) {\n          text.push('and');\n        }\n      }\n    });\n    name = text.reverse().join(', ').replace(', and,', ' and');\n  }\n  return name;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>numberName</code> should be a function.'",
          "testString":
            "assert(typeof numberName=='function','<code>numberName</code> should be a function.');"
        },
        {
          "text": "'<code>numberName(0)</code> should return a string.'",
          "testString":
            "assert(typeof numberName(0) == 'string','<code>numberName(0)</code> should return a string.');"
        },
        {
          "text":
            "'<code>numberName(0)</code> should return <code>\"zero\"</code>.'",
          "testString":
            "assert.equal(numberName(0),\"zero\",'<code>numberName(0)</code> should return <code>\"zero\"</code>.');"
        },
        {
          "text":
            "'<code>numberName(10)</code> should return <code>\"ten\"</code>.'",
          "testString":
            "assert.equal(numberName(10),\"ten\",'<code>numberName(10)</code> should return <code>\"ten\"</code>.');"
        },
        {
          "text":
            "'<code>numberName(30)</code> should return <code>\"thirty\"</code>.'",
          "testString":
            "assert.equal(numberName(30),\"thirty\",'<code>numberName(30)</code> should return <code>\"thirty\"</code>.');"
        },
        {
          "text":
            "'<code>numberName(47)</code> should return <code>\"forty seven\"</code>.'",
          "testString":
            "assert.equal(numberName(47),\"forty seven\",'<code>numberName(47)</code> should return <code>\"forty seven\"</code>.');"
        },
        {
          "text":
            "'<code>numberName(100)</code> should return <code>\"one hundred\"</code>.'",
          "testString":
            "assert.equal(numberName(100),\"one hundred\",'<code>numberName(100)</code> should return <code>\"one hundred\"</code>.');"
        },
        {
          "text":
            "'<code>numberName(999)</code> should return <code>\"nine hundred and ninety nine\"</code>.'",
          "testString":
            "assert.equal(numberName(999),\"nine hundred and ninety nine\",'<code>numberName(999)</code> should return <code>\"nine hundred and ninety nine\"</code>.');"
        },
        {
          "text":
            "'<code>numberName(1000)</code> should return <code>\"one thousand\"</code>.'",
          "testString":
            "assert.equal(numberName(1000),\"one thousand\",'<code>numberName(1000)</code> should return <code>\"one thousand\"</code>.');"
        },
        {
          "text":
            "'<code>numberName(9999)</code> should return <code>\"nine thousand, nine hundred and ninety nine\"</code>.'",
          "testString":
            "assert.equal(numberName(9999),\"nine thousand, nine hundred and ninety nine\",'<code>numberName(9999)</code> should return <code>\"nine thousand, nine hundred and ninety nine\"</code>.');"
        },
        {
          "text":
            "'<code>numberName(123456)</code> should return <code>\"one hundred and twenty three thousand, four hundred and fifty six\"</code>.'",
          "testString":
            "assert.equal(numberName(123456),\"one hundred and twenty three thousand, four hundred and fifty six\",'<code>numberName(123456)</code> should return <code>\"one hundred and twenty three thousand, four hundred and fifty six\"</code>.');"
        },
        {
          "text":
            "'<code>numberName(900000001)</code> should return <code>\"nine hundred million and one\"</code>.'",
          "testString":
            "assert.equal(numberName(900000001),\"nine hundred million and one\",'<code>numberName(900000001)</code> should return <code>\"nine hundred million and one\"</code>.');"
        },
        {
          "text":
            "'<code>numberName(1234567890)</code> should return <code>\"one billion, two hundred and thirty four million, five hundred and sixty seven thousand, eight hundred and ninety\"</code>.'",
          "testString":
            "assert.equal(numberName(1234567890),\"one billion, two hundred and thirty four million, five hundred and sixty seven thousand, eight hundred and ninety\",'<code>numberName(1234567890)</code> should return <code>\"one billion, two hundred and thirty four million, five hundred and sixty seven thousand, eight hundred and ninety\"</code>.');"
        },
        {
          "text":
            "'<code>numberName(-987654321)</code> should return <code>\"negative nine hundred and eighty seven million, six hundred and fifty four thousand, three hundred and twenty one\"</code>.'",
          "testString":
            "assert.equal(numberName(-987654321),\"negative nine hundred and eighty seven million, six hundred and fifty four thousand, three hundred and twenty one\",'<code>numberName(-987654321)</code> should return <code>\"negative nine hundred and eighty seven million, six hundred and fifty four thousand, three hundred and twenty one\"</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f3f",
      "challengeType": 5,
      "releasedOn": "July 28, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function numberName (value) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Numeric error propagation",
      "description": [
        "If  <b>f</b>,  <b>a</b>,  and  <b>b</b>  are values with uncertainties  σ<sub>f</sub>,  σ<sub>a</sub>,  and  σ<sub>b</sub>,  and  <b>c</b>  is a constant; then if  <b>f</b>  is derived from  <b>a</b>,  <b>b</b>,  and  <b>c</b>  in the following ways, then  σ<sub>f</sub>  can be calculated as follows:",
        "Addition/Subtraction",
        "If  f = a &plusmn; c,  or  f = c &plusmn; a  then  <b>σ<sub>f</sub> = σ<sub>a</sub></b>",
        "If  f = a &plusmn; b  then  <b>σ<sub>f</sub><sup>2</sup> = σ<sub>a</sub><sup>2</sup> + σ<sub>b</sub><sup>2</sup></b>",
        "Multiplication/Division",
        "If  f = ca  or  f = ac    then  <b>σ<sub>f</sub> = |cσ<sub>a</sub>|</b>",
        "If  f = ab  or  f = a / b             then  <b>σ<sub>f</sub><sup>2</sup> = f<sup>2</sup>( (σ<sub>a</sub> / a)<sup>2</sup> + (σ<sub>b</sub> / b)<sup>2</sup>)</b>",
        "Exponentiation",
        "If  f = a<sup>c</sup>  then  <b>σ<sub>f</sub> = |fc(σ<sub>a</sub> / a)|</b>",
        "Caution:",
        "This implementation of error propagation does not address issues of dependent and independent values.  It is assumed that  <b>a</b>  and  <b>b</b>  are independent and so the formula for multiplication should not be applied to  <b>a*a</b>  for example.  See  <a href=\"http://rosettacode.org/wiki/Talk:Numeric_error_propagation\">the talk page</a>  for some of the implications of this issue.",
        "<ol><li>Add an uncertain number type to your language that can support addition, subtraction, multiplication, division, and exponentiation between numbers with an associated error term together with 'normal' floating point numbers without an associated error term. Implement enough functionality to perform the following calculations.</li> <li>Calculate the distance between the two points using the classic Pythagorean formula:   d = &radic;<span style=\"text-decoration:overline\">  (x1 - x2)²  +  (y1 - y2)²  </span> </li></ol>",
        "Write a function that takes x1, x2, y1 and y2 as parameters. These parameters are arrays with 2 elements. The first is the value and the second is the error. The function should return the result after the above calculation as an object in this form { \"value\" : val, \"error\" : err }. Both the value and error should be rounded to 4 decimal places."
      ],
      "solutions": [
        "function errorProp(x1, x2, y1, y2) {\n  function Approx(value, error) {\n    var _this = this;\n    if (((typeof value === 'number') || value === null) && ((typeof error === 'number') || error === null)) {\n      var __args = Array.prototype.slice.call(arguments);\n      this.value = 0;\n      this.error = 0;\n      this.value = 0;\n      this.error = 0;\n      (function() {\n        _this.value = value;\n        _this.error = error;\n      })();\n    } else if (((value != null && value instanceof Approx) || value === null) && error === undefined) {\n      var __args = Array.prototype.slice.call(arguments);\n      var b_1 = __args[0];\n      this.value = 0;\n      this.error = 0;\n      this.value = 0;\n      this.error = 0;\n      (function() {\n        _this.value = b_1.value;\n        _this.error = b_1.error;\n      })();\n    } else if (value === undefined && error === undefined) {\n      var __args = Array.prototype.slice.call(arguments);\n      this.value = 0;\n      this.error = 0;\n      this.value = 0;\n      this.error = 0;\n      (function() {\n        _this.value = _this.error = 0;\n      })();\n    } else\n      throw new Error('invalid overload');\n  }\n  Approx.prototype.add$Approx = function(b) {\n    this.value += b.value;\n    this.error = Math.sqrt(this.error * this.error + b.error * b.error);\n    return this;\n  };\n  Approx.prototype.add = function(b) {\n    if (((b != null && b instanceof Approx) || b === null)) {\n      return this.add$Approx(b);\n    } else if (((typeof b === 'number') || b === null)) {\n      return this.add$double(b);\n    } else\n      throw new Error('invalid overload');\n  };\n  Approx.prototype.add$double = function(b) {\n    this.value += b;\n    return this;\n  };\n  Approx.prototype.sub$Approx = function(b) {\n    this.value -= b.value;\n    this.error = Math.sqrt(this.error * this.error + b.error * b.error);\n    return this;\n  };\n  Approx.prototype.sub = function(b) {\n    if (((b != null && b instanceof Approx) || b === null)) {\n      return this.sub$Approx(b);\n    } else if (((typeof b === 'number') || b === null)) {\n      return this.sub$double(b);\n    } else\n      throw new Error('invalid overload');\n  };\n  Approx.prototype.sub$double = function(b) {\n    this.value -= b;\n    return this;\n  };\n  Approx.prototype.mult$Approx = function(b) {\n    var oldVal = this.value;\n    this.value *= b.value;\n    this.error = Math.sqrt(this.value * this.value * (this.error * this.error) / (oldVal * oldVal) + (b.error * b.error) / (b.value * b.value));\n    return this;\n  };\n  Approx.prototype.mult = function(b) {\n    if (((b != null && b instanceof Approx) || b === null)) {\n      return this.mult$Approx(b);\n    } else if (((typeof b === 'number') || b === null)) {\n      return this.mult$double(b);\n    } else\n      throw new Error('invalid overload');\n  };\n  Approx.prototype.mult$double = function(b) {\n    this.value *= b;\n    this.error = Math.abs(b * this.error);\n    return this;\n  };\n  Approx.prototype.div$Approx = function(b) {\n    var oldVal = this.value;\n    this.value /= b.value;\n    this.error = Math.sqrt(this.value * this.value * (this.error * this.error) / (oldVal * oldVal) + (b.error * b.error) / (b.value * b.value));\n    return this;\n  };\n  Approx.prototype.div = function(b) {\n    if (((b != null && b instanceof Approx) || b === null)) {\n      return this.div$Approx(b);\n    } else if (((typeof b === 'number') || b === null)) {\n      return this.div$double(b);\n    } else\n      throw new Error('invalid overload');\n  };\n  Approx.prototype.div$double = function(b) {\n    this.value /= b;\n    this.error = Math.abs(b * this.error);\n    return this;\n  };\n  Approx.prototype.pow = function(b) {\n    var oldVal = this.value;\n    this.value = Math.pow(this.value, b);\n    this.error = Math.abs(this.value * b * (this.error / oldVal));\n    return this;\n  };\n\n  x1 = new Approx(x1[0], x1[1]);\n  y1 = new Approx(y1[0], y1[1]);\n  x2 = new Approx(x2[0], x2[1]);\n  y2 = new Approx(y2[0], y2[1]);\n  x1.sub$Approx(x2).pow(2).add$Approx(y1.sub$Approx(y2).pow(2)).pow(0.5);\n  return {\n    value: Math.round(x1.value * 10000) / 10000,\n    error: Math.round(x1.error * 10000) / 10000\n  };\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>errorProp</code> should be a function.'",
          "testString":
            "assert(typeof errorProp=='function','<code>errorProp</code> should be a function.');"
        },
        {
          "text":
            "'<code>errorProp('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+','+JSON.stringify(tests[0][2])+','+JSON.stringify(tests[0][3])+')</code> should return a object.'",
          "testString":
            "assert(typeof errorProp(tests[0][0],tests[0][1],tests[0][2],tests[0][3]) == 'object','<code>errorProp('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+','+JSON.stringify(tests[0][2])+','+JSON.stringify(tests[0][3])+')</code> should return a object.');"
        },
        {
          "text":
            "'<code>errorProp('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+','+JSON.stringify(tests[0][2])+','+JSON.stringify(tests[0][3])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(errorProp(tests[0][0],tests[0][1],tests[0][2],tests[0][3]),results[0],'<code>errorProp('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+','+JSON.stringify(tests[0][2])+','+JSON.stringify(tests[0][3])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>errorProp('+JSON.stringify(tests[1][0])+','+JSON.stringify(tests[1][1])+','+JSON.stringify(tests[1][2])+','+JSON.stringify(tests[1][3])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(errorProp(tests[1][0],tests[1][1],tests[1][2],tests[1][3]),results[1],'<code>errorProp('+JSON.stringify(tests[1][0])+','+JSON.stringify(tests[1][1])+','+JSON.stringify(tests[1][2])+','+JSON.stringify(tests[1][3])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>errorProp('+JSON.stringify(tests[2][0])+','+JSON.stringify(tests[2][1])+','+JSON.stringify(tests[2][2])+','+JSON.stringify(tests[2][3])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(errorProp(tests[2][0],tests[2][1],tests[2][2],tests[2][3]),results[2],'<code>errorProp('+JSON.stringify(tests[2][0])+','+JSON.stringify(tests[2][1])+','+JSON.stringify(tests[2][2])+','+JSON.stringify(tests[2][3])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>errorProp('+JSON.stringify(tests[3][0])+','+JSON.stringify(tests[3][1])+','+JSON.stringify(tests[3][2])+','+JSON.stringify(tests[3][3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(errorProp(tests[3][0],tests[3][1],tests[3][2],tests[3][3]),results[3],'<code>errorProp('+JSON.stringify(tests[3][0])+','+JSON.stringify(tests[3][1])+','+JSON.stringify(tests[3][2])+','+JSON.stringify(tests[3][3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>errorProp('+JSON.stringify(tests[4][0])+','+JSON.stringify(tests[4][1])+','+JSON.stringify(tests[4][2])+','+JSON.stringify(tests[4][3])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(errorProp(tests[4][0],tests[4][1],tests[4][2],tests[4][3]),results[4],'<code>errorProp('+JSON.stringify(tests[4][0])+','+JSON.stringify(tests[4][1])+','+JSON.stringify(tests[4][2])+','+JSON.stringify(tests[4][3])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f43",
      "challengeType": 5,
      "releasedOn": "July 28, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function errorProp(x1, x2, y1, y2) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var tests=[",
            "[[100,1.1],[50,1.2],[200,2.2],[100,2.33]],",
            "[[10,1.31],[30,1.26],[33,2.6],[43,1.73]],",
            "[[4,1.13],[50,1.5],[50,2.4],[70,2.73]],",
            "[[58,2.23],[19,1.4],[18,2.12],[17,2.37]],",
            "[[99,1.41],[50,1.7],[30,2.21],[100,2.23]]]",
            "var results=[",
            "{ \"value\": 111.8034, \"error\": 2.9572 },",
            "{ \"value\": 22.3607, \"error\": 2.1433 },",
            "{ \"value\": 50.1597, \"error\": 2.251 },",
            "{ \"value\": 39.0128, \"error\": 2.6334 },",
            "{ \"value\": 85.4459, \"error\": 2.867 }",
            "]"
          ]
        }
      }
    },
    {
      "title": "Numerical integration/Gauss-Legendre Quadrature",
      "description": [
        "In a general <a href=\"https://en.wikipedia.org/wiki/Gaussian quadrature\">Gaussian quadrature</a> rule, an definite integral of $f(x)$ is first approximated over the interval $[-1,1]$ by a polynomial approximable function $g(x)$ and a known weighting function $W(x)$.",
        "$\\int_{-1}^1 f(x) \\, dx = \\int_{-1}^1 W(x) g(x) \\, dx$",
        "Those are then approximated by a sum of function values at specified points $x_i$ multiplied by some weights $w_i$:",
        "$\\int_{-1}^1 W(x) g(x) \\, dx \\approx \\sum_{i=1}^n w_i g(x_i)$",
        "In the case of Gauss-Legendre quadrature, the weighting function $W(x) = 1$, so we can approximate an integral of $f(x)$ with:",
        "$\\int_{-1}^1 f(x)\\,dx \\approx \\sum_{i=1}^n w_i f(x_i)$",
        "For this, we first need to calculate the nodes and the weights, but after we have them, we can reuse them for numerious integral evaluations, which greatly speeds up the calculation compared to more <a href=\"http://rosettacode.org/wiki/Numerical Integration\">simple numerical integration methods</a>.",
        "The $n$ evaluation points $x_i$ for a n-point rule, also called \"nodes\", are roots of n-th order <a href=\"https://en.wikipedia.org/wiki/Legendre Polynomials\">Legendre Polynomials</a> $P_n(x)$. Legendre polynomials are defined by the following recursive rule:",
        "$P_0(x) = 1$",
        "$P_1(x) = x$",
        "$nP_{n}(x) = (2n-1)xP_{n-1}(x)-(n-1)P_{n-2}(x)$",
        "There is also a recursive equation for their derivative:",
        "$P_{n}'(x) = \\frac{n}{x^2-1} \\left( x P_n(x) - P_{n-1}(x) \\right)$",
        "The roots of those polynomials are in general not analytically solvable, so they have to be approximated numerically, for example by <a href=\"https://en.wikipedia.org/wiki/Newton's method\">Newton-Raphson iteration</a>:",
        "$x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}$",
        "The first guess $x_0$ for the $i$-th root of a $n$-order polynomial $P_n$ can be given by",
        "$x_0 = \\cos \\left( \\pi \\, \\frac{i - \\frac{1}{4}}{n+\\frac{1}{2}} \\right)$",
        "After we get the nodes $x_i$, we compute the appropriate weights by:",
        "$w_i = \\frac{2}{\\left( 1-x_i^2 \\right) [P'_n(x_i)]^2}$",
        "After we have the nodes and the weights for a n-point quadrature rule, we can approximate an integral over any interval $[a,b]$ by",
        "$\\int_a^b f(x)\\,dx \\approx \\frac{b-a}{2} \\sum_{i=1}^n w_i f\\left(\\frac{b-a}{2}x_i + \\frac{a+b}{2}\\right)$",
        "<b>Task description</b>",
        "Write a function to calculate the value of the below equation. It should take $N$, $from$ and $to$ as parameters. It should return the result rounded to 3 decimal places.",
        "$\\int_{from}^{to} \\exp(x) \\, dx \\approx \\sum_{i=1}^N w_i \\; \\exp(x_i)$"
      ],
      "solutions": [
        "function numericalIntegration (N, from, to) {\n  var lroots,lcoef,weight;\n  function lroots_$LI$() {\n    if (lroots == null)\n      lroots = (function(s) {\n        var a = [];\n        while (s-- > 0)\n          a.push(0);\n        return a;\n      })(N);\n    return lroots;\n  };;\n\n  function weight_$LI$() {\n    if (weight == null)\n      weight = (function(s) {\n        var a = [];\n        while (s-- > 0)\n          a.push(0);\n        return a;\n      })(N);\n    return weight;\n  };;\n\n  function lcoef_$LI$() {\n    if (lcoef == null)\n      lcoef = (function(dims) {\n        var allocate = function(dims) {\n          if (dims.length == 0) {\n            return 0;\n          } else {\n            var array = [];\n            for (var i = 0; i < dims[0]; i++) {\n              array.push(allocate(dims.slice(1)));\n            }\n            return array;\n          }\n        };\n        return allocate(dims);\n      })([N + 1, N + 1]);\n    return lcoef;\n  };;\n\n  function legeCoef() {\n    lcoef_$LI$()[0][0] = lcoef_$LI$()[1][1] = 1;\n    for (var n = 2; n <= N; n++) {\n      lcoef_$LI$()[n][0] = -(n - 1) * lcoef_$LI$()[n - 2][0] / n;\n      for (var i = 1; i <= n; i++) {\n        lcoef_$LI$()[n][i] = ((2 * n - 1) * lcoef_$LI$()[n - 1][i - 1] - (n - 1) * lcoef_$LI$()[n - 2][i]) / n;\n      };\n    };\n  };\n\n  function legeEval(n, x) {\n    var s = lcoef_$LI$()[n][n];\n    for (var i = n; i > 0; i--)\n      s = s * x + lcoef_$LI$()[n][i - 1];\n    return s;\n  };\n\n  function legeDiff(n, x) {\n    return n * (x * legeEval(n, x) - legeEval(n - 1, x)) / (x * x - 1);\n  };\n\n  function legeRoots() {\n    var x;\n    var x1;\n    for (var i = 1; i <= N; i++) {\n      x = Math.cos(Math.PI * (i - 0.25) / (N + 0.5));\n      do {\n        x1 = x;\n        x -= legeEval(N, x) / legeDiff(N, x);\n      } while ((x !== x1));\n      lroots_$LI$()[i - 1] = x;\n      x1 = legeDiff(N, x);\n      weight_$LI$()[i - 1] = 2 / ((1 - x * x) * x1 * x1);\n    };\n  };\n\n  function legeInte(f, a, b) {\n    var c1 = (b - a) / 2;\n    var c2 = (b + a) / 2;\n    var sum = 0;\n    var _loop_1 = function(i) {\n      sum += weight_$LI$()[i] * (function(target) {\n        return (typeof target === 'function') ? target(c1 * lroots_$LI$()[i] + c2) : target.apply(c1 * lroots_$LI$()[i] + c2);\n      })(f);\n    };\n    for (var i = 0; i < N; i++) {\n      _loop_1(i);\n    }\n    return c1 * sum;\n  };\n\n  lcoef_$LI$();\n  weight_$LI$();\n  lroots_$LI$();\n  legeCoef();\n  legeRoots();\n\n  return Math.round(legeInte(x => Math.exp(x), from, to)*1000)/1000;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>numericalIntegration</code> should be a function.'",
          "testString":
            "assert(typeof numericalIntegration=='function','<code>numericalIntegration</code> should be a function.');"
        },
        {
          "text":
            "'<code>numericalIntegration(5,-3,3)</code> should return a number.'",
          "testString":
            "assert(typeof numericalIntegration(5,-3,3) == 'number','<code>numericalIntegration(5,-3,3)</code> should return a number.');"
        },
        {
          "text":
            "'<code>numericalIntegration(5,-3,3)</code> should return <code>20.036</code>.'",
          "testString":
            "assert.equal(numericalIntegration(5,-3,3),20.036,'<code>numericalIntegration(5,-3,3)</code> should return <code>20.036</code>.');"
        },
        {
          "text":
            "'<code>numericalIntegration(5,-9,9)</code> should return <code>7980.062</code>.'",
          "testString":
            "assert.equal(numericalIntegration(5,-9,9),7980.062,'<code>numericalIntegration(5,-9,9)</code> should return <code>7980.062</code>.');"
        },
        {
          "text":
            "'<code>numericalIntegration(6,10,11)</code> should return <code>37847.676</code>.'",
          "testString":
            "assert.equal(numericalIntegration(6,10,11),37847.676,'<code>numericalIntegration(6,10,11)</code> should return <code>37847.676</code>.');"
        },
        {
          "text":
            "'<code>numericalIntegration(4,-3,3)</code> should return <code>20.029</code>.'",
          "testString":
            "assert.equal(numericalIntegration(4,-3,3),20.029,'<code>numericalIntegration(4,-3,3)</code> should return <code>20.029</code>.');"
        },
        {
          "text":
            "'<code>numericalIntegration(5,0,3)</code> should return <code>19.086</code>.'",
          "testString":
            "assert.equal(numericalIntegration(5,0,3),19.086,'<code>numericalIntegration(5,0,3)</code> should return <code>19.086</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f41",
      "challengeType": 5,
      "releasedOn": "July 28, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function numericalIntegration (N, from, to) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Numerical integration",
      "description": [
        "Write a function that calculates the definite integral of a function <span style=\"font-family: serif\"><i>ƒ(x)</i></span> using <i>all</i> five of the following methods:",
        "<a href=\"https://en.wikipedia.org/wiki/Rectangle_method\">rectangular</a> left",
        "<a href=\"https://en.wikipedia.org/wiki/Rectangle_method\">rectangular</a> right",
        "<a href=\"https://en.wikipedia.org/wiki/Rectangle_method\">rectangular</a> midpoint",
        "<a href=\"https://en.wikipedia.org/wiki/Trapezoidal_rule\">trapezium</a>",
        "<a href=\"https://en.wikipedia.org/wiki/Simpson%27s_rule\">Simpson's</a>",
        "Simpson's method is defined by the following pseudo-code:",
        "<pre>",
        "h := (b - a) / n",
        "sum1 := f(a + h/2)",
        "sum2 := 0loop on i from 1 to (n - 1)",
        "    sum1 := sum1 + f(a + h * i + h/2)",
        "    sum2 := sum2 + f(a + h * i)answer := (h / 6) * (f(a) + f(b) + 4*sum1 + 2*sum2)",
        "</pre>",
        "Your function should take in the upper and lower bounds  (<span style=\"font-family: serif\"><i>a</i></span>  and  <span style=\"font-family: serif\"><i>b</i></span>),  and the number of approximations to make in that range  (<span style=\"font-family: serif\"><i>n</i></span>).",
        "<span style=\"font-family: serif\"><i>ƒ(x)</i></span> for this task are as follows: $ x^3, 1/x $ and $ x $",
        "The function should return a 2D array containing the definite integrals for all the functions and methods mentioned above. The 2D array must contain 3 elements, one for each function and the sequence must be as stated above. The element for each function should contain the results of the methods in this sequence: [rectangularLeft, rectangularMidpoint, rectangularRight, trapezium, simpsons]."
      ],
      "solutions": [
        "function numericalIntegration (a, b, n) {\n  var res=[]\n\n  function rectangularLeft(f) {\n    return rectangular(f, 0);\n  };\n  function rectangularMidpoint(f) {\n    return rectangular(f, 1);\n  };\n  function rectangularRight(f) {\n    return rectangular(f, 2);\n  };\n  function trapezium(f) {\n    var range = checkParamsGetRange(a, b, n);\n    var nFloat = n;\n    var sum = 0.0;\n    for (var i = 1; i < n; i++) {\n      var x = a + range * i / nFloat;\n      sum += f(x);\n    };\n    sum += (f(a) + f(b)) / 2.0;\n    return sum * range / nFloat;\n  };\n  function simpsons(f) {\n    var range = checkParamsGetRange(a, b, n);\n    var nFloat = n;\n    var sum1 = f(a + range / (nFloat * 2.0));\n    var sum2 = 0.0;\n    for (var i = 1; i < n; i++) {\n      var x1 = a + range * (i + 0.5) / nFloat;\n      sum1 += f(x1);\n      var x2 = a + range * i / nFloat;\n      sum2 += f(x2);\n    };\n    return (f(a) + f(b) + sum1 * 4.0 + sum2 * 2.0) * range / (nFloat * 6.0);\n  };\n  function rectangular(f, mode) {\n    var range = checkParamsGetRange(a, b, n);\n    var modeOffset = mode / 2.0;\n    var nFloat = n;\n    var sum = 0.0;\n    for (var i = 0; i < n; i++) {\n      var x = a + range * (i + modeOffset) / nFloat;\n      sum += f(x);\n    };\n    return sum * range / nFloat;\n  };\n  function checkParamsGetRange(a, b, n) {\n    if (n <= 0)\n      throw Object.defineProperty(new Error(\"Invalid value of n\"), '__classes', {\n        configurable: true,\n        value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.IllegalArgumentException', 'java.lang.Exception']\n      });\n    var range = b - a;\n    if (range <= 0)\n      throw Object.defineProperty(new Error(\"Invalid range\"), '__classes', {\n        configurable: true,\n        value: ['java.lang.Throwable', 'java.lang.Object', 'java.lang.RuntimeException', 'java.lang.IllegalArgumentException', 'java.lang.Exception']\n      });\n    return range;\n  };\n\n  function roundTo3(num){\n    return Math.round(num*1000)/1000\n  }\n\n  function testFunction(f) {\n    res.push([roundTo3(rectangularLeft(f)),\n      roundTo3(rectangularMidpoint(f)),\n      roundTo3(rectangularRight(f)),\n      roundTo3(trapezium(f)),\n      roundTo3(simpsons(f))])\n  }\n\n  testFunction(x=>x*x*x);\n  testFunction(x=>1/x);\n  testFunction(x=>x);\n\n  return res;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>numericalIntegration</code> should be a function.'",
          "testString":
            "assert(typeof numericalIntegration=='function','<code>numericalIntegration</code> should be a function.');"
        },
        {
          "text":
            "'<code>numericalIntegration(1,100,100)</code> should return a array.'",
          "testString":
            "assert(Array.isArray(numericalIntegration(1,100,100)),'<code>numericalIntegration(1,100,100)</code> should return a array.');"
        },
        {
          "text":
            "'<code>numericalIntegration(1,100,100)</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(numericalIntegration(1,100,100),results[0],'<code>numericalIntegration(1,100,100)</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>numericalIntegration(1,100,1000)</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(numericalIntegration(1,100,1000),results[1],'<code>numericalIntegration(1,100,1000)</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>numericalIntegration(1,50,100)</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(numericalIntegration(1,50,100),results[2],'<code>numericalIntegration(1,50,100)</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>numericalIntegration(1,5,10)</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(numericalIntegration(1,5,10),results[3],'<code>numericalIntegration(1,5,10)</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>numericalIntegration(5,10,100)</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(numericalIntegration(5,10,100),results[4],'<code>numericalIntegration(5,10,100)</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f42",
      "challengeType": 5,
      "releasedOn": "July 28, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function numericalIntegration (a, b, n) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var results=[",
            "[[24507450.25,24998774.748,25497449.26,25002449.755,24999999.75],[5.171,4.569,4.191,4.681,4.607],[4950.495,4999.5,5048.505,4999.5,4999.5]],",
            "[[24950524.3,24999987.5,25049524.201,25000024.25,24999999.75],[4.655,4.605,4.557,4.606,4.605],[4994.6,4999.5,5004.401,4999.5,4999.5]],",
            "[[1532024.997,1562424.749,1593274.507,1562649.752,1562499.75],[4.172,3.902,3.691,3.932,3.912],[1237.495,1249.5,1261.505,1249.5,1249.5]],",
            "[[132.16,155.52,181.76,156.96,156],[1.782,1.603,1.462,1.622,1.609],[11.2,12,12.8,12,12]],",
            "[[2321.922,2343.727,2365.672,2343.797,2343.75],[0.696,0.693,0.691,0.693,0.693],[37.375,37.5,37.625,37.5,37.5]]]"
          ]
        }
      }
    },
    {
      "title": "Optional parameters",
      "description": [
        "Write a function which sorts a 2D array of strings. Besides the input to be sorted, it shall have the following optional parameters (passed as an object):",
        "ordering: A string specifying the ordering of strings. It can be \"lexicographic\" or \"numeric\".",
        "column: An integer specifying which string of each row to compare; the first by default.",
        "reverse: Reverses the ordering."
      ],
      "solutions": [
        "function sorter (table, options) {\n  var ordering = options.ordering || 'lexicographic',\n    column = options.column || 0,\n    reverse = options.reverse || false,\n    numer = ordering == \"numeric\";\n  table.sort(function(a, b) {\n    var swap=a[column].localeCompare(b[column]) > 0\n    if(numer)\n      swap = a[column].localeCompare(b[column],undefined, { numeric: true }) > 0\n\n    if (reverse) {\n      swap = !swap\n    }\n\n    return swap\n  })\n\n  return table\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>sorter</code> should be a function.'",
          "testString":
            "assert(typeof sorter=='function','<code>sorter</code> should be a function.');"
        },
        {
          "text":
            "'<code>sorter('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return a array.'",
          "testString":
            "assert(Array.isArray(sorter(tests[0][0],tests[0][1])),'<code>sorter('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return a array.');"
        },
        {
          "text":
            "'<code>sorter('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(sorter(tests[0][0],tests[0][1]),results[0],'<code>sorter('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>sorter('+JSON.stringify(tests[1][0])+','+JSON.stringify(tests[1][1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(sorter(tests[1][0],tests[1][1]),results[1],'<code>sorter('+JSON.stringify(tests[1][0])+','+JSON.stringify(tests[1][1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>sorter('+JSON.stringify(tests[2][0])+','+JSON.stringify(tests[2][1])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(sorter(tests[2][0],tests[2][1]),results[2],'<code>sorter('+JSON.stringify(tests[2][0])+','+JSON.stringify(tests[2][1])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>sorter('+JSON.stringify(tests[3][0])+','+JSON.stringify(tests[3][1])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(sorter(tests[3][0],tests[3][1]),results[3],'<code>sorter('+JSON.stringify(tests[3][0])+','+JSON.stringify(tests[3][1])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>sorter('+JSON.stringify(tests[4][0])+','+JSON.stringify(tests[4][1])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(sorter(tests[4][0],tests[4][1]),results[4],'<code>sorter('+JSON.stringify(tests[4][0])+','+JSON.stringify(tests[4][1])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f4c",
      "challengeType": 5,
      "releasedOn": "August 3, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function sorter (table, options) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "let tests=[",
            "[[[\"123\",\"456\",\"0789\"],[\"456\",\"0789\",\"123\"],[\"0789\",\"123\",\"456\"]],{\"reverse\":true}],",
            "[[[\"123\",\"456\",\"0789\"],[\"456\",\"0789\",\"123\"],[\"0789\",\"123\",\"456\"]],{\"column\":2,\"reverse\":true}],",
            "[[[\"123\",\"456\",\"0789\"],[\"456\",\"0789\",\"123\"],[\"0789\",\"123\",\"456\"]],{\"ordering\":\"numeric\",\"reverse\":true}],",
            "[[[\"a\",\"b\",\"c\"],[\"\",\"q\",\"z\"],[\"zap\",\"zip\",\"Zot\"]],{\"column\":1}],",
            "[[[\"a\",\"b\",\"c\"],[\"\",\"q\",\"z\"],[\"zap\",\"zip\",\"Zot\"]],{\"column\":1,\"reverse\":true}]]",
            "let results=[",
            "[[\"456\",\"0789\",\"123\"],[\"123\",\"456\",\"0789\"],[\"0789\",\"123\",\"456\"]],",
            "[[\"0789\",\"123\",\"456\"],[\"456\",\"0789\",\"123\"],[\"123\",\"456\",\"0789\"]],",
            "[[\"0789\",\"123\",\"456\"],[\"456\",\"0789\",\"123\"],[\"123\",\"456\",\"0789\"]],",
            "[[\"a\",\"b\",\"c\"],[\"\",\"q\",\"z\"],[\"zap\",\"zip\",\"Zot\"]],",
            "[[\"zap\",\"zip\",\"Zot\"],[\"\",\"q\",\"z\"],[\"a\",\"b\",\"c\"]]]"
          ]
        }
      }
    },
    {
      "title": "Order disjoint list items",
      "description": [
        "Given  <code>M</code>  as a list of items and another list  <code>N</code>  of items chosen from  <code>M</code>,  create  <code>M'</code>  as a list with the <i>first</i> occurrences of items from  N  sorted to be in one of the set of indices of their original occurrence in  <code>M</code>  but in the order given by their order in   <code>N</code>.",
        "That is, items in  <code>N</code>  are taken from  <code>M</code>  without replacement, then the corresponding positions in  <code>M'</code>  are filled by successive items from  <code>N</code>.",
        "if  <code>M</code>  is  <code>'the cat sat on the mat'</code>",
        "And  <code>N</code>  is  <code>'mat cat'</code>",
        "Then the result  <code>M'</code>  is  <code>'the mat sat on the cat'</code>.",
        "The words not in  <code>N</code>  are left in their original positions.",
        "If there are duplications then only the first instances in  <code>M</code>  up to as many as are mentioned in  <code>N</code>  are potentially re-ordered.",
        "<code> M = 'A B C A B C A B C' </code>",
        "<code> N = 'C A C A'</code>",
        "Is ordered as:",
        "<code> M' = 'C B A C B A A B C' </code>"
      ],
      "solutions": [
        "function orderDisjointList (M, N) {\n  const concatMap = (f, xs) => [].concat.apply([], xs.map(f));\n  const deleteFirst = (x, xs) =>\n    xs.length > 0 ? (\n      x === xs[0] ? (\n        xs.slice(1)\n      ) : [xs[0]].concat(deleteFirst(x, xs.slice(1)))\n    ) : [];\n  const flatten = t => (t instanceof Array ? concatMap(flatten, t) : [t]);\n  const unwords = xs => xs.join(' ');\n  const words = s => s.split(/\\s+/);\n  const zipWith = (f, xs, ys) => {\n    const ny = ys.length;\n    return (xs.length <= ny ? xs : xs.slice(0, ny))\n      .map((x, i) => f(x, ys[i]));\n  };\n  const disjointOrder = (ms, ns) =>\n    flatten(\n      zipWith(\n        (a, b) => a.concat(b),\n        segments(ms, ns),\n        ns.concat('')\n      )\n    );\n  const segments = (ms, ns) => {\n    const dct = ms.reduce((a, x) => {\n      const wds = a.words,\n        blnFound = wds.indexOf(x) !== -1;\n      return {\n        parts: a.parts.concat(blnFound ? [a.current] : []),\n        current: blnFound ? [] : a.current.concat(x),\n        words: blnFound ? deleteFirst(x, wds) : wds,\n      };\n    }, {\n      words: ns,\n      parts: [],\n      current: []\n    });\n\n    return dct.parts.concat([dct.current]);\n  };\n  return unwords(disjointOrder(words(M), words(N))).slice(0,-1);\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>orderDisjointList</code> should be a function.'",
          "testString":
            "assert(typeof orderDisjointList=='function','<code>orderDisjointList</code> should be a function.');"
        },
        {
          "text":
            "'<code>orderDisjointList(\"the cat sat on the mat\",\"mat cat\")</code> should return a string.'",
          "testString":
            "assert(typeof orderDisjointList(\"the cat sat on the mat\",\"mat cat\") == 'string','<code>orderDisjointList(\"the cat sat on the mat\",\"mat cat\")</code> should return a string.');"
        },
        {
          "text":
            "'<code>orderDisjointList(\"the cat sat on the mat\",\"mat cat\")</code> should return <code>\"the mat sat on the cat\"</code>.'",
          "testString":
            "assert.equal(orderDisjointList(\"the cat sat on the mat\",\"mat cat\"),\"the mat sat on the cat\",'<code>orderDisjointList(\"the cat sat on the mat\",\"mat cat\")</code> should return <code>\"the mat sat on the cat\"</code>.');"
        },
        {
          "text":
            "'<code>orderDisjointList(\"the cat sat on the mat\",\"cat mat\")</code> should return <code>\"the cat sat on the mat\"</code>.'",
          "testString":
            "assert.equal(orderDisjointList(\"the cat sat on the mat\",\"cat mat\"),\"the cat sat on the mat\",'<code>orderDisjointList(\"the cat sat on the mat\",\"cat mat\")</code> should return <code>\"the cat sat on the mat\"</code>.');"
        },
        {
          "text":
            "'<code>orderDisjointList(\"A B C A B C A B C\",\"C A C A\")</code> should return <code>\"C B A C B A A B C\"</code>.'",
          "testString":
            "assert.equal(orderDisjointList(\"A B C A B C A B C\",\"C A C A\"),\"C B A C B A A B C\",'<code>orderDisjointList(\"A B C A B C A B C\",\"C A C A\")</code> should return <code>\"C B A C B A A B C\"</code>.');"
        },
        {
          "text":
            "'<code>orderDisjointList(\"A B C A B D A B E\",\"E A D A\")</code> should return <code>\"E B C A B D A B A\"</code>.'",
          "testString":
            "assert.equal(orderDisjointList(\"A B C A B D A B E\",\"E A D A\"),\"E B C A B D A B A\",'<code>orderDisjointList(\"A B C A B D A B E\",\"E A D A\")</code> should return <code>\"E B C A B D A B A\"</code>.');"
        },
        {
          "text":
            "'<code>orderDisjointList(\"A B\",\"B\")</code> should return <code>\"A B\"</code>.'",
          "testString":
            "assert.equal(orderDisjointList(\"A B\",\"B\"),\"A B\",'<code>orderDisjointList(\"A B\",\"B\")</code> should return <code>\"A B\"</code>.');"
        },
        {
          "text":
            "'<code>orderDisjointList(\"A B\",\"B A\")</code> should return <code>\"B A\"</code>.'",
          "testString":
            "assert.equal(orderDisjointList(\"A B\",\"B A\"),\"B A\",'<code>orderDisjointList(\"A B\",\"B A\")</code> should return <code>\"B A\"</code>.');"
        },
        {
          "text":
            "'<code>orderDisjointList(\"A B B A\",\"B A\")</code> should return <code>\"B A B A\"</code>.'",
          "testString":
            "assert.equal(orderDisjointList(\"A B B A\",\"B A\"),\"B A B A\",'<code>orderDisjointList(\"A B B A\",\"B A\")</code> should return <code>\"B A B A\"</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f4d",
      "challengeType": 5,
      "releasedOn": "August 3, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function orderDisjointList (M, N) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Ordered Partitions",
      "description": [
        "In this task we want to find the ordered partitions into fixed-size blocks. This task is related to <a href=\"http://rosettacode.org/wiki/Combinations\">Combinations</a> in that it has to do with discrete mathematics.",
        "$partitions(\\mathit{arg}_1,\\mathit{arg}_2,...,\\mathit{arg}_n)$ should generate all distributions of the elements in $\\{1,...,\\Sigma_{i=1}^n\\mathit{arg}_i\\}$ into $n$ blocks of respective size $\\mathit{arg}_1,\\mathit{arg}_2,...,\\mathit{arg}_n$.",
        "Example 1: $partitions(2,0,2)$ would create:",
        "<pre>",
        "{({1, 2}, {}, {3, 4}),",
        " ({1, 3}, {}, {2, 4}),",
        " ({1, 4}, {}, {2, 3}),",
        " ({2, 3}, {}, {1, 4}),",
        " ({2, 4}, {}, {1, 3}),",
        " ({3, 4}, {}, {1, 2})}",
        "</pre>",
        "Example 2: $partitions(1,1,1)$ would create:",
        "<pre>",
        "{({1}, {2}, {3}),",
        " ({1}, {3}, {2}),",
        " ({2}, {1}, {3}),",
        " ({2}, {3}, {1}),",
        " ({3}, {1}, {2}),",
        " ({3}, {2}, {1})}",
        "</pre>",
        "Note that the number of elements in the list is",
        "${\\mathit{arg}_1+\\mathit{arg}_2+...+\\mathit{arg}_n \\choose \\mathit{arg}_1} \\cdot {\\mathit{arg}_2+\\mathit{arg}_3+...+\\mathit{arg}_n \\choose \\mathit{arg}_2} \\cdot \\ldots \\cdot {\\mathit{arg}_n \\choose \\mathit{arg}_n}$",
        "(see <a href=\"http://en.wikipedia.org/wiki/Binomial_coefficient\">the definition of the binomial coefficient</a> if you are not familiar with this notation) and the number of elements remains the same regardless of how the argument is permuted (i.e. the <a href=\"http://en.wikipedia.org/wiki/Multinomial_coefficient\">multinomial coefficient</a>). Also, $partitions(1,1,1)$ creates the permutations of $\\{1,2,3\\}$ and thus there would be $3! = 6$ elements in the list.",
        "<b>Notation</b>",
        "Here are some explanatory remarks on the notation used in the task description:$\\{1, \\ldots, n\\}$ denotes the set of consecutive numbers from $1$ to $n$, e.g. $\\{1,2,3\\}$ if $n = 3$. $\\Sigma$ is the mathematical notation for summation, e.g. $\\Sigma_{i=1}^3 i = 6$. $\\mathit{arg}_1,\\mathit{arg}_2,...,\\mathit{arg}_n$ are the arguments — natural numbers — that the sought function receives.",
        "Write a function that takes 3 numbers as paramters and returns the ordered partitions as a 3D array as explained above."
      ],
      "solutions": [
        "function partitions (a1, a2, a3) {\n  function combos(s, n, xxs) {\n    if (!xxs.length) return [\n      []\n    ];\n    var x = xxs[0],\n      xs = xxs.slice(1);\n    return mb(choose(s, n, x), function(l_rest) {\n      return mb(combos(l_rest[1], (n - x), xs), function(r) {\n        return [\n          [l_rest[0]].concat(r)\n        ];\n\n      })\n    });\n  }\n\n  function choose(aa, n, m) {\n    if (!m) return [\n      [\n        [], aa\n      ]\n    ];\n    var a = aa[0],\n      as = aa.slice(1);\n    return n === m ? (\n      [\n        [aa, []]\n      ]\n    ) : (\n      choose(as, n - 1, m - 1).map(function(xy) {\n        return [\n          [a].concat(xy[0]), xy[1]\n        ];\n      }).concat(choose(as, n - 1, m).map(function(xy) {\n        return [xy[0],\n          [a].concat(xy[1])\n        ];\n      }))\n    );\n  }\n\n  function mb(xs, f) {\n    return [].concat.apply([], xs.map(f));\n  }\n\n  function range(m, n) {\n    return Array.apply(null, Array(n - m + 1)).map(function(x, i) {\n      return m + i;\n    });\n  }\n\n  var n = a1 + a2 + a3;\n\n  return combos(range(1, n), n, [a1, a2, a3]);\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>partitions</code> should be a function.'",
          "testString":
            "assert(typeof partitions=='function','<code>partitions</code> should be a function.');"
        },
        {
          "text": "'<code>partitions(2,0,2)</code> should return a array.'",
          "testString":
            "assert(Array.isArray(partitions(2,0,2)),'<code>partitions(2,0,2)</code> should return a array.');"
        },
        {
          "text":
            "'<code>partitions(2,0,2)</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(partitions(2,0,2),results[0],'<code>partitions(2,0,2)</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>partitions(1,1,1)</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(partitions(1,1,1),results[1],'<code>partitions(1,1,1)</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>partitions(1,0,1)</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(partitions(1,0,1),results[2],'<code>partitions(1,0,1)</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>partitions(1,0,2)</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(partitions(1,0,2),results[3],'<code>partitions(1,0,2)</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>partitions(2,0,1)</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(partitions(2,0,1),results[4],'<code>partitions(2,0,1)</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f4e",
      "challengeType": 5,
      "releasedOn": "August 3, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function partitions (a1, a2, a3) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var results=[",
            "[[[1,2],[],[3,4]],[[1,3],[],[2,4]],[[1,4],[],[2,3]],[[2,3],[],[1,4]],[[2,4],[],[1,3]],[[3,4],[],[1,2]]],",
            "[[[1],[2],[3]],[[1],[3],[2]],[[2],[1],[3]],[[2],[3],[1]],[[3],[1],[2]],[[3],[2],[1]]],",
            "[[[1],[],[2]],[[2],[],[1]]],",
            "[[[1],[],[2,3]],[[2],[],[1,3]],[[3],[],[1,2]]],",
            "[[[1,2],[],[3]],[[1,3],[],[2]],[[2,3],[],[1]]]]"
          ]
        }
      }
    },
    {
      "title": "Ordered words",
      "description": [
        "An  <i>ordered word</i>  is a word in which the letters appear in alphabetic order.",
        "Examples include  <b>abbey</b>  and  <b>dirt</b>.",
        "Write a function that returns true if the letters of the given word are in alphabetic order and false if they're not."
      ],
      "solutions": [
        "function is_ordered (word) {\n  return word.split('').sort().join('') === word;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>is_ordered</code> should be a function.'",
          "testString":
            "assert(typeof is_ordered=='function','<code>is_ordered</code> should be a function.');"
        },
        {
          "text":
            "'<code>is_ordered(\"abbott\")</code> should return a boolean.'",
          "testString":
            "assert(typeof is_ordered(\"abbott\") == 'boolean','<code>is_ordered(\"abbott\")</code> should return a boolean.');"
        },
        {
          "text":
            "'<code>is_ordered(\"abbott\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(is_ordered(\"abbott\"),true,'<code>is_ordered(\"abbott\")</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>is_ordered(\"rosetta\")</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(is_ordered(\"rosetta\"),false,'<code>is_ordered(\"rosetta\")</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>is_ordered(\"accent\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(is_ordered(\"accent\"),true,'<code>is_ordered(\"accent\")</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>is_ordered(\"coding\")</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(is_ordered(\"coding\"),false,'<code>is_ordered(\"coding\")</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>is_ordered(\"access\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(is_ordered(\"access\"),true,'<code>is_ordered(\"access\")</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>is_ordered(\"lexicographic\")</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(is_ordered(\"lexicographic\"),false,'<code>is_ordered(\"lexicographic\")</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>is_ordered(\"knotty\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(is_ordered(\"knotty\"),true,'<code>is_ordered(\"knotty\")</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>is_ordered(\"champion\")</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(is_ordered(\"champion\"),false,'<code>is_ordered(\"champion\")</code> should return <code>false</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f4f",
      "challengeType": 5,
      "releasedOn": "August 3, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function is_ordered (word) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Palindrome detection",
      "description": [
        "A <a href=\"https://en.wikipedia.org/wiki/Palindrome\">palindrome</a> is a phrase which reads the same backward and forward.",
        "Write a function or program that checks whether a given sequence of characters is a palindrome."
      ],
      "solutions": [
        "function isPalindrome (str) {\n  return str === str.split(\"\").reverse().join(\"\");\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>isPalindrome</code> should be a function.'",
          "testString":
            "assert(typeof isPalindrome=='function','<code>isPalindrome</code> should be a function.');"
        },
        {
          "text":
            "'<code>isPalindrome(\"ABBA\")</code> should return a boolean.'",
          "testString":
            "assert(typeof isPalindrome(\"ABBA\") == 'boolean','<code>isPalindrome(\"ABBA\")</code> should return a boolean.');"
        },
        {
          "text":
            "'<code>isPalindrome(\"ABBA\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isPalindrome(\"ABBA\"),true,'<code>isPalindrome(\"ABBA\")</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isPalindrome(\"abcedfgfedcb\")</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isPalindrome(\"abcedfgfedcb\"),false,'<code>isPalindrome(\"abcedfgfedcb\")</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>isPalindrome(\"abcdeffedcba\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isPalindrome(\"abcdeffedcba\"),true,'<code>isPalindrome(\"abcdeffedcba\")</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isPalindrome(\"hello\")</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isPalindrome(\"hello\"),false,'<code>isPalindrome(\"hello\")</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>isPalindrome(\"abcdefgfedcba\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isPalindrome(\"abcdefgfedcba\"),true,'<code>isPalindrome(\"abcdefgfedcba\")</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isPalindrome(\"ingirumimusnocteetconsumimurigni\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isPalindrome(\"ingirumimusnocteetconsumimurigni\"),true,'<code>isPalindrome(\"ingirumimusnocteetconsumimurigni\")</code> should return <code>true</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f51",
      "challengeType": 5,
      "releasedOn": "August 3, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function isPalindrome (str) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Pangram checker",
      "description": [
        "A pangram is a sentence that contains all the letters of the English alphabet at least once.",
        "For example:  <i>The quick brown fox jumps over the lazy dog</i>.",
        "Write a function to check if a sentence is a <a href=\"https://en.wikipedia.org/wiki/Pangram\">pangram. It should return true if the given sentence is a pangram, and false if it isn't."
      ],
      "solutions": [
        "function isPangram (s) {\n    var letters = \"zqxjkvbpygfwmucldrhsnioate\"\n    // sorted by frequency ascending (http://en.wikipedia.org/wiki/Letter_frequency)\n    s = s.toLowerCase().replace(/[^a-z]/g,'')\n    for (var i = 0; i < 26; i++)\n        if (s.indexOf(letters[i]) < 0) return false\n    return true\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>isPangram</code> should be a function.'",
          "testString":
            "assert(typeof isPangram=='function','<code>isPangram</code> should be a function.');"
        },
        {
          "text":
            "'<code>isPangram(\"is this a pangram\")</code> should return a boolean.'",
          "testString":
            "assert(typeof isPangram(\"is this a pangram\") == 'boolean','<code>isPangram(\"is this a pangram\")</code> should return a boolean.');"
        },
        {
          "text":
            "'<code>isPangram(\"is this a pangram\")</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isPangram(\"is this a pangram\"),false,'<code>isPangram(\"is this a pangram\")</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>isPangram(\"The quick brown fox jumps over the lazy dog\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isPangram(\"The quick brown fox jumps over the lazy dog\"),true,'<code>isPangram(\"The quick brown fox jumps over the lazy dog\")</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isPangram(\"Pack my box with five dozen liquor jugs.\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isPangram(\"Pack my box with five dozen liquor jugs.\"),true,'<code>isPangram(\"Pack my box with five dozen liquor jugs.\")</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isPangram(\"This sentence contains A-Z but not the whole alphabet.\")</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isPangram(\"This sentence contains A-Z but not the whole alphabet.\"),false,'<code>isPangram(\"This sentence contains A-Z but not the whole alphabet.\")</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>isPangram(\"The five boxing wizards jump quickly.\")</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isPangram(\"The five boxing wizards jump quickly.\"),true,'<code>isPangram(\"The five boxing wizards jump quickly.\")</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isPangram(\"Trying to write all the alphabets in this statement\")</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isPangram(\"Trying to write all the alphabets in this statement\"),false,'<code>isPangram(\"Trying to write all the alphabets in this statement\")</code> should return <code>false</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f52",
      "challengeType": 5,
      "releasedOn": "August 3, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function isPangram (s) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Paraffins",
      "description": [
        "This organic chemistry task is essentially to implement a tree enumeration algorithm.",
        "Paraffins are built up using only carbon atoms, which has four bonds, and hydrogen, which has one bond. All bonds for each atom must be used, so it is easiest to think of an alkane as linked carbon atoms forming the \"backbone\" structure, with adding hydrogen atoms linking the remaining unused bonds.",
        "In a paraffin, one is allowed neither double bonds (two bonds between the same pair of atoms), nor cycles of linked carbons. So all paraffins with  <b>n</b>  carbon atoms share the empirical formula  C<sub>n</sub>H<sub>2n+2</sub>",
        "But for all  <b>n</b> ≥ 4  there are several distinct molecules (\"isomers\") with the same formula but different structures.",
        "The number of isomers rises rather rapidly when  <b>n</b>  increases.",
        "In counting isomers it should be borne in mind that the four bond positions on a given carbon atom can be freely interchanged and bonds rotated (including 3-D \"out of the paper\" rotations when it's being observed on a flat diagram), so rotations or re-orientations of parts of the molecule (without breaking bonds) do not give different isomers. So what seem at first to be different molecules may in fact turn out to be different orientations of the same molecule.",
        "With  <b>n</b> = 3  there is only one way of linking the carbons despite the different orientations the molecule can be drawn;  and with  <b>n</b> = 4  there are two configurations:",
        "straight chain:   (CH<sub>3</sub>)(CH<sub>2</sub>)(CH<sub>2</sub>)(CH<sub>3</sub>)",
        "branched chain:   (CH<sub>3</sub>)(CH(CH<sub>3</sub>))(CH<sub>3</sub>)",
        "Due to bond rotations, it doesn't matter which direction the branch points in.",
        "The phenomenon of \"stereo-isomerism\" (a molecule being different from its mirror image due to the actual 3-D arrangement of bonds) is ignored for the purpose of this task.",
        "The input is the number  <b>n</b>  of carbon atoms of a molecule (for instance <b>17</b>).",
        "The output is how many different different paraffins there are with  <b>n</b>  carbon atoms  (for instance  24,894  if  <b>n</b> = 17).",
        "The sequence of those results is visible in the <a href=\"http://rosettacode.org/wiki/oeis:A000602\">Sloane encyclopedia</a>. The sequence is (the index starts from zero, and represents the number of carbon atoms):",
        "1, 1, 1, 1, 2, 3, 5, 9, 18, 35, 75, 159, 355, 802, 1858, 4347, 10359, 24894, 60523, 148284, 366319, 910726, 2278658, 5731580, 14490245, 36797588, 93839412, 240215803, 617105614, 1590507121, 4111846763, 10660307791, 27711253769, ..."
      ],
      "solutions": [
        "function paraffinIsomers (N) {\n  var nBranches = 4;\n  var c=new Array(nBranches);\n  var rooted=new Array(N+1);\n  var unrooted=new Array(N+1);\n\n  function tree(br, n, l, inSum, cnt) {\n    var sum = inSum;\n    for (var b = br + 1; b <= nBranches; b++) {\n      sum += n;\n      if (sum > N || (l * 2 >= sum && b >= nBranches))\n        return;\n      var tmp = rooted[n];\n      if (b === br + 1) {\n        c[br] = tmp * cnt;\n      } else {\n        c[br] = c[br] * (tmp + b - br - 1);\n        c[br] = (c[br] / (b - br) | 0);\n      }\n      if (l * 2 < sum)\n        unrooted[sum] = unrooted[sum] + c[br];\n      if (b < nBranches)\n        rooted[sum] = rooted[sum] + c[br];\n      for (var m = n - 1; m > 0; m--)\n        tree(b, m, l, sum, c[br]);\n    };\n  };\n  function bicenter(s) {\n    if ((s & 1) === 0) {\n      var tmp = rooted[s / 2];\n      tmp = (tmp + 1) * rooted[s / 2];\n      unrooted[s] = unrooted[s] + (tmp >> 1);\n    }\n  };\n\n  rooted.fill(0);\n  unrooted.fill(0);\n  rooted[0] = rooted[1] = 1;\n  unrooted[0] = unrooted[1] = 1;\n  var n;\n  for (n = 1; n <= N; n++) {\n    tree(0, n, n, 1, 1);\n    bicenter(n);\n  }\n\n  return unrooted[n-1];\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>paraffinIsomers</code> should be a function.'",
          "testString":
            "assert(typeof paraffinIsomers=='function','<code>paraffinIsomers</code> should be a function.');"
        },
        {
          "text": "'<code>paraffinIsomers(3)</code> should return a number.'",
          "testString":
            "assert(typeof paraffinIsomers(3) == 'number','<code>paraffinIsomers(3)</code> should return a number.');"
        },
        {
          "text":
            "'<code>paraffinIsomers(3)</code> should return <code>1</code>.'",
          "testString":
            "assert.equal(paraffinIsomers(3),1,'<code>paraffinIsomers(3)</code> should return <code>1</code>.');"
        },
        {
          "text":
            "'<code>paraffinIsomers(5)</code> should return <code>3</code>.'",
          "testString":
            "assert.equal(paraffinIsomers(5),3,'<code>paraffinIsomers(5)</code> should return <code>3</code>.');"
        },
        {
          "text":
            "'<code>paraffinIsomers(7)</code> should return <code>9</code>.'",
          "testString":
            "assert.equal(paraffinIsomers(7),9,'<code>paraffinIsomers(7)</code> should return <code>9</code>.');"
        },
        {
          "text":
            "'<code>paraffinIsomers(10)</code> should return <code>75</code>.'",
          "testString":
            "assert.equal(paraffinIsomers(10),75,'<code>paraffinIsomers(10)</code> should return <code>75</code>.');"
        },
        {
          "text":
            "'<code>paraffinIsomers(20)</code> should return <code>366319</code>.'",
          "testString":
            "assert.equal(paraffinIsomers(20),366319,'<code>paraffinIsomers(20)</code> should return <code>366319</code>.');"
        },
        {
          "text":
            "'<code>paraffinIsomers(25)</code> should return <code>36797588</code>.'",
          "testString":
            "assert.equal(paraffinIsomers(25),36797588,'<code>paraffinIsomers(25)</code> should return <code>36797588</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f53",
      "challengeType": 5,
      "releasedOn": "August 3, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function paraffinIsomers (N) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Parse an IP Address",
      "description": [
        "The purpose of this task is to demonstrate parsing of text-format IP addresses, using IPv4 and IPv6.",
        "Taking the following as inputs:",
        "127.0.0.1",
        "=> The \"localhost\" IPv4 address",
        "127.0.0.1:80",
        "=> The \"localhost\" IPv4 address, with a specified port (80)",
        "::1",
        "=> The \"localhost\" IPv6 address",
        "[::1]:80",
        "=> The \"localhost\" IPv6 address, with a specified port (80)",
        "2605:2700:0:3::4713:93e3",
        "=> Rosetta Code's primary server's public IPv6 address",
        "[2605:2700:0:3::4713:93e3]:80",
        "=> Rosetta Code's primary server's public IPv6 address, with a specified port (80)",
        "Write a function to parse the IP address from a given string. The function should return an array if the string contains a valid IP address. The first element of the array should be the IP address. The second element should be the port number, or \"absent\" if there is no port number. The third element should be the address space, \"ipv4\" or \"ipv6\". Finally, if the IP address is invalid the function should return the string \"invalid\"."
      ],
      "solutions": [
        "function parseIP (str){\n  var ipRegx= /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$|^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\\-]*[A-Za-z0-9])$|^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/\n\n  var ip,port,type,portRegx\n  if(str.indexOf('.')==-1){\n    type='ipv6'\n    portRegx=/\\[(.*)\\]:(\\d+)/\n  }else{\n    type='ipv4'\n    portRegx=/(.*?):(\\d+)/\n  }\n  var portMatch=portRegx.exec(str)\n  if(portMatch){\n    ip=portMatch[1]\n    port=parseInt(portMatch[2])\n  }else{\n    ip=str\n    port='absent';\n  }\n  if(!ipRegx.test(ip)){\n    return 'invalid'\n  }\n  return [ip,port,type]\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>parseIP</code> should be a function.'",
          "testString":
            "assert(typeof parseIP=='function','<code>parseIP</code> should be a function.');"
        },
        {
          "text":
            "'<code>parseIP(\"127.0.0.1\")</code> should return a array.'",
          "testString":
            "assert(Array.isArray(parseIP(\"127.0.0.1\")),'<code>parseIP(\"127.0.0.1\")</code> should return a array.');"
        },
        {
          "text":
            "'<code>parseIP(\"127.0.0.1\")</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(parseIP(\"127.0.0.1\"),results[0],'<code>parseIP(\"127.0.0.1\")</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>parseIP(\"127.0.0.1:80\")</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(parseIP(\"127.0.0.1:80\"),results[1],'<code>parseIP(\"127.0.0.1:80\")</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>parseIP(\"::1\")</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(parseIP(\"::1\"),results[2],'<code>parseIP(\"::1\")</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>parseIP(\"[::1]:80\")</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(parseIP(\"[::1]:80\"),results[3],'<code>parseIP(\"[::1]:80\")</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>parseIP(\"2605:2700:0:3::4713:93e3\")</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(parseIP(\"2605:2700:0:3::4713:93e3\"),results[4],'<code>parseIP(\"2605:2700:0:3::4713:93e3\")</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        },
        {
          "text":
            "'<code>parseIP(\"[2605:2700:0:3::4713:93e3]:80\")</code> should return <code>'+JSON.stringify(results[5])+'</code>.'",
          "testString":
            "assert.deepEqual(parseIP(\"[2605:2700:0:3::4713:93e3]:80\"),results[5],'<code>parseIP(\"[2605:2700:0:3::4713:93e3]:80\")</code> should return <code>'+JSON.stringify(results[5])+'</code>.');"
        },
        {
          "text":
            "'<code>parseIP(\"1\")</code> should return <code>\"invalid\"</code>.'",
          "testString":
            "assert.equal(parseIP(\"1\"),\"invalid\",'<code>parseIP(\"1\")</code> should return <code>\"invalid\"</code>.');"
        },
        {
          "text":
            "'<code>parseIP(\"666.1.1.1\")</code> should return <code>\"invalid\"</code>.'",
          "testString":
            "assert.equal(parseIP(\"666.1.1.1\"),\"invalid\",'<code>parseIP(\"666.1.1.1\")</code> should return <code>\"invalid\"</code>.');"
        },
        {
          "text":
            "'<code>parseIP(\"1:1:\")</code> should return <code>\"invalid\"</code>.'",
          "testString":
            "assert.equal(parseIP(\"1:1:\"),\"invalid\",'<code>parseIP(\"1:1:\")</code> should return <code>\"invalid\"</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f58",
      "challengeType": 5,
      "releasedOn": "August 3, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function parseIP (str){", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "var results=[",
            "[\"127.0.0.1\",\"absent\",\"ipv4\"],",
            "[\"127.0.0.1\",80,\"ipv4\"],",
            "[\"::1\",\"absent\",\"ipv6\"],",
            "[\"::1\",80,\"ipv6\"],",
            "[\"2605:2700:0:3::4713:93e3\",\"absent\",\"ipv6\"],",
            "[\"2605:2700:0:3::4713:93e3\",80,\"ipv6\"]]"
          ]
        }
      }
    },
    {
      "title": "Parsing/RPN calculator algorithm",
      "description": [
        "Create a stack-based evaluator for an expression in  <a href=\"https://en.wikipedia.org/wiki/Reverse Polish notation\">Reverse Polish Notation (RPN)</a>.",
        "<ul><li>Assume an input of a correct, space separated, string of tokens of an RPN expression</li> <li>Test with the RPN expression generated from the  <a href=\"http://rosettacode.org/wiki/Parsing/Shunting-yard algorithm\">Parsing/Shunting-yard algorithm</a></li></ul>",
        "Write a function that takes an RPN expression as string and returns the result as a number."
      ],
      "solutions": [
        "function rpnCalculate (e) {\n  var s = [],\n    e = e.split(' ')\n  for (var i in e) {\n    var t = e[i],\n      n = +t\n    if (n == t)\n      s.push(n)\n    else {\n      var o2 = s.pop(),\n        o1 = s.pop()\n      switch (t) {\n        case '+':\n          s.push(o1 + o2);\n          break;\n        case '-':\n          s.push(o1 - o2);\n          break;\n        case '*':\n          s.push(o1 * o2);\n          break;\n        case '/':\n          s.push(o1 / o2);\n          break;\n        case '^':\n          s.push(Math.pow(o1, o2));\n          break;\n      }\n    }\n  }\n\n  return parseFloat(s[0])\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>rpnCalculate</code> should be a function.'",
          "testString":
            "assert(typeof rpnCalculate=='function','<code>rpnCalculate</code> should be a function.');"
        },
        {
          "text":
            "'<code>rpnCalculate(\"3 4 +\")</code> should return a number.'",
          "testString":
            "assert(typeof rpnCalculate(\"3 4 +\") == 'number','<code>rpnCalculate(\"3 4 +\")</code> should return a number.');"
        },
        {
          "text":
            "'<code>rpnCalculate(\"3 4 +\")</code> should return <code>7</code>.'",
          "testString":
            "assert.equal(rpnCalculate(\"3 4 +\"),7,'<code>rpnCalculate(\"3 4 +\")</code> should return <code>7</code>.');"
        },
        {
          "text":
            "'<code>rpnCalculate(\"15 7 1 1 + - / 3 * 2 1 1 + + -\")</code> should return <code>5</code>.'",
          "testString":
            "assert.equal(rpnCalculate(\"15 7 1 1 + - / 3 * 2 1 1 + + -\"),5,'<code>rpnCalculate(\"15 7 1 1 + - / 3 * 2 1 1 + + -\")</code> should return <code>5</code>.');"
        },
        {
          "text":
            "'<code>rpnCalculate(\"3 5 + 7 2 - *\")</code> should return <code>40</code>.'",
          "testString":
            "assert.equal(rpnCalculate(\"3 5 + 7 2 - *\"),40,'<code>rpnCalculate(\"3 5 + 7 2 - *\")</code> should return <code>40</code>.');"
        },
        {
          "text":
            "'<code>rpnCalculate(\"12 3 - 3 /\")</code> should return <code>3</code>.'",
          "testString":
            "assert.equal(rpnCalculate(\"12 3 - 3 /\"),3,'<code>rpnCalculate(\"12 3 - 3 /\")</code> should return <code>3</code>.');"
        },
        {
          "text":
            "'<code>rpnCalculate(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\")</code> should return <code>3.0001220703125</code>.'",
          "testString":
            "assert.equal(rpnCalculate(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\"),3.0001220703125,'<code>rpnCalculate(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\")</code> should return <code>3.0001220703125</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f59",
      "challengeType": 5,
      "releasedOn": "August 3, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function rpnCalculate (e) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Parsing/RPN to infix conversion",
      "description": [
        "Write a function that takes an <a href=\"https://en.wikipedia.org/wiki/Reverse Polish notation\">RPN</a> representation of an expression formatted as a space separated sequence of tokens and generates the equivalent expression in <a href=\"https://en.wikipedia.org/wiki/Infix notation\">infix notation</a>.",
        "<ul><li>Assume an input of a correct, space separated, string of tokens</li> <li>Generate a space separated output string representing the same expression in infix notation</li>"
      ],
      "solutions": [
        "function rpnToInfix (rpn) {\n  const Associativity = {\n    // a / b / c = (a / b) / c\n    left: 0,\n    // a ^ b ^ c = a ^ (b ^ c)\n    right: 1,\n    // a + b + c = (a + b) + c = a + (b + c)\n    both: 2,\n  };\n  const operators = {\n    '+': {\n      precedence: 2,\n      associativity: Associativity.both\n    },\n    '-': {\n      precedence: 2,\n      associativity: Associativity.left\n    },\n    '*': {\n      precedence: 3,\n      associativity: Associativity.both\n    },\n    '/': {\n      precedence: 3,\n      associativity: Associativity.left\n    },\n    '^': {\n      precedence: 4,\n      associativity: Associativity.right\n    },\n  };\n  class NumberNode {\n    constructor(text) {\n      this.text = text;\n    }\n    toString() {\n      return this.text;\n    }\n  }\n  function InfixNode(fnname, operands) {\n    this.fnname = fnname;\n    this.operands = operands;\n    this.toString=function (parentPrecedence = 0) {\n      const op = operators[this.fnname];\n      const leftAdd = op.associativity === Associativity.right ? 0.01 : 0;\n      const rightAdd = op.associativity === Associativity.left ? 0.01 : 0;\n      if (this.operands.length !== 2) throw Error(\"invalid operand count\");\n      const result = this.operands[0].toString(op.precedence + leftAdd) +\n        ` ${this.fnname} ${this.operands[1].toString(op.precedence + rightAdd)}`;\n      if (parentPrecedence > op.precedence) return `( ${result} )`;\n      else return result;\n    }\n  }\n\n  function rpnToTree(tokens) {\n    const stack = [];\n    for (const token of tokens.split(\" \")) {\n      if (token in operators) {\n        const op = operators[token],\n          arity = 2; // all of these operators take 2 arguments\n        if (stack.length < arity) throw Error(\"stack error\");\n        stack.push(new InfixNode(token, stack.splice(stack.length - arity)));\n      } else stack.push(new NumberNode(token));\n    }\n    if (stack.length !== 1) throw Error(\"stack error \" + stack);\n    return stack[0];\n  }\n\n  return rpnToTree(rpn).toString()\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>rpnToInfix</code> should be a function.'",
          "testString":
            "assert(typeof rpnToInfix=='function','<code>rpnToInfix</code> should be a function.');"
        },
        {
          "text":
            "'<code>rpnToInfix(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\")</code> should return a string.'",
          "testString":
            "assert(typeof rpnToInfix(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\") == 'string','<code>rpnToInfix(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\")</code> should return a string.');"
        },
        {
          "text":
            "'<code>rpnToInfix(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\")</code> should return <code>\"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\"</code>.'",
          "testString":
            "assert.equal(rpnToInfix(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\"),\"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\",'<code>rpnToInfix(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\")</code> should return <code>\"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\"</code>.');"
        },
        {
          "text":
            "'<code>rpnToInfix(\"1 2 + 3 4 + ^ 5 6 + ^\")</code> should return <code>\"( ( 1 + 2 ) ^ ( 3 + 4 ) ) ^ ( 5 + 6 )\"</code>.'",
          "testString":
            "assert.equal(rpnToInfix(\"1 2 + 3 4 + ^ 5 6 + ^\"),\"( ( 1 + 2 ) ^ ( 3 + 4 ) ) ^ ( 5 + 6 )\",'<code>rpnToInfix(\"1 2 + 3 4 + ^ 5 6 + ^\")</code> should return <code>\"( ( 1 + 2 ) ^ ( 3 + 4 ) ) ^ ( 5 + 6 )\"</code>.');"
        },
        {
          "text":
            "'<code>rpnToInfix(\"1 2 3 + +\")</code> should return <code>\"1 + 2 + 3\"</code>.'",
          "testString":
            "assert.equal(rpnToInfix(\"1 2 3 + +\"),\"1 + 2 + 3\",'<code>rpnToInfix(\"1 2 3 + +\")</code> should return <code>\"1 + 2 + 3\"</code>.');"
        },
        {
          "text":
            "'<code>rpnToInfix(\"3 5 + 7 2 - *\")</code> should return <code>\"( 3 + 5 ) * ( 7 - 2 )\"</code>.'",
          "testString":
            "assert.equal(rpnToInfix(\"3 5 + 7 2 - *\"),\"( 3 + 5 ) * ( 7 - 2 )\",'<code>rpnToInfix(\"3 5 + 7 2 - *\")</code> should return <code>\"( 3 + 5 ) * ( 7 - 2 )\"</code>.');"
        },
        {
          "text":
            "'<code>rpnToInfix(\"15 7 1 1 + - / 3 * 2 1 1 + + -\")</code> should return <code>\"15 / ( 7 - ( 1 + 1 ) ) * 3 - ( 2 + 1 + 1 )\"</code>.'",
          "testString":
            "assert.equal(rpnToInfix(\"15 7 1 1 + - / 3 * 2 1 1 + + -\"),\"15 / ( 7 - ( 1 + 1 ) ) * 3 - ( 2 + 1 + 1 )\",'<code>rpnToInfix(\"15 7 1 1 + - / 3 * 2 1 1 + + -\")</code> should return <code>\"15 / ( 7 - ( 1 + 1 ) ) * 3 - ( 2 + 1 + 1 )\"</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f5a",
      "challengeType": 5,
      "releasedOn": "August 3, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function rpnToInfix (rpn) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Parsing/Shunting-yard algorithm",
      "description": [
        "Given the operator characteristics and input from the <a href=\"https://en.wikipedia.org/wiki/Shunting-yard_algorithm\">Shunting-yard algorithm</a> page and tables, use the algorithm to generate the RPN output.</p>",
        "<ul><li>Assume an input of a correct, space separated, string of tokens representing an infix expression</li> <li>Generate a space separated output string representing the RPN</li> <li>Operator precedence is given in this table:</li></ul>",
        "<table style=\"text-align:center;border-collapse:collapse;\" border=\"1\" cellpadding=5> <tr><th>Operator</th><th>Precedence</th><th>Associativity</th><th>Operation</th></tr> <tr><td>^</td><td>4</td><td>Right</td><td>Exponentiation</td></tr> <tr><td>*</td><td>3</td><td>Left</td><td>Multiplication</td></tr> <tr><td>/</td><td>3</td><td>Left</td><td>Division</td></tr> <tr><td>+</td><td>2</td><td>Left</td><td>Addition</td></tr> <tr><td>-</td><td>2</td><td>Left</td><td>Subtraction</td></tr> </table>"
      ],
      "solutions": [
        "function shuntingYard (infix) {\n  function Stack() {\n    this.dataStore = [];\n    this.top = 0;\n    this.push = push;\n    this.pop = pop;\n    this.peek = peek;\n    this.length = length;\n  }\n\n  function push(element) {\n    this.dataStore[this.top++] = element;\n  }\n\n  function pop() {\n    return this.dataStore[--this.top];\n  }\n\n  function peek() {\n    return this.dataStore[this.top - 1];\n  }\n\n  function length() {\n    return this.top;\n  }\n\n  infix = infix.replace(/\\s+/g, ''); // remove spaces, so infix[i]!=\" \"\n\n  var s = new Stack();\n  var ops = \"-+/*^\";\n  var precedence = {\n    \"^\": 4,\n    \"*\": 3,\n    \"/\": 3,\n    \"+\": 2,\n    \"-\": 2\n  };\n  var associativity = {\n    \"^\": \"Right\",\n    \"*\": \"Left\",\n    \"/\": \"Left\",\n    \"+\": \"Left\",\n    \"-\": \"Left\"\n  };\n  var token;\n  var postfix = \"\";\n  var o1, o2;\n\n  for (var i = 0; i < infix.length; i++) {\n    token = infix[i];\n    if (token >= \"0\" && token <= \"9\") { // if token is operand (here limited to 0 <= x <= 9)\n      postfix += token + \" \";\n    } else if (ops.indexOf(token) != -1) { // if token is an operator\n      o1 = token;\n      o2 = s.peek();\n      while (ops.indexOf(o2) != -1 && ( // while operator token, o2, on top of the stack\n          // and o1 is left-associative and its precedence is less than or equal to that of o2\n          (associativity[o1] == \"Left\" && (precedence[o1] <= precedence[o2])) ||\n          // the algorithm on wikipedia says: or o1 precedence < o2 precedence, but I think it should be\n          // or o1 is right-associative and its precedence is less than that of o2\n          (associativity[o1] == \"Right\" && (precedence[o1] < precedence[o2]))\n        )) {\n        postfix += o2 + \" \"; // add o2 to output queue\n        s.pop(); // pop o2 of the stack\n        o2 = s.peek(); // next round\n      }\n      s.push(o1); // push o1 onto the stack\n    } else if (token == \"(\") { // if token is left parenthesis\n      s.push(token); // then push it onto the stack\n    } else if (token == \")\") { // if token is right parenthesis\n      while (s.peek() != \"(\") { // until token at top is (\n        postfix += s.pop() + \" \";\n      }\n      s.pop(); // pop (, but not onto the output queue\n    }\n  }\n  postfix += s.dataStore.reverse().join(\" \");\n  return postfix\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>shuntingYard</code> should be a function.'",
          "testString":
            "assert(typeof shuntingYard=='function','<code>shuntingYard</code> should be a function.');"
        },
        {
          "text":
            "'<code>shuntingYard(\"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\")</code> should return a string.'",
          "testString":
            "assert(typeof shuntingYard(\"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\") == 'string','<code>shuntingYard(\"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\")</code> should return a string.');"
        },
        {
          "text":
            "'<code>shuntingYard(\"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\")</code> should return <code>\"3 4 2 * 1 5 - 2 3 ^ ^ / +\"</code>.'",
          "testString":
            "assert.equal(shuntingYard(\"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\"),\"3 4 2 * 1 5 - 2 3 ^ ^ / +\",'<code>shuntingYard(\"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\")</code> should return <code>\"3 4 2 * 1 5 - 2 3 ^ ^ / +\"</code>.');"
        },
        {
          "text":
            "'<code>shuntingYard(\"1 + 2 + 3\")</code> should return <code>\"1 2 + 3 +\"</code>.'",
          "testString":
            "assert.equal(shuntingYard(\"1 + 2 + 3\"),\"1 2 + 3 +\",'<code>shuntingYard(\"1 + 2 + 3\")</code> should return <code>\"1 2 + 3 +\"</code>.');"
        },
        {
          "text":
            "'<code>shuntingYard(\"3 * 3 ^ 2\")</code> should return <code>\"3 3 2 ^ *\"</code>.'",
          "testString":
            "assert.equal(shuntingYard(\"3 * 3 ^ 2\"),\"3 3 2 ^ *\",'<code>shuntingYard(\"3 * 3 ^ 2\")</code> should return <code>\"3 3 2 ^ *\"</code>.');"
        },
        {
          "text":
            "'<code>shuntingYard(\"1 / 3 - 5 ^ 2\")</code> should return <code>\"1 3 / 5 2 ^ -\"</code>.'",
          "testString":
            "assert.equal(shuntingYard(\"1 / 3 - 5 ^ 2\"),\"1 3 / 5 2 ^ -\",'<code>shuntingYard(\"1 / 3 - 5 ^ 2\")</code> should return <code>\"1 3 / 5 2 ^ -\"</code>.');"
        },
        {
          "text":
            "'<code>shuntingYard(\"7 + 8 * 4 * 3\")</code> should return <code>\"7 8 4 * 3 * +\"</code>.'",
          "testString":
            "assert.equal(shuntingYard(\"7 + 8 * 4 * 3\"),\"7 8 4 * 3 * +\",'<code>shuntingYard(\"7 + 8 * 4 * 3\")</code> should return <code>\"7 8 4 * 3 * +\"</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f5b",
      "challengeType": 5,
      "releasedOn": "August 15, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function shuntingYard (infix) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Pascal matrix generation",
      "description": [
        "A pascal matrix is a two-dimensional square matrix holding numbers from  <a href=\"http://rosettacode.org/wiki/Pascal's triangle\">Pascal's triangle</a>,  also known as  <a href=\"http://rosettacode.org/wiki/Evaluate binomial coefficients\">binomial coefficients</a>  and which can be shown as   <sup>n</sup>C<sub>r</sub>.",
        "Shown below are truncated  5-by-5  matrices  M[i, j]  for  i,j  in range  0..4.",
        "A Pascal upper-triangular matrix that is populated with  <sup>j</sup>C<sub>i</sub>:",
        "<pre> [[1, 1, 1, 1, 1],\n [0, 1, 2, 3, 4],\n [0, 0, 1, 3, 6],\n [0, 0, 0, 1, 4],\n [0, 0, 0, 0, 1]]</pre>",
        "A Pascal lower-triangular matrix that is populated with  <sup>i</sup>C<sub>j</sub>  (the transpose of the upper-triangular matrix):",
        "<pre>[[1, 0, 0, 0, 0],\n [1, 1, 0, 0, 0],\n [1, 2, 1, 0, 0],\n [1, 3, 3, 1, 0],\n [1, 4, 6, 4, 1]]</pre>",
        "A Pascal symmetric matrix that is populated with  <sup>i+j</sup>C<sub>i</sub>:",
        "<pre>[[1, 1, 1, 1, 1],\n [1, 2, 3, 4, 5],\n [1, 3, 6, 10, 15],\n [1, 4, 10, 20, 35],\n [1, 5, 15, 35, 70]]</pre>",
        "Write a function that takes a string and a 2D array as parameters. The string can have the values \"lower\", \"upper\" and \"symmetric\". The function should return the appropriate resultant matrix corresponding to the given string.",
        "The  <a href=\"http://rosettacode.org/wiki/Cholesky decomposition\">Cholesky decomposition</a>  of a Pascal symmetric matrix is the Pascal lower-triangle matrix of the same size."
      ],
      "solutions": [
        "function pascalMat (type, N) {\n  const pascalMatrix = (f, n) =>\n    chunksOf(n, map(compose(bc, f), range([\n      [0, 0],\n      [n - 1, n - 1]\n    ])));\n\n  // Binomial coefficient\n  // bc :: (Int, Int) -> Int\n  const bc = ([n, k]) => {\n    return enumFromTo(1, k)\n      .reduce((a, x) => {\n        return (Math.floor((a * (n - x + 1)) / x) + 0)\n      }, 1)\n  };\n\n  // GENERIC FUNCTIONS -----------------------------------------------------\n\n  // A list of functions applied to a list of arguments\n  // <*> :: [(a -> b)] -> [a] -> [b]\n  const ap = (fs, xs) => //\n    [].concat.apply([], fs.map(f => //\n      [].concat.apply([], xs.map(x => [f(x)]))));\n\n  // chunksOf :: Int -> [a] -> [[a]]\n  const chunksOf = (n, xs) =>\n    xs.reduce((a, _, i, xs) =>\n      i % n ? a : a.concat([xs.slice(i, i + n)]), []);\n\n  // compose :: (b -> c) -> (a -> b) -> (a -> c)\n  const compose = (f, g) => x => f(g(x));\n\n  // concat :: [[a]] -> [a] | [String] -> String\n  const concat = xs => {\n    if (xs.length > 0) {\n      const unit = typeof xs[0] === 'string' ? '' : [];\n      return unit.concat.apply(unit, xs);\n    } else return [];\n  };\n\n  // cons :: a -> [a] -> [a]\n  const cons = (x, xs) => [x].concat(xs);\n\n  // curry :: ((a, b) -> c) -> a -> b -> c\n  const curry = f => a => b => f(a, b);\n\n  // enumFromTo :: Int -> Int -> [Int]\n  const enumFromTo = (m, n) =>\n    Array.from({\n      length: Math.floor(n - m) + 1\n    }, (_, i) => m + i);\n\n  // id :: a -> a\n  const id = x => x;\n\n  // map :: (a -> b) -> [a] -> [b]\n  const map = (f, xs) => xs.map(f);\n\n  // range :: Ix a => (a, a) -> [a]\n  const range = ([a, b]) => {\n    const [as, bs] = a instanceof Array ? [a, b] : [\n        [a],\n        [b]\n      ],\n      an = as.length;\n    return (an === bs.length) ? (\n      an > 1 ? (\n        sequence(as.map((_, i) => enumFromTo(as[i], bs[i])))\n      ) : enumFromTo(a, b)\n    ) : [];\n  };\n\n  // Evaluate left to right, and collect the results\n  // sequence :: Monad m => [m a] -> m [a]\n  const sequence = xs => traverse(id, xs);\n\n  // Map each element of a structure to an action,\n  // evaluate these actions from left to right,\n  // and collect the results.\n  // traverse :: (a -> [b]) -> [a] -> [[b]]\n  const traverse = (f, xs) => {\n    const cons_f = (a, x) => ap(f(x)\n      .map(curry(cons)), a);\n    return xs.reduceRight(cons_f, [\n      []\n    ]);\n  };\n\n  // unlines :: [String] -> String\n  const unlines = xs => xs.join('\\n');\n\n  // zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\n  const zipWith = (f, xs, ys) => {\n    const ny = ys.length;\n    return (xs.length <= ny ? xs : xs.slice(0, ny))\n      .map((x, i) => f(x, ys[i]));\n  };\n\n  var res;\n  switch (type) {\n    case 'lower':\n      res=pascalMatrix(x=>x,N)\n      break;\n    case 'upper':\n      res=pascalMatrix(([a, b]) => [b, a],N)\n      break;\n    case 'symmetric':\n      res=pascalMatrix(([a, b]) => [a + b, a],N)\n      break;\n  }\n\n  return res;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>pascalMat</code> should be a function.'",
          "testString":
            "assert(typeof pascalMat=='function','<code>pascalMat</code> should be a function.');"
        },
        {
          "text":
            "'<code>pascalMat(\"lower\",3)</code> should return a array.'",
          "testString":
            "assert(Array.isArray(pascalMat(\"lower\",3)),'<code>pascalMat(\"lower\",3)</code> should return a array.');"
        },
        {
          "text":
            "'<code>pascalMat(\"lower\",3)</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(pascalMat(\"lower\",3),results[0],'<code>pascalMat(\"lower\",3)</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>pascalMat(\"upper\",3)</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(pascalMat(\"upper\",3),results[1],'<code>pascalMat(\"upper\",3)</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>pascalMat(\"lower\",5)</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(pascalMat(\"lower\",5),results[2],'<code>pascalMat(\"lower\",5)</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>pascalMat(\"upper\",5)</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(pascalMat(\"upper\",5),results[3],'<code>pascalMat(\"upper\",5)</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>pascalMat(\"symmetric\",5)</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(pascalMat(\"symmetric\",5),results[4],'<code>pascalMat(\"symmetric\",5)</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f5d",
      "challengeType": 5,
      "releasedOn": "August 15, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function pascalMat (type, N) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var results=[",
            "[[1,0,0],[1,1,0],[1,2,1]],",
            "[[1,1,1],[0,1,2],[0,0,1]],",
            "[[1,0,0,0,0],[1,1,0,0,0],[1,2,1,0,0],[1,3,3,1,0],[1,4,6,4,1]],",
            "[[1,1,1,1,1],[0,1,2,3,4],[0,0,1,3,6],[0,0,0,1,4],[0,0,0,0,1]],",
            "[[1,1,1,1,1],[1,2,3,4,5],[1,3,6,10,15],[1,4,10,20,35],[1,5,15,35,70]]]"
          ]
        }
      }
    },
    {
      "title": "Pascal's triangle/Puzzle",
      "description": [
        "This puzzle involves a <a href=\"http://xunor.free.fr/en/riddles/auto/pyramidnb.php\">Pascal's Triangle</a>, also known as a <a href=\"http://xunor.free.fr/en/riddles/auto/pyramidnb.php\">Pyramid of Numbers</a>.",
        "<pre>           [top]\n          [  ][  ]\n       [mid][  ][  ]\n      [  ][  ][  ][  ]\n     [ X][a][ Y][b][ Z]</pre>",
        "Each brick of the pyramid is the sum of the two bricks situated below it.",
        "Of the three missing numbers at the base of the pyramid, the middle one is the sum of the other two (that is, Y = X + Z).",
        "Write a function to find a solution to this puzzle. It should take a, b, mid and top as parameters and return the result as an array of the form: <code>[X,Y,Z]</code>."
      ],
      "solutions": [
        "function pascal (a, b, mid, top) {\n  function fmod(dividend, divisor) {\n    var multiplier = 0;\n\n    while (divisor * multiplier < dividend) {\n      ++multiplier;\n    }\n\n    --multiplier;\n\n    return dividend - (divisor * multiplier);\n  }\n  var x, y, z;\n  var ytemp = (top - 4 * (a + b)) / 7.;\n  if (ytemp % 1. >= 0.0001) {\n    x = 0;\n    return;\n  }\n  y = ytemp;\n  x = mid - 2 * a - y;\n  z = y - x;\n\n  return [x, y, z]\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>pascal</code> should be a function.'",
          "testString":
            "assert(typeof pascal=='function','<code>pascal</code> should be a function.');"
        },
        {
          "text": "'<code>pascal(11,4,40,151)</code> should return a array.'",
          "testString":
            "assert(Array.isArray(pascal(11,4,40,151)),'<code>pascal(11,4,40,151)</code> should return a array.');"
        },
        {
          "text":
            "'<code>pascal(11,4,40,151)</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(pascal(11,4,40,151),results[0],'<code>pascal(11,4,40,151)</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>pascal(11,4,41,151)</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(pascal(11,4,41,151),results[1],'<code>pascal(11,4,41,151)</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>pascal(11,4,35,151)</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(pascal(11,4,35,151),results[2],'<code>pascal(11,4,35,151)</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>pascal(11,4,440,151)</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(pascal(11,4,440,151),results[3],'<code>pascal(11,4,440,151)</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f5e",
      "challengeType": 5,
      "releasedOn": "August 15, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function pascal (a, b, mid, top) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var results=[",
            "[5,13,8],",
            "[6,13,7],",
            "[0,13,13],",
            "[405,13,-392]]"
          ]
        }
      }
    },
    {
      "title": "Pascal's triangle",
      "description": [
        "<a href=\"https://en.wikipedia.org/wiki/Pascal's triangle\">Pascal's triangle</a>  is an arithmetic and geometric figure first imagined by  <a href=\"https://en.wikipedia.org/wiki/Blaise Pascal\">Blaise Pascal</a>.",
        "Its first few rows look like this:",
        "<pre> 1\n 1 1\n 1 2 1\n 1 3 3 1</pre>",
        "where each element of each row is either 1 or the sum of the two elements right above it.",
        "For example, the next row of the triangle would be:",
        "<b>1</b>  (since the first element of each row doesn't have two elements above it)</span>",
        "<b>4</b>  (1 + 3)</span>",
        "<b>6</b>  (3 + 3)</span>",
        "<b>4</b>  (3 + 1)</span>",
        "<b>1</b>  (since the last element of each row doesn't have two elements above it) </span>",
        "So the triangle now looks like this:",
        "<pre> 1\n 1 1\n 1 2 1\n 1 3 3 1\n 1 4 6 4 1</pre>",
        "Each row  <tt> n </tt>  (starting with row  0  at the top) shows the coefficients of the binomial expansion of   (x + y)<sup>n</sup>.",
        "Write a function that returns the first  <tt> n </tt>  rows of the triangle  (with  <tt> f(1) </tt>  yielding the row consisting of only the element <b>1</b>) as a 2D array.",
        "This can be done either by summing elements from the previous rows or using a binary coefficient or combination function."
      ],
      "solutions": [
        "function pascalTriangle (rows) {\n  // The 2D array holding the rows of the triangle\n  var triangle = new Array();\n  for (var r = 0; r < rows; r++) {\n    triangle[r] = new Array();\n    for (var i = 0; i <= r; i++) {\n      if (i == 0 || i == r)\n        triangle[r][i] = 1;\n      else\n        triangle[r][i] = triangle[r - 1][i - 1] + triangle[r - 1][i];\n    }\n  }\n\n  // Private method to calculate digits in number\n  var digits = function(n, b) {\n    var d = 0;\n    while (n >= 1) {\n      d++;\n      n /= b;\n    }\n    return d;\n  }\n\n  var res=[];\n  // Print the triangle line by line\n  for (var r = 0; r < triangle.length; r++) {\n    var m=[]\n    for (var i = 0; i < triangle[r].length; i++) {\n      m.push(triangle[r][i]);\n    }\n    res.push(m)\n  }\n  return res\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>pascalTriangle</code> should be a function.'",
          "testString":
            "assert(typeof pascalTriangle=='function','<code>pascalTriangle</code> should be a function.');"
        },
        {
          "text": "'<code>pascalTriangle(1)</code> should return a array.'",
          "testString":
            "assert(Array.isArray(pascalTriangle(1)),'<code>pascalTriangle(1)</code> should return a array.');"
        },
        {
          "text":
            "'<code>pascalTriangle(1)</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(pascalTriangle(1),results[0],'<code>pascalTriangle(1)</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>pascalTriangle(2)</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(pascalTriangle(2),results[1],'<code>pascalTriangle(2)</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>pascalTriangle(3)</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(pascalTriangle(3),results[2],'<code>pascalTriangle(3)</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>pascalTriangle(4)</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(pascalTriangle(4),results[3],'<code>pascalTriangle(4)</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>pascalTriangle(5)</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(pascalTriangle(5),results[4],'<code>pascalTriangle(5)</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f5f",
      "challengeType": 5,
      "releasedOn": "August 15, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function pascalTriangle (rows) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var results=[",
            "[[1]],",
            "[[1],[1,1]],",
            "[[1],[1,1],[1,2,1]],",
            "[[1],[1,1],[1,2,1],[1,3,3,1]],",
            "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]]"
          ]
        }
      }
    },
    {
      "title": "Pattern matching",
      "description": [
        "Some languages offer direct support for <a href=\"https://en.wikipedia.org/wiki/Algebraic_data_type\">algebraic data types</a> and pattern matching on them. While this of course can always be simulated with manual tagging and conditionals, it allows for terse code which is easy to read, and can represent the algorithm directly.",
        "As an example, implement insertion in a <a href=\"https://en.wikipedia.org/wiki/Red_Black_Tree\">red-black-tree</a>. A red-black-tree is a binary tree where each internal node has a color attribute <i>red</i> or <i>black</i>. Moreover, no red node can have a red child, and every path from the root to an empty node must contain the same number of black nodes. As a consequence, the tree is balanced, and must be re-balanced after an insertion.",
        "Write a function that takes an array as parameter. The array elements should be sequentially inserted into a red black tree and the tree should be returned. The returned tree should be in the form: { value: ... , color: ... , left: ... , right: ... }. The values for red and black should be 0 and 1 respectively. If a node does not have a left or right subtree, it should have null in its place."
      ],
      "solutions": [
        "function rbTree (vals) {\n  var RED = 0\n  var BLACK = 1\n\n  function RBNode(color, key, value, left, right, count) {\n    this._color = color\n    this.key = key\n    this.value = value\n    this.left = left\n    this.right = right\n    this._count = count\n  }\n\n  function cloneNode(node) {\n    return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count)\n  }\n\n  function repaint(color, node) {\n    return new RBNode(color, node.key, node.value, node.left, node.right, node._count)\n  }\n\n  function recount(node) {\n    node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0)\n  }\n\n  function RedBlackTree(compare, root) {\n    this._compare = compare\n    this.root = root\n  }\n\n  var proto = RedBlackTree.prototype\n\n  Object.defineProperty(proto, \"keys\", {\n    get: function() {\n      var result = []\n      this.forEach(function(k, v) {\n        result.push(k)\n      })\n      return result\n    }\n  })\n\n  Object.defineProperty(proto, \"values\", {\n    get: function() {\n      var result = []\n      this.forEach(function(k, v) {\n        result.push(v)\n      })\n      return result\n    }\n  })\n\n  //Returns the number of nodes in the tree\n  Object.defineProperty(proto, \"length\", {\n    get: function() {\n      if (this.root) {\n        return this.root._count\n      }\n      return 0\n    }\n  })\n\n  //Insert a new item into the tree\n  proto.insert = function(key, value) {\n    var cmp = this._compare\n    //Find point to insert new node at\n    var n = this.root\n    var n_stack = []\n    var d_stack = []\n    while (n) {\n      var d = cmp(key, n.key)\n      n_stack.push(n)\n      d_stack.push(d)\n      if (d <= 0) {\n        n = n.left\n      } else {\n        n = n.right\n      }\n    }\n    //Rebuild path to leaf node\n    n_stack.push(new RBNode(RED, key, value, null, null, 1))\n    for (var s = n_stack.length - 2; s >= 0; --s) {\n      var n = n_stack[s]\n      if (d_stack[s] <= 0) {\n        n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s + 1], n.right, n._count + 1)\n      } else {\n        n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s + 1], n._count + 1)\n      }\n    }\n    //Rebalance tree using rotations\n    //console.log(\"start insert\", key, d_stack)\n    for (var s = n_stack.length - 1; s > 1; --s) {\n      var p = n_stack[s - 1]\n      var n = n_stack[s]\n      if (p._color === BLACK || n._color === BLACK) {\n        break\n      }\n      var pp = n_stack[s - 2]\n      if (pp.left === p) {\n        if (p.left === n) {\n          var y = pp.right\n          if (y && y._color === RED) {\n            //console.log(\"LLr\")\n            p._color = BLACK\n            pp.right = repaint(BLACK, y)\n            pp._color = RED\n            s -= 1\n          } else {\n            //console.log(\"LLb\")\n            pp._color = RED\n            pp.left = p.right\n            p._color = BLACK\n            p.right = pp\n            n_stack[s - 2] = p\n            n_stack[s - 1] = n\n            recount(pp)\n            recount(p)\n            if (s >= 3) {\n              var ppp = n_stack[s - 3]\n              if (ppp.left === pp) {\n                ppp.left = p\n              } else {\n                ppp.right = p\n              }\n            }\n            break\n          }\n        } else {\n          var y = pp.right\n          if (y && y._color === RED) {\n            //console.log(\"LRr\")\n            p._color = BLACK\n            pp.right = repaint(BLACK, y)\n            pp._color = RED\n            s -= 1\n          } else {\n            //console.log(\"LRb\")\n            p.right = n.left\n            pp._color = RED\n            pp.left = n.right\n            n._color = BLACK\n            n.left = p\n            n.right = pp\n            n_stack[s - 2] = n\n            n_stack[s - 1] = p\n            recount(pp)\n            recount(p)\n            recount(n)\n            if (s >= 3) {\n              var ppp = n_stack[s - 3]\n              if (ppp.left === pp) {\n                ppp.left = n\n              } else {\n                ppp.right = n\n              }\n            }\n            break\n          }\n        }\n      } else {\n        if (p.right === n) {\n          var y = pp.left\n          if (y && y._color === RED) {\n            //console.log(\"RRr\", y.key)\n            p._color = BLACK\n            pp.left = repaint(BLACK, y)\n            pp._color = RED\n            s -= 1\n          } else {\n            //console.log(\"RRb\")\n            pp._color = RED\n            pp.right = p.left\n            p._color = BLACK\n            p.left = pp\n            n_stack[s - 2] = p\n            n_stack[s - 1] = n\n            recount(pp)\n            recount(p)\n            if (s >= 3) {\n              var ppp = n_stack[s - 3]\n              if (ppp.right === pp) {\n                ppp.right = p\n              } else {\n                ppp.left = p\n              }\n            }\n            break\n          }\n        } else {\n          var y = pp.left\n          if (y && y._color === RED) {\n            //console.log(\"RLr\")\n            p._color = BLACK\n            pp.left = repaint(BLACK, y)\n            pp._color = RED\n            s -= 1\n          } else {\n            //console.log(\"RLb\")\n            p.left = n.right\n            pp._color = RED\n            pp.right = n.left\n            n._color = BLACK\n            n.right = p\n            n.left = pp\n            n_stack[s - 2] = n\n            n_stack[s - 1] = p\n            recount(pp)\n            recount(p)\n            recount(n)\n            if (s >= 3) {\n              var ppp = n_stack[s - 3]\n              if (ppp.right === pp) {\n                ppp.right = n\n              } else {\n                ppp.left = n\n              }\n            }\n            break\n          }\n        }\n      }\n    }\n    //Return new tree\n    n_stack[0]._color = BLACK\n    return new RedBlackTree(cmp, n_stack[0])\n  }\n\n  //Default comparison function\n  function defaultCompare(a, b) {\n    if (a > b) {\n      return 1\n    }\n    if (a < b) {\n      return -1\n    }\n    return 0\n  }\n\n  //Build a tree\n  function createRBTree(compare) {\n    return new RedBlackTree(compare || defaultCompare, null)\n  }\n\n  function JSONTree(node) {\n    if (node) {\n      return {\n        value: node.value,\n        color: node._color,\n        left: JSONTree(node.left),\n        right: JSONTree(node.right)\n      };\n    } else {\n      return null\n    }\n  }\n\n  var tr = createRBTree()\n  vals.forEach(function(e, i) {\n    tr = tr.insert(e, e)\n  })\n  return JSONTree(tr.root)\n}\n\n"
      ],
      "tests": [
        {
          "text": "'<code>rbTree</code> should be a function.'",
          "testString":
            "assert(typeof rbTree=='function','<code>rbTree</code> should be a function.');"
        },
        {
          "text":
            "'<code>rbTree([10,20,30,15])</code> should return a object.'",
          "testString":
            "assert(typeof rbTree([10,20,30,15]) == 'object','<code>rbTree([10,20,30,15])</code> should return a object.');"
        },
        {
          "text":
            "'<code>rbTree([10,20,30,15])</code> should return a valid Red black tree.'",
          "testString":
            "assert(isCorrect(rbTree([10,20,30,15]),[10,20,30,15]),'<code>rbTree([10,20,30,15])</code> should return a valid Red black tree.');"
        },
        {
          "text":
            "'<code>rbTree([7,6,5,4,3,2,1])</code> should return a valid Red black tree.'",
          "testString":
            "assert(isCorrect(rbTree([7,6,5,4,3,2,1]),[7,6,5,4,3,2,1]),'<code>rbTree([7,6,5,4,3,2,1])</code> should return a valid Red black tree.');"
        },
        {
          "text":
            "'<code>rbTree([7,3,18,10,22,8,11,26])</code> should return a valid Red black tree.'",
          "testString":
            "assert(isCorrect(rbTree([7,3,18,10,22,8,11,26]),[7,3,18,10,22,8,11,26]),'<code>rbTree([7,3,18,10,22,8,11,26])</code> should return a valid Red black tree.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f62",
      "challengeType": 5,
      "releasedOn": "August 15, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function rbTree (vals) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "function isCorrect(root, values) {",
            "  var correct = true,",
            "    values = values.slice(),",
            "    leaves = [],",
            "    keys = JSON.stringify(['value', 'color', 'left', 'right']);",
            "",
            "  // Traverse tree",
            "  function inorder(node) {",
            "    if (node == null)",
            "      return;",
            "",
            "    // check if Object has correct keys",
            "    if (typeof node != 'object' || JSON.stringify(Object.keys(node)) != keys)",
            "      return correct = false",
            "    // check if value of node is in the sequence",
            "    if (values.indexOf(node.value) == -1)",
            "      return correct = false",
            "    else",
            "      // Remove the value",
            "      values.splice(values.indexOf(node.value), 1)",
            "",
            "    // if node and child has red, sets correct=false and returns",
            "    if (node.color == 0) {",
            "      if ((node.left != null && node.left.color == 0) || (node.right != null && node.right.color == 0))",
            "        return correct = false",
            "    }",
            "",
            "    // listing all the leaves",
            "    if (node.left == null && node.right == null)",
            "      leaves.push(node.value)",
            "    // Traverse left and right sub-trees",
            "    inorder(node.left)",
            "    inorder(node.right)",
            "  }",
            "",
            "  // Start traverse",
            "  inorder(root)",
            "",
            "  // If not correct or values array is not empty",
            "  // values should be empty as after traversing, all elements should have been removed",
            "  if (!correct || values.length != 0) return false",
            "",
            "  function blackNodes(value) {",
            "    var temp = root,",
            "      count = 0;",
            "    while (temp.value != value) {",
            "      count += temp.color",
            "      if (temp.value > value) {",
            "        temp = temp.left",
            "      } else {",
            "        temp = temp.right",
            "      }",
            "    }",
            "    count += temp.color",
            "    return count;",
            "  }",
            "",
            "  // Check black height",
            "  var blackHeight;",
            "  for (var i = 0; i < leaves.length; i++) {",
            "    if (i == 0) {",
            "      blackHeight = blackNodes(leaves[i])",
            "    } else if (blackNodes(leaves[i]) != blackHeight) {",
            "      return false;",
            "    }",
            "  }",
            "",
            "  return true;",
            "}"
          ]
        }
      }
    },
    {
      "title": "Perfect numbers",
      "description": [
        "Write a function which checks whether a number is perfect.",
        "<a href=\"https://en.wikipedia.org/wiki/Perfect_numbers\">A perfect number</a> is a positive integer that is the sum of its proper positive divisors excluding the number itself.",
        "Equivalently, a perfect number is a number that is half the sum of all of its positive divisors (including itself).",
        "Note:  The faster  <a href=\"http://rosettacode.org/wiki/Lucas-Lehmer test\">Lucas-Lehmer test</a>  is used to find primes of the form   2<sup><i>n</i></sup>-1,  all <i>known</i> perfect numbers can be derived from these primes using the formula   (2<sup><i>n</i></sup> - 1) × 2<sup><i>n</i> - 1</sup>.",
        "It is not known if there are any odd perfect numbers (any that exist are larger than 10<sup>2000</sup>)."
      ],
      "solutions": [
        "function isPerfect (n) {\n  var sum = 1,\n    i, sqrt = Math.floor(Math.sqrt(n));\n  for (i = sqrt - 1; i > 1; i--) {\n    if (n % i == 0) {\n      sum += i + n / i;\n    }\n  }\n  if (n % sqrt == 0)\n    sum += sqrt + (sqrt * sqrt == n ? 0 : n / sqrt);\n  return sum === n;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>isPerfect</code> should be a function.'",
          "testString":
            "assert(typeof isPerfect=='function','<code>isPerfect</code> should be a function.');"
        },
        {
          "text": "'<code>isPerfect(6)</code> should return a boolean.'",
          "testString":
            "assert(typeof isPerfect(6) == 'boolean','<code>isPerfect(6)</code> should return a boolean.');"
        },
        {
          "text":
            "'<code>isPerfect(6)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isPerfect(6),true,'<code>isPerfect(6)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isPerfect(28)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isPerfect(28),true,'<code>isPerfect(28)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isPerfect(66)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isPerfect(66),false,'<code>isPerfect(66)</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>isPerfect(496)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isPerfect(496),true,'<code>isPerfect(496)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isPerfect(17)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isPerfect(17),false,'<code>isPerfect(17)</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>isPerfect(8128)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isPerfect(8128),true,'<code>isPerfect(8128)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isPerfect(100)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isPerfect(100),false,'<code>isPerfect(100)</code> should return <code>false</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f6a",
      "challengeType": 5,
      "releasedOn": "August 15, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function isPerfect (n) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Perfect shuffle",
      "description": [
        "A perfect shuffle (or <a href=\"https://en.wikipedia.org/wiki/Faro_shuffle\">faro/weave shuffle</a>) means splitting a deck of cards into equal halves, and perfectly interleaving them - so that you end up with the first card from the left half, followed by the first card from the right half, and so on:",
        "<div style=\"display:inline-block;margin:0.5em 1.5em\"> <tt> <span style=\"background:#8DF\">7♠</span> <span style=\"background:#8DF\">8♠</span> <span style=\"background:#8DF\">9♠</span> <span style=\"background:#FB5\">J♠</span> <span style=\"background:#FB5\">Q♠</span> <span style=\"background:#FB5\">K♠</span> </tt> </div>",
        "<div style=\"display:inline-block\">&rarr; <div style=\"display:inline-block;vertical-align:middle;margin:0.5em 1.5em\"><tt> <span style=\"background:#8DF\">7♠</span>&nbsp;&nbsp; <span style=\"background:#8DF\">8♠</span>&nbsp;&nbsp; <span style=\"background:#8DF\">9♠</span> </tt><br> <tt> &nbsp;&nbsp;<span style=\"background:#FB5\">J♠</span> &nbsp;&nbsp;<span style=\"background:#FB5\">Q♠</span> &nbsp;&nbsp;<span style=\"background:#FB5\">K♠</span> </tt> </div> </div>",
        "<div style=\"display:inline-block\">&rarr; <div style=\"display:inline-block;vertical-align:middle;margin:0.5em 1.5em\"> <tt> <span style=\"background:#8DF\">7♠</span> <span style=\"background:#FB5\">J♠</span> <span style=\"background:#8DF\">8♠</span> <span style=\"background:#FB5\">Q♠</span> <span style=\"background:#8DF\">9♠</span> <span style=\"background:#Fb5\">K♠</span> </tt> </div> </div>",
        "When you repeatedly perform perfect shuffles on an even-sized deck of unique cards, it will at some point arrive back at its original order. How many shuffles this takes, depends solely on the number of cards in the deck - for example for a deck of eight cards it takes three shuffles:",
        "<table style=\"border-spacing:0.5em 0;border-collapse:separate;margin:0 1em;text-align:right\">",
        "<tr> <td><small><i>original:</i></small></td> <td><tt style=\"background:#122CF8;color:#B8C0FD;padding:0 0.3em\">1</tt> <tt style=\"background:#332AD7;color:#C2C0F3;padding:0 0.3em\">2</tt> <tt style=\"background:#5428B7;color:#CCBFEA;padding:0 0.3em\">3</tt> <tt style=\"background:#752696;color:#D6BEE0;padding:0 0.3em\">4</tt> <tt style=\"background:#962576;color:#E0BED6;padding:0 0.3em\">5</tt> <tt style=\"background:#B72355;color:#EABDCC;padding:0 0.3em\">6</tt> <tt style=\"background:#D82135;color:#F3BDC3;padding:0 0.3em\">7</tt> <tt style=\"background:#F92015;color:#FDBDB9;padding:0 0.3em\">8</tt></td> </tr>",
        "<tr> <td><small><i>after 1st shuffle:</i></small></td> <td><tt style=\"background:#122CF8;color:#B8C0FD;padding:0 0.3em\">1</tt> <tt style=\"background:#962576;color:#E0BED6;padding:0 0.3em\">5</tt> <tt style=\"background:#332AD7;color:#C2C0F3;padding:0 0.3em\">2</tt> <tt style=\"background:#B72355;color:#EABDCC;padding:0 0.3em\">6</tt> <tt style=\"background:#5428B7;color:#CCBFEA;padding:0 0.3em\">3</tt> <tt style=\"background:#D82135;color:#F3BDC3;padding:0 0.3em\">7</tt> <tt style=\"background:#752696;color:#D6BEE0;padding:0 0.3em\">4</tt> <tt style=\"background:#F92015;color:#FDBDB9;padding:0 0.3em\">8</tt></td> </tr>",
        "<tr> <td><small><i>after 2nd shuffle:</i></small></td> <td><tt style=\"background:#122CF8;color:#B8C0FD;padding:0 0.3em\">1</tt> <tt style=\"background:#5428B7;color:#CCBFEA;padding:0 0.3em\">3</tt> <tt style=\"background:#962576;color:#E0BED6;padding:0 0.3em\">5</tt> <tt style=\"background:#D82135;color:#F3BDC3;padding:0 0.3em\">7</tt> <tt style=\"background:#332AD7;color:#C2C0F3;padding:0 0.3em\">2</tt> <tt style=\"background:#752696;color:#D6BEE0;padding:0 0.3em\">4</tt> <tt style=\"background:#B72355;color:#EABDCC;padding:0 0.3em\">6</tt> <tt style=\"background:#F92015;color:#FDBDB9;padding:0 0.3em\">8</tt></td> </tr>",
        "<tr> <td><small><i>after 3rd shuffle:</i></small></td> <td><tt style=\"background:#122CF8;color:#B8C0FD;padding:0 0.3em\">1</tt> <tt style=\"background:#332AD7;color:#C2C0F3;padding:0 0.3em\">2</tt> <tt style=\"background:#5428B7;color:#CCBFEA;padding:0 0.3em\">3</tt> <tt style=\"background:#752696;color:#D6BEE0;padding:0 0.3em\">4</tt> <tt style=\"background:#962576;color:#E0BED6;padding:0 0.3em\">5</tt> <tt style=\"background:#B72355;color:#EABDCC;padding:0 0.3em\">6</tt> <tt style=\"background:#D82135;color:#F3BDC3;padding:0 0.3em\">7</tt> <tt style=\"background:#F92015;color:#FDBDB9;padding:0 0.3em\">8</tt></td> </tr>",
        "</table>",
        "<ol> <li>Write a function that can perform a perfect shuffle on an even-sized list of values.</li> <li>Call this function repeatedly to count how many shuffles are needed to get a deck back to its original order, for each of the deck sizes listed under \"Test Cases\" below.</li> <li>You can use a list of numbers (or anything else that's convenient) to represent a deck; just make sure that all \"cards\" are unique within each deck.</li> <li>Return the resulting shuffle counts, to demonstrate that your program passes the test-cases.</li> </ol>"
      ],
      "solutions": [
        "function cycleLength (deckSize) {\n  // shuffleCycleLength :: Int -> Int\n  const shuffleCycleLength = deckSize =>\n    firstCycle(shuffle, range(1, deckSize))\n    .all.length;\n\n  // shuffle :: [a] -> [a]\n  const shuffle = xs =>\n    concat(zip.apply(null, splitAt(div(length(xs), 2), xs)));\n\n  // firstycle :: Eq a => (a -> a) -> a -> [a]\n  const firstCycle = (f, x) =>\n    until(\n      m => EqArray(x, m.current),\n      m => {\n        const fx = f(m.current);\n        return {\n          current: fx,\n          all: m.all.concat([fx])\n        };\n      }, {\n        current: f(x),\n        all: [x]\n      }\n    );\n\n  // Two arrays equal ?\n  // EqArray :: [a] -> [b] -> Bool\n  const EqArray = (xs, ys) => {\n    const [nx, ny] = [xs.length, ys.length];\n    return nx === ny ? (\n      nx > 0 ? (\n        xs[0] === ys[0] && EqArray(xs.slice(1), ys.slice(1))\n      ) : true\n    ) : false;\n  };\n\n  // GENERIC FUNCTIONS\n\n  // zip :: [a] -> [b] -> [(a,b)]\n  const zip = (xs, ys) =>\n    xs.slice(0, Math.min(xs.length, ys.length))\n    .map((x, i) => [x, ys[i]]);\n\n  // concat :: [[a]] -> [a]\n  const concat = xs => [].concat.apply([], xs);\n\n  // splitAt :: Int -> [a] -> ([a],[a])\n  const splitAt = (n, xs) => [xs.slice(0, n), xs.slice(n)];\n\n  // div :: Num -> Num -> Int\n  const div = (x, y) => Math.floor(x / y);\n\n  // until :: (a -> Bool) -> (a -> a) -> a -> a\n  const until = (p, f, x) => {\n    const go = x => p(x) ? x : go(f(x));\n    return go(x);\n  }\n\n  // range :: Int -> Int -> [Int]\n  const range = (m, n) =>\n    Array.from({\n      length: Math.floor(n - m) + 1\n    }, (_, i) => m + i);\n\n  // length :: [a] -> Int\n  // length :: Text -> Int\n  const length = xs => xs.length;\n\n  return shuffleCycleLength(deckSize)\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>cycleLength</code> should be a function.'",
          "testString":
            "assert(typeof cycleLength=='function','<code>cycleLength</code> should be a function.');"
        },
        {
          "text": "'<code>cycleLength(8)</code> should return a number.'",
          "testString":
            "assert(typeof cycleLength(8) == 'number','<code>cycleLength(8)</code> should return a number.');"
        },
        {
          "text": "'<code>cycleLength(8)</code> should return <code>3</code>.'",
          "testString":
            "assert.equal(cycleLength(8),3,'<code>cycleLength(8)</code> should return <code>3</code>.');"
        },
        {
          "text":
            "'<code>cycleLength(24)</code> should return <code>11</code>.'",
          "testString":
            "assert.equal(cycleLength(24),11,'<code>cycleLength(24)</code> should return <code>11</code>.');"
        },
        {
          "text":
            "'<code>cycleLength(52)</code> should return <code>8</code>.'",
          "testString":
            "assert.equal(cycleLength(52),8,'<code>cycleLength(52)</code> should return <code>8</code>.');"
        },
        {
          "text":
            "'<code>cycleLength(100)</code> should return <code>30</code>.'",
          "testString":
            "assert.equal(cycleLength(100),30,'<code>cycleLength(100)</code> should return <code>30</code>.');"
        },
        {
          "text":
            "'<code>cycleLength(1020)</code> should return <code>1018</code>.'",
          "testString":
            "assert.equal(cycleLength(1020),1018,'<code>cycleLength(1020)</code> should return <code>1018</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f6b",
      "challengeType": 5,
      "releasedOn": "August 15, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function cycleLength (deckSize) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Permutation test",
      "description": [
        "A new medical treatment was tested on a population of $n + m$ volunteers, with each volunteer randomly assigned either to a group of $n$ treatment subjects, or to a group of $m$ control subjects.",
        "Members of the treatment group were given the treatment, and members of the control group were given a placebo.",
        "The effect of the treatment or placebo on each volunteer was measured and reported in this table.",
        "<table style=\"text-align:center;border-collapse:collapse\" border=\"1\" cellpadding=\"5\"><tr><th>Treatment group</th><th>Control group</th></tr><tr><td>85</td><td>68</td></tr><tr><td>88</td><td>41</td></tr><tr><td>75</td><td>10</td></tr><tr><td>66</td><td>49</td></tr><tr><td>25</td><td>16</td></tr><tr><td>29</td><td>65</td></tr><tr><td>83</td><td>32</td></tr><tr><td>39</td><td>92</td></tr><tr><td>97</td><td>28</td></tr><tr><td></td><td>98</td></tr></table>",
        "Write a function that performs a <a href=\"https://en.wikipedia.org/wiki/Permutation_test#Permutation_tests\">permutation test</a> to judge whether the treatment had a significantly stronger effect than the placebo. The function should take two arrays as parameters. These arrays will contain the data.",
        "<ul><li>Do this by considering every possible alternative assignment from the same pool of volunteers to a treatment group of size $n$ and a control group of size $m$ (i.e., the same group sizes used in the actual experiment but with the group members chosen differently), while assuming that each volunteer's effect remains constant regardless.</li>",
        "<li>Note that the number of alternatives will be the <a href=\"https://en.wikipedia.org/wiki/Binomial_coefficient\">binomial coefficient</a> $\\tbinom{n+m}{n}$.</li>",
        "<li>Compute the mean effect for each group and the difference in means between the groups in every case by subtracting the mean of the control group from the mean of the treatment group.</li>",
        "<li>The function should return the percentage of alternative groupings for which the difference in means is less or equal to the actual experimentally observed difference in means, and the percentage for which it is greater as an array of 2 elements. The percentages should be rounded to 2 decimal places.</li></ul>"
      ],
      "solutions": [
        "function permutationTest (a, b) {\n  var data=a.slice(0).concat(b);\n  function pick(at, remain, accu, treat) {\n    if (remain === 0)\n      return (accu > treat) ? 1 : 0;\n    return pick(at - 1, remain - 1, accu + data[at - 1], treat) + ((at > remain) ? pick(at - 1, remain, accu, treat) : 0);\n  }\n\n  var treat = 0;\n  var total = 1.0;\n  for (var i = 0; i < a.length; ++i) {\n    treat += data[i];\n  };\n  for (var i = data.length; i >= a.length+2; --i) {\n    total *= i;\n  };\n  for (var i = a.length; i >= 1; --i) {\n    total /= i;\n  };\n  var gt = pick(data.length, a.length, 0, treat);\n  var le = ((total - gt) | 0);\n  var result=100.0 * le / total\n  return Math.floor(result*100)/100\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>permutationTest</code> should be a function.'",
          "testString":
            "assert(typeof permutationTest=='function','<code>permutationTest</code> should be a function.');"
        },
        {
          "text":
            "'<code>permutationTest('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return a number.'",
          "testString":
            "assert(typeof permutationTest(tests[0][0],tests[0][1]) == 'number','<code>permutationTest('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return a number.');"
        },
        {
          "text":
            "'<code>permutationTest('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return <code>39.68</code>.'",
          "testString":
            "assert.equal(permutationTest(tests[0][0],tests[0][1]),39.68,'<code>permutationTest('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+')</code> should return <code>39.68</code>.');"
        },
        {
          "text":
            "'<code>permutationTest('+JSON.stringify(tests[1][0])+','+JSON.stringify(tests[1][1])+')</code> should return <code>93.65</code>.'",
          "testString":
            "assert.equal(permutationTest(tests[1][0],tests[1][1]),93.65,'<code>permutationTest('+JSON.stringify(tests[1][0])+','+JSON.stringify(tests[1][1])+')</code> should return <code>93.65</code>.');"
        },
        {
          "text":
            "'<code>permutationTest('+JSON.stringify(tests[2][0])+','+JSON.stringify(tests[2][1])+')</code> should return <code>49.2</code>.'",
          "testString":
            "assert.equal(permutationTest(tests[2][0],tests[2][1]),49.2,'<code>permutationTest('+JSON.stringify(tests[2][0])+','+JSON.stringify(tests[2][1])+')</code> should return <code>49.2</code>.');"
        },
        {
          "text":
            "'<code>permutationTest('+JSON.stringify(tests[3][0])+','+JSON.stringify(tests[3][1])+')</code> should return <code>68.25</code>.'",
          "testString":
            "assert.equal(permutationTest(tests[3][0],tests[3][1]),68.25,'<code>permutationTest('+JSON.stringify(tests[3][0])+','+JSON.stringify(tests[3][1])+')</code> should return <code>68.25</code>.');"
        },
        {
          "text":
            "'<code>permutationTest('+JSON.stringify(tests[4][0])+','+JSON.stringify(tests[4][1])+')</code> should return <code>87.19</code>.'",
          "testString":
            "assert.equal(permutationTest(tests[4][0],tests[4][1]),87.19,'<code>permutationTest('+JSON.stringify(tests[4][0])+','+JSON.stringify(tests[4][1])+')</code> should return <code>87.19</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f70",
      "challengeType": 5,
      "releasedOn": "August 15, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function permutationTest (a, b) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var tests=[",
            "[[1,2,3,4],[1,2,3,4,5]],",
            "[[85,88,75,66],[68,41,10,49,90]],",
            "[[29,83,39,97],[65,32,92,28,98]],",
            "[[29,83,39,97],[65,32,92,28,48]],",
            "[[85,88,75,66,25,29,83,39,97],[68,41,10,49,16,65,32,92,28,98]]]"
          ]
        }
      }
    },
    {
      "title": "Permutations by swapping",
      "description": [
        "The task is to generate permutations of n items in which successive permutations differ from each other by the swapping of any two items.",
        "Also generate the sign of the permutation which is +1 when the permutation is generated from an even number of swaps from the initial state, and -1 for odd.",
        "Write a function that takes an array as parameter. Return permutations as a 2D array in which each element is a permutation. Each permutation element should have an additional number at the end that denotes the sign as stated above (1 or -1)."
      ],
      "solutions": [
        "function HeapsAlgorithm (arr) {\n  var flag = 1;\n  var res=[],perm\n  function heapPermute(n) {\n    var temp;\n    var i;\n\n    if (n == 1) {\n      perm=[]\n\n      for (i = 0; i < arr.length; i++)\n        perm.push(arr[i])\n      perm.push(flag)\n      res.push(perm)\n      flag *= -1;\n    } else {\n      for (i = 0; i < n - 1; i++) {\n        heapPermute(n - 1);\n\n        if (n % 2 == 0) {\n          temp = arr[i];\n          arr[i] = arr[n - 1];\n          arr[n - 1] = temp;\n        } else {\n          temp = arr[0];\n          arr[0] = arr[n - 1];\n          arr[n - 1] = temp;\n        }\n      }\n      heapPermute(n - 1);\n    }\n  }\n\n  heapPermute(arr.length);\n  res.sort()\n  return res\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>HeapsAlgorithm</code> should be a function.'",
          "testString":
            "assert(typeof HeapsAlgorithm=='function','<code>HeapsAlgorithm</code> should be a function.');"
        },
        {
          "text":
            "'<code>HeapsAlgorithm('+JSON.stringify(tests[0])+')</code> should return a array.'",
          "testString":
            "assert(Array.isArray(HeapsAlgorithm(tests[0].slice())),'<code>HeapsAlgorithm('+JSON.stringify(tests[0])+')</code> should return a array.');"
        },
        {
          "text":
            "'<code>HeapsAlgorithm('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(HeapsAlgorithm(tests[0]),results[0],'<code>HeapsAlgorithm('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>HeapsAlgorithm('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(HeapsAlgorithm(tests[1]),results[1],'<code>HeapsAlgorithm('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>HeapsAlgorithm('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(HeapsAlgorithm(tests[2]),results[2],'<code>HeapsAlgorithm('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f6c",
      "challengeType": 5,
      "releasedOn": "August 15, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function HeapsAlgorithm (arr) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var tests=[",
            "[1,2,3],",
            "[4,5,6],",
            "[22,31,43,57]]",
            "var results=[",
            "[[1,2,3,1],[1,3,2,-1],[2,1,3,-1],[2,3,1,1],[3,1,2,1],[3,2,1,-1]],",
            "[[4,5,6,1],[4,6,5,-1],[5,4,6,-1],[5,6,4,1],[6,4,5,1],[6,5,4,-1]],",
            "[[22,31,43,57,1],[22,31,57,43,-1],[22,43,31,57,-1],[22,43,57,31,1],[22,57,31,43,1],[22,57,43,31,-1],[31,22,43,57,-1],[31,22,57,43,1],[31,43,22,57,1],[31,43,57,22,-1],[31,57,22,43,-1],[31,57,43,22,1],[43,22,31,57,1],[43,22,57,31,-1],[43,31,22,57,-1],[43,31,57,22,1],[43,57,22,31,1],[43,57,31,22,-1],[57,22,31,43,-1],[57,22,43,31,1],[57,31,22,43,1],[57,31,43,22,-1],[57,43,22,31,-1],[57,43,31,22,1]]]"
          ]
        }
      }
    },
    {
      "title": "Permutations/Derangements",
      "description": [
        "A <a href=\"http://mathworld.wolfram.com/Derangement.html\">derangement</a> is a permutation of the order of distinct items in which <i>no item appears in its original place</i>.",
        "For example, the only two derangements of the three items (0, 1, 2) are (1, 2, 0), and (2, 0, 1).",
        "Write a function that takes a string as a parameter and returns its derangements as an array. Note: Sort the array before returning it."
      ],
      "solutions": [
        "function derangements (str) {\n  String.prototype.replaceAt = function(index, replacement) {\n    return this.substr(0, index) + replacement + this.substr(index + replacement.length);\n  }\n  var res = []\n\n  var orig=str\n  function deranged(depth) {\n    var i;\n    var tmp;\n    var count = 0;\n\n    if (depth == str.length) {\n      res.push(str)\n      return 1;\n    }\n    for (i = str.length - 1; i >= depth; i--) {\n      if (orig[i] == str[depth]) continue;\n\n      tmp = str[i];\n      str=str.replaceAt(i, str[depth])\n      str=str.replaceAt(depth, tmp)\n      count += deranged(depth + 1);\n      tmp = str[i];\n      str=str.replaceAt(i, str[depth])\n      str=str.replaceAt(depth, tmp)\n    }\n    return count;\n  }\n\n  deranged(0);\n\n  res.sort()\n  return res\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>derangements</code> should be a function.'",
          "testString":
            "assert(typeof derangements=='function','<code>derangements</code> should be a function.');"
        },
        {
          "text": "'<code>derangements(\"567\")</code> should return a array.'",
          "testString":
            "assert(Array.isArray(derangements(\"567\")),'<code>derangements(\"567\")</code> should return a array.');"
        },
        {
          "text":
            "'<code>derangements(\"567\")</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(derangements(\"567\"),results[0],'<code>derangements(\"567\")</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>derangements(\"xyz\")</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(derangements(\"xyz\"),results[1],'<code>derangements(\"xyz\")</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>derangements(\"mqr\")</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(derangements(\"mqr\"),results[2],'<code>derangements(\"mqr\")</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>derangements(\"1234\")</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(derangements(\"1234\"),results[3],'<code>derangements(\"1234\")</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>derangements(\"abcd\")</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(derangements(\"abcd\"),results[4],'<code>derangements(\"abcd\")</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f6d",
      "challengeType": 5,
      "releasedOn": "August 15, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function derangements (str) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "var results=[",
            "[\"675\",\"756\"],",
            "[\"yzx\",\"zxy\"],",
            "[\"qrm\",\"rmq\"],",
            "[\"2143\",\"2341\",\"2413\",\"3142\",\"3412\",\"3421\",\"4123\",\"4312\",\"4321\"],",
            "[\"badc\",\"bcda\",\"bdac\",\"cadb\",\"cdab\",\"cdba\",\"dabc\",\"dcab\",\"dcba\"]]"
          ]
        }
      }
    },
    {
      "title": "Permutations/Rank of a permutation",
      "description": [
        "A particular ranking of a permutation associates an integer with a particular ordering of all the permutations of a set of distinct items.",
        "For our purposes the ranking will assign integers $0 .. (n! - 1)$ to an ordering of all the permutations of the integers $0 .. (n - 1)$.",
        "For example, the permutations of the digits zero to 3 arranged lexicographically have the following rank:",
        "<pre>  PERMUTATION      RANK\n  (0, 1, 2, 3) ->  0\n  (0, 1, 3, 2) ->  1\n  (0, 2, 1, 3) ->  2\n  (0, 2, 3, 1) ->  3\n  (0, 3, 1, 2) ->  4...  (3, 2, 1, 0) -> 23</pre>",
        "Algorithms exist that can generate a rank from a permutation for some particular ordering of permutations, and that can generate the same rank from the given individual permutation (i.e. given a rank of 17 produce (2, 3, 1, 0) in the example above).",
        "One use of such algorithms could be in generating a small, random, sample of permutations of $n$ items without duplicates when the total number of permutations is large. Remember that the total number of permutations of $n$ items is given by $n!$ which grows large very quickly: A 32 bit integer can only hold $12!$, a 64 bit integer only $20!$. It becomes difficult to take the straight-forward approach of generating all permutations then taking a random sample of them.",
        "Create a function to generate a permutation from a rank. This function should take $n$ and rank as parameters and return the permutation. Create the inverse function that given the permutation generates its rank. This function should take a permution as an array and return its rank."
      ],
      "solutions": [
        "function BitSet (nbits) {\n  var _this = this;\n  if (((typeof nbits === 'number') || nbits === null)) {\n    var __args = Array.prototype.slice.call(arguments);\n    this.bits = null;\n    this.bits = null;\n    (function() {\n      var length = nbits >>> 6;\n      if ((nbits & BitSet.LONG_MASK) !== 0)\n        ++length;\n      _this.bits = (function(s) {\n        var a = [];\n        while (s-- > 0)\n          a.push(0);\n        return a;\n      })(length);\n    })();\n  } else if (nbits === undefined) {\n    var __args = Array.prototype.slice.call(arguments); {\n      var __args_1 = Array.prototype.slice.call(arguments);\n      var nbits_1 = 64;\n      this.bits = null;\n      this.bits = null;\n      (function() {\n        var length = nbits_1 >>> 6;\n        if ((nbits_1 & BitSet.LONG_MASK) !== 0)\n          ++length;\n        _this.bits = (function(s) {\n          var a = [];\n          while (s-- > 0)\n            a.push(0);\n          return a;\n        })(length);\n      })();\n    }\n  } else\n    throw new Error('invalid overload');\n}\nBitSet.LONG_MASK = 63;\nBitSet.prototype.set = function(pos) {\n  var offset = pos >> 6;\n  this.ensure(offset);\n  this.bits[offset] |= 1 << pos;\n};\nBitSet.prototype.ensure = function(lastElt) {\n  if (lastElt >= this.bits.length) {\n    var nd = (function(s) {\n      var a = [];\n      while (s-- > 0)\n        a.push(0);\n      return a;\n    })(lastElt + 1);\n    (function(srcPts, srcOff, dstPts, dstOff, size) {\n      if (srcPts !== dstPts || dstOff >= srcOff + size) {\n        while (--size >= 0)\n          dstPts[dstOff++] = srcPts[srcOff++];\n      } else {\n        var tmp = srcPts.slice(srcOff, srcOff + size);\n        for (var i = 0; i < size; i++)\n          dstPts[dstOff++] = tmp[i];\n      }\n    })(this.bits, 0, nd, 0, this.bits.length);\n    this.bits = nd;\n  }\n};\nBitSet.prototype.nextClearBit = function(from) {\n  var offset = from >> 6;\n  var mask = 1 << from;\n  while (offset < this.bits.length) {\n    var h = this.bits[offset];\n    do {\n      if ((h & mask) == 0)\n        return from;\n      mask <<= 1;\n      from++;\n    }\n    while (mask != 0);\n    mask = 1;\n    offset++;\n  }\n  return from;\n}\n\nfunction getRank (permutation) {\n  var n = permutation.length;\n  var usedDigits = new BitSet();\n  var rank = 0;\n  for (var i = 0; i < n; i++) {\n    rank = rank * (n - i);\n    var digit = 0;\n    var v = -1;\n    while ((v = usedDigits.nextClearBit(v + 1)) < permutation[i])\n      digit++;\n    usedDigits.set(v);\n    rank = rank + digit;\n  }\n  return rank;\n}\n\nfunction getPermutation (n, rank) {\n  var digits = new Array(n);\n  for (var digit = 2; digit <= n; digit++) {\n    var divisor = digit;\n    digits[n - digit] = rank%divisor;\n    if (digit < n)\n      rank = Math.floor(rank/divisor);\n  }\n  var usedDigits = new BitSet();\n  var permutation = new Array(n);\n  for (var i = 0; i < n; i++) {\n    var v = usedDigits.nextClearBit(0);\n    for (var j = 0; j < digits[i]; j++)\n      v = usedDigits.nextClearBit(v + 1);\n    permutation[i] = v;\n    usedDigits.set(v);\n  }\n  return permutation;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>getRank</code> should be a function.'",
          "testString":
            "assert(typeof getRank=='function','<code>getRank</code> should be a function.');"
        },
        {
          "text":
            "'<code>getRank('+JSON.stringify(tests[0])+')</code> should return a number.'",
          "testString":
            "assert(typeof getRank(tests[0]) == 'number','<code>getRank('+JSON.stringify(tests[0])+')</code> should return a number.');"
        },
        {
          "text": "'<code>getPermutation</code> should be a function.'",
          "testString":
            "assert(typeof getPermutation=='function','<code>getPermutation</code> should be a function.');"
        },
        {
          "text": "'<code>getPermutation(4,17)</code> should return a array.'",
          "testString":
            "assert(Array.isArray(getPermutation(4,17)),'<code>getPermutation(4,17)</code> should return a array.');"
        },
        {
          "text":
            "'<code>getRank('+JSON.stringify(tests[0])+')</code> should return <code>17</code>.'",
          "testString":
            "assert.equal(getRank(tests[0]),17,'<code>getRank('+JSON.stringify(tests[0])+')</code> should return <code>17</code>.');"
        },
        {
          "text":
            "'<code>getRank('+JSON.stringify(tests[1])+')</code> should return <code>11</code>.'",
          "testString":
            "assert.equal(getRank(tests[1]),11,'<code>getRank('+JSON.stringify(tests[1])+')</code> should return <code>11</code>.');"
        },
        {
          "text":
            "'<code>getRank('+JSON.stringify(tests[2])+')</code> should return <code>23</code>.'",
          "testString":
            "assert.equal(getRank(tests[2]),23,'<code>getRank('+JSON.stringify(tests[2])+')</code> should return <code>23</code>.');"
        },
        {
          "text":
            "'<code>getRank('+JSON.stringify(tests[3])+')</code> should return <code>590</code>.'",
          "testString":
            "assert.equal(getRank(tests[3]),590,'<code>getRank('+JSON.stringify(tests[3])+')</code> should return <code>590</code>.');"
        },
        {
          "text":
            "'<code>getPermutation(4,17)</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(getPermutation(4,17),results[0],'<code>getPermutation(4,17)</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>getPermutation(4,11)</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(getPermutation(4,11),results[1],'<code>getPermutation(4,11)</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>getPermutation(4,23)</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(getPermutation(4,23),results[2],'<code>getPermutation(4,23)</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>getPermutation(6,590)</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(getPermutation(6,590),results[3],'<code>getPermutation(6,590)</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f6e",
      "challengeType": 5,
      "releasedOn": "August 15, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function getRank (permutation) {",
            "  // Good luck!",
            "}",
            "",
            "function getPermutation (n, rank) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var tests=[",
            "[2,3,1,0],",
            "[1,3,2,0],",
            "[3,2,1,0],",
            "[4,5,2,1,0,3]]",
            "var results=[",
            "[2,3,1,0],",
            "[1,3,2,0],",
            "[3,2,1,0],",
            "[4,5,2,1,0,3]]"
          ]
        }
      }
    },
    {
      "title": "Permutations",
      "description": [
        "Write a function that generates all  <a href=\"https://en.wikipedia.org/wiki/Permutation\">permutations</a> of <b>n</b> different objects. The returned array should be sorted."
      ],
      "solutions": [
        "function perm (a) {\n  if (a.length < 2) return a;\n  var c, d, b = [];\n  for (c = 0; c < a.length; c++) {\n    var e = a.splice(c, 1),\n      f = perm(a);\n    for (d = 0; d < f.length; d++) b.push(e.concat(f[d]));\n    a.splice(c, 0, e[0])\n  }\n  b.sort(function(a, b) {\n    return a > b\n  })\n  return b\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>perm</code> should be a function.'",
          "testString":
            "assert(typeof perm=='function','<code>perm</code> should be a function.');"
        },
        {
          "text":
            "'<code>perm('+JSON.stringify(permutationTests[0])+')</code> should return a array.'",
          "testString":
            "assert(Array.isArray(perm(permutationTests[0])),'<code>perm('+JSON.stringify(permutationTests[0])+')</code> should return a array.');"
        },
        {
          "text":
            "'<code>perm('+JSON.stringify(permutationTests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(perm(permutationTests[0]),results[0],'<code>perm('+JSON.stringify(permutationTests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>perm('+JSON.stringify(permutationTests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(perm(permutationTests[1]),results[1],'<code>perm('+JSON.stringify(permutationTests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>perm('+JSON.stringify(permutationTests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(perm(permutationTests[2]),results[2],'<code>perm('+JSON.stringify(permutationTests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>perm('+JSON.stringify(permutationTests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(perm(permutationTests[3]),results[3],'<code>perm('+JSON.stringify(permutationTests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f6f",
      "challengeType": 5,
      "releasedOn": "August 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function perm (a) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "let permutationTests=[",
            "[1,2,3],",
            "[5,6,7],",
            "[\"a\",\"b\",\"c\"],",
            "[\"hey\",\"hi\",\"hello\"]]",
            "var results=[",
            "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]],",
            "[[5,6,7],[5,7,6],[6,5,7],[6,7,5],[7,5,6],[7,6,5]],",
            "[[\"a\",\"b\",\"c\"],[\"a\",\"c\",\"b\"],[\"b\",\"a\",\"c\"],[\"b\",\"c\",\"a\"],[\"c\",\"a\",\"b\"],[\"c\",\"b\",\"a\"]],",
            "[[\"hello\",\"hey\",\"hi\"],[\"hello\",\"hi\",\"hey\"],[\"hey\",\"hello\",\"hi\"],[\"hey\",\"hi\",\"hello\"],[\"hi\",\"hello\",\"hey\"],[\"hi\",\"hey\",\"hello\"]]]"
          ]
        }
      }
    },
    {
      "title": "Pernicious numbers",
      "description": [
        "A <a href=\"https://en.wikipedia.org/wiki/Pernicious number\">pernicious number</a> is a positive integer whose <a href=\"http://rosettacode.org/wiki/population count\">population count</a> is a prime. The population count is the number of ones in the binary representation of a non-negative integer.",
        "22 (which is 10110 in binary) has a population count of 3, which is prime, and therefore 22 is a pernicious number.",
        "Write a function that checks if a given number is pernicious or not."
      ],
      "solutions": [
        "function isPernicious (n) {\n  function isPrime(x) {\n    if (x < 2) return false;\n    for (var i = 2; i < x; i++) {\n      if (x % i == 0) return false;\n    }\n    return true;\n  }\n\n  function popCount(x) {\n    var count = 0;\n    while (x > 0) {\n      count += x % 2\n      x = x >> 1;\n    }\n    return count;\n  }\n\n  return isPrime(popCount(n))\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>isPernicious</code> should be a function.'",
          "testString":
            "assert(typeof isPernicious=='function','<code>isPernicious</code> should be a function.');"
        },
        {
          "text": "'<code>isPernicious(3)</code> should return a boolean.'",
          "testString":
            "assert(typeof isPernicious(3) == 'boolean','<code>isPernicious(3)</code> should return a boolean.');"
        },
        {
          "text":
            "'<code>isPernicious(3)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isPernicious(3),true,'<code>isPernicious(3)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isPernicious(1)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isPernicious(1),false,'<code>isPernicious(1)</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>isPernicious(18)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isPernicious(18),true,'<code>isPernicious(18)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isPernicious(15)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isPernicious(15),false,'<code>isPernicious(15)</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>isPernicious(25)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isPernicious(25),true,'<code>isPernicious(25)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isPernicious(27)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isPernicious(27),false,'<code>isPernicious(27)</code> should return <code>false</code>.');"
        },
        {
          "text":
            "'<code>isPernicious(10)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isPernicious(10),true,'<code>isPernicious(10)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isPernicious(36)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isPernicious(36),true,'<code>isPernicious(36)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isPernicious(16)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isPernicious(16),false,'<code>isPernicious(16)</code> should return <code>false</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f71",
      "challengeType": 5,
      "releasedOn": "August 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function isPernicious (n) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Phrase reversals",
      "description": [
        "Given a string of space separated words containing the following phrase:",
        "rosetta code phrase reversal",
        "<ul><li>Reverse the string.</li>",
        "<li>Reverse each individual word in the string, maintaining original string order.</li>",
        "<li>Reverse the order of each word of the phrase, maintaining the order of characters in each word.</li></ul>",
        "The result should be returned as an array with respective results ordered as above."
      ],
      "solutions": [
        "function reversal (p) {\n  return [\n    p.split('').reverse().join(''),\n\n    p.split(' ').map(function(x) {\n      return x.split('').reverse().join('');\n    }).join(' '),\n\n    p.split(' ').reverse().join(' ')\n\n  ];\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>reversal</code> should be a function.'",
          "testString":
            "assert(typeof reversal=='function','<code>reversal</code> should be a function.');"
        },
        {
          "text":
            "'<code>reversal(\"rosetta code phrase reversal\")</code> should return a array.'",
          "testString":
            "assert(Array.isArray(reversal(\"rosetta code phrase reversal\")),'<code>reversal(\"rosetta code phrase reversal\")</code> should return a array.');"
        },
        {
          "text":
            "'<code>reversal(\"rosetta code phrase reversal\")</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(reversal(\"rosetta code phrase reversal\"),results[0],'<code>reversal(\"rosetta code phrase reversal\")</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>reversal(\"Reverse each individual word\")</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(reversal(\"Reverse each individual word\"),results[1],'<code>reversal(\"Reverse each individual word\")</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>reversal(\"maintaining the order of characters\")</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(reversal(\"maintaining the order of characters\"),results[2],'<code>reversal(\"maintaining the order of characters\")</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>reversal(\"the order of each word of the phrase\")</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(reversal(\"the order of each word of the phrase\"),results[3],'<code>reversal(\"the order of each word of the phrase\")</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>reversal(\"string of space separated words containing\")</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(reversal(\"string of space separated words containing\"),results[4],'<code>reversal(\"string of space separated words containing\")</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f72",
      "challengeType": 5,
      "releasedOn": "August 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function reversal (p) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "var results=[",
            "[\"lasrever esarhp edoc attesor\",\"attesor edoc esarhp lasrever\",\"reversal phrase code rosetta\"],",
            "[\"drow laudividni hcae esreveR\",\"esreveR hcae laudividni drow\",\"word individual each Reverse\"],",
            "[\"sretcarahc fo redro eht gniniatniam\",\"gniniatniam eht redro fo sretcarahc\",\"characters of order the maintaining\"],",
            "[\"esarhp eht fo drow hcae fo redro eht\",\"eht redro fo hcae drow fo eht esarhp\",\"phrase the of word each of order the\"],",
            "[\"gniniatnoc sdrow detarapes ecaps fo gnirts\",\"gnirts fo ecaps detarapes sdrow gniniatnoc\",\"containing words separated space of string\"]]"
          ]
        }
      }
    },
    {
      "title": "Polynomial long division",
      "description": [
        "<cite>In algebra, <a href=\"https://en.wikipedia.org/wiki/Polynomial long division\">polynomial long division</a> is an algorithm for dividing a polynomial by another polynomial of the same or lower degree.</cite>",
        "Let us suppose a polynomial is represented by a vector, $x$ (i.e., an ordered collection of <a href=\"https://en.wikipedia.org/wiki/Coefficient\">coefficients</a>) so that the $i$<sup>th</sup> element keeps the coefficient of $x^i$, and the multiplication by a monomial is a <i>shift</i>  of the vector's elements \"towards right\" (injecting ones from left) followed by a multiplication of each element by the coefficient of the monomial.",
        "Write a function that takes 2 arrays as parameters. The first array contains the coefficients of polynomial of the dividend and the second array contains the coefficients of the divisor. The $i^{th}$ element is the coefficient of $x^i$. The function should return an array. The first element should be an array containing the coefficients of the quotient and the second element should be an array containing the coefficients of the remainder. Note that the lengths of the array should be equal to the length of the dividend array."
      ],
      "solutions": [
        "function PolynomialLongDivision (n,d) {\n  function Solution(q, r) {\n    this.quotient = null;\n    this.remainder = null;\n    this.quotient = q;\n    this.remainder = r;\n  }\n\n  function polyDegree(p) {\n    for (var i = p.length - 1; i >= 0; --i) {\n      if (p[i] !== 0.0)\n        return i;\n    }\n    return Number.MIN_VALUE;\n  }\n\n  function polyShiftRight(p, places) {\n    if (places <= 0)\n      return p;\n    var pd = polyDegree(p);\n    var d = (function(s) {\n      var a = [];\n      while (s-- > 0)\n        a.push(0);\n      return a;\n    })(p.length);\n    for (var i = 0; i < p.length; i++)\n      d[i] = p[i];\n    for (var i = pd; i >= 0; --i) {\n      d[i + places] = d[i];\n      d[i] = 0.0;\n    }\n    return d;\n  }\n\n  function polyMultiply(p, m) {\n    for (var i = 0; i < p.length; ++i) {\n      p[i] *= m;\n    }\n  }\n\n  function polySubtract(p, s) {\n    for (var i = 0; i < p.length; ++i) {\n      p[i] -= s[i];\n    }\n  }\n\n  function polyLongDiv(n, d) {\n    var nd = polyDegree(n);\n    var dd = polyDegree(d);\n    var n2 = (function(s) {\n      var a = [];\n      while (s-- > 0)\n        a.push(0);\n      return a;\n    })(n.length);\n    for (var i = 0; i < n.length; i++)\n      n2[i] = n[i];\n    var q = (function(s) {\n      var a = [];\n      while (s-- > 0)\n        a.push(0);\n      return a;\n    })(n.length);\n    while ((nd >= dd)) {\n      var d2 = polyShiftRight(d, nd - dd);\n      q[nd - dd] = n2[nd] / d2[nd];\n      polyMultiply(d2, q[nd - dd]);\n      polySubtract(n2, d2);\n      nd = polyDegree(n2);\n    }\n    return new Solution(q, n2);\n  }\n  var sol=polyLongDiv(n,d)\n  return [sol.quotient,sol.remainder]\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>PolynomialLongDivision</code> should be a function.'",
          "testString":
            "assert(typeof PolynomialLongDivision=='function','<code>PolynomialLongDivision</code> should be a function.');"
        },
        {
          "text":
            "'<code>PolynomialLongDivision('+JSON.stringify(polyLongTests[0][0])+','+JSON.stringify(polyLongTests[0][1])+')</code> should return a array.'",
          "testString":
            "assert(Array.isArray(PolynomialLongDivision(polyLongTests[0][0].slice(),polyLongTests[0][1].slice())),'<code>PolynomialLongDivision('+JSON.stringify(polyLongTests[0][0])+','+JSON.stringify(polyLongTests[0][1])+')</code> should return a array.');"
        },
        {
          "text":
            "'<code>PolynomialLongDivision('+JSON.stringify(polyLongTests[0][0])+','+JSON.stringify(polyLongTests[0][1])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(PolynomialLongDivision(polyLongTests[0][0].slice(),polyLongTests[0][1].slice()),results[0],'<code>PolynomialLongDivision('+JSON.stringify(polyLongTests[0][0])+','+JSON.stringify(polyLongTests[0][1])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>PolynomialLongDivision('+JSON.stringify(polyLongTests[1][0])+','+JSON.stringify(polyLongTests[1][1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(PolynomialLongDivision(polyLongTests[1][0].slice(),polyLongTests[1][1].slice()),results[1],'<code>PolynomialLongDivision('+JSON.stringify(polyLongTests[1][0])+','+JSON.stringify(polyLongTests[1][1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>PolynomialLongDivision('+JSON.stringify(polyLongTests[2][0])+','+JSON.stringify(polyLongTests[2][1])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(PolynomialLongDivision(polyLongTests[2][0].slice(),polyLongTests[2][1].slice()),results[2],'<code>PolynomialLongDivision('+JSON.stringify(polyLongTests[2][0])+','+JSON.stringify(polyLongTests[2][1])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>PolynomialLongDivision('+JSON.stringify(polyLongTests[3][0])+','+JSON.stringify(polyLongTests[3][1])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(PolynomialLongDivision(polyLongTests[3][0].slice(),polyLongTests[3][1].slice()),results[3],'<code>PolynomialLongDivision('+JSON.stringify(polyLongTests[3][0])+','+JSON.stringify(polyLongTests[3][1])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>PolynomialLongDivision('+JSON.stringify(polyLongTests[4][0])+','+JSON.stringify(polyLongTests[4][1])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(PolynomialLongDivision(polyLongTests[4][0].slice(),polyLongTests[4][1].slice()),results[4],'<code>PolynomialLongDivision('+JSON.stringify(polyLongTests[4][0])+','+JSON.stringify(polyLongTests[4][1])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f80",
      "challengeType": 5,
      "releasedOn": "August 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function PolynomialLongDivision (n,d) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "let polyLongTests=[",
            "[[-42,0,-12,1],[-3,1,0,0]],",
            "[[-4,0,-2,1],[-3,1,0,0]],",
            "[[-42,0,-12,1],[1,-2,1,0]],",
            "[[-3,2,-4,1],[2,1,0,0]],",
            "[[-7,2,-13,4],[-2,3,1,0]]]",
            "var results=[",
            "[[-27,-9,1,0],[-123,0,0,0]],",
            "[[3,1,1,0],[5,0,0,0]],",
            "[[-10,1,0,0],[-32,-21,0,0]],",
            "[[14,-6,1,0],[-31,0,0,0]],",
            "[[-25,4,0,0],[-57,85,0,0]]]"
          ]
        }
      }
    },
    {
      "title": "Polynomial regression",
      "description": [
        "Find an approximating polynomial of known degree for a given data.",
        "Example:",
        "For input data:",
        "x = {0,  1,  2,  3,  4,  5,  6,   7,   8,   9,   10};",
        "y = {1,  6,  17, 34, 57, 86, 121, 162, 209, 262, 321};",
        "The approximating polynomial is:",
        "3 x<sup>2</sup> + 2 x + 1",
        "Here, the polynomial's coefficients are (3, 2, 1)."
      ],
      "solutions": [
        "function PolynomialRegression (x, y) {\n  function average(arr) {\n    var av = 0;\n    for (var i = 0; i < arr.length; i++) {\n      av += arr[i];\n    }\n    return av / arr.length;\n  }\n\n  var n = x.length;\n  var r = new Array(n);\n  for (var i = 0; i < n; i++) r[i] = i;\n  var xm = average(x);\n  var ym = average(y);\n  var x2m = average(r.map(a => a * a));\n  var x3m = average(r.map(a => a * a * a));\n  var x4m = average(r.map(a => a * a * a * a));\n  var xym = 0.0;\n  for (var i = 0; i < x.length && i < y.length; ++i) {\n    xym += x[i] * y[i];\n  }\n  xym /= Math.min(x.length, y.length);\n  var x2ym = 0.0;\n  for (var i = 0; i < x.length && i < y.length; ++i) {\n    x2ym += x[i] * x[i] * y[i];\n  }\n  x2ym /= Math.min(x.length, y.length);\n\n  var sxx = x2m - xm * xm;\n  var sxy = xym - xm * ym;\n  var sxx2 = x3m - xm * x2m;\n  var sx2x2 = x4m - x2m * x2m;\n  var sx2y = x2ym - x2m * ym;\n\n  var b = (sxy * sx2x2 - sx2y * sxx2) / (sxx * sx2x2 - sxx2 * sxx2);\n  var c = (sx2y * sxx - sxy * sxx2) / (sxx * sx2x2 - sxx2 * sxx2);\n  var a = ym - b * xm - c * x2m;\n\n  var abc = xx => a + b * xx + c * xx * xx;\n  return [a,b,c]\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>PolynomialRegression</code> should be a function.'",
          "testString":
            "assert(typeof PolynomialRegression=='function','<code>PolynomialRegression</code> should be a function.');"
        },
        {
          "text":
            "'<code>PolynomialRegression('+JSON.stringify(polyRegTests[0][0])+','+JSON.stringify(polyRegTests[0][1])+')</code> should return a array.'",
          "testString":
            "assert(Array.isArray(PolynomialRegression(polyRegTests[0][0],polyRegTests[0][1])),'<code>PolynomialRegression('+JSON.stringify(polyRegTests[0][0])+','+JSON.stringify(polyRegTests[0][1])+')</code> should return a array.');"
        },
        {
          "text":
            "'<code>PolynomialRegression('+JSON.stringify(polyRegTests[0][0])+','+JSON.stringify(polyRegTests[0][1])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(PolynomialRegression(polyRegTests[0][0],polyRegTests[0][1]),results[0],'<code>PolynomialRegression('+JSON.stringify(polyRegTests[0][0])+','+JSON.stringify(polyRegTests[0][1])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>PolynomialRegression('+JSON.stringify(polyRegTests[1][0])+','+JSON.stringify(polyRegTests[1][1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(PolynomialRegression(polyRegTests[1][0],polyRegTests[1][1]),results[1],'<code>PolynomialRegression('+JSON.stringify(polyRegTests[1][0])+','+JSON.stringify(polyRegTests[1][1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>PolynomialRegression('+JSON.stringify(polyRegTests[2][0])+','+JSON.stringify(polyRegTests[2][1])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(PolynomialRegression(polyRegTests[2][0],polyRegTests[2][1]),results[2],'<code>PolynomialRegression('+JSON.stringify(polyRegTests[2][0])+','+JSON.stringify(polyRegTests[2][1])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f81",
      "challengeType": 5,
      "releasedOn": "August 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function PolynomialRegression (x, y) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "let polyRegTests=[",
            "[[0,1,2,3,4,5,6,7,8,9,10],[2,4,6,8,10,12,14,16,18,20,22]],",
            "[[0,1,2,3,4,5,6,7,8,9,10],[-1,1,5,11,19,29,41,55,71,89,109]],",
            "[[0,1,2,3,4,5,6,7,8,9,10],[1,6,17,34,57,86,121,162,209,262,321]]]",
            "var results=[",
            "[2,2,0],",
            "[-1,1,1],",
            "[1,2,3]]"
          ]
        }
      }
    },
    {
      "title": "Population count",
      "description": [
        "The <i><a href=\"https://en.wikipedia.org/wiki/Hamming weight\">population count</a></i>  is the number of  <b>1</b>s  (ones)  in the binary representation of a non-negative integer.",
        "<i>Population count</i> is also known as  <i>pop count</i>,  <i>popcount</i>,  <i>sideways sum</i>,  and  <i>Hamming weight</i>.",
        "For example,  <b>5</b>  (which is  <b>101</b>  in binary)  has a population count of  <b>2</b>.",
        "<i><a href=\"http://mathworld.wolfram.com/EvilNumber.html\">Evil numbers</a></i>  are non-negative integers  that have an  <i>even</i>  population count.",
        "<i><a href=\"http://mathworld.wolfram.com/OdiousNumber.html\">Odious numbers</a></i>  are positive integers that have an  <i>odd</i>  population count.",
        "Write a function that takes a number as parameter and returns an array. The first element should be the population count. The second element should be true or false if the number is evil or not. The third element should be true or false if the number is odious or not."
      ],
      "solutions": [
        "function popCountNumber (n) {\n  var popCount=0;\n  while(n!=0){\n    popCount+=n%2;\n    n>>=1;\n  }\n\n  return [popCount,popCount%2==0,popCount%2==1]\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>popCountNumber</code> should be a function.'",
          "testString":
            "assert(typeof popCountNumber=='function','<code>popCountNumber</code> should be a function.');"
        },
        {
          "text": "'<code>popCountNumber(7)</code> should return a array.'",
          "testString":
            "assert(Array.isArray(popCountNumber(7)),'<code>popCountNumber(7)</code> should return a array.');"
        },
        {
          "text":
            "'<code>popCountNumber(7)</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(popCountNumber(7),results[0],'<code>popCountNumber(7)</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>popCountNumber(89)</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(popCountNumber(89),results[1],'<code>popCountNumber(89)</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>popCountNumber(44)</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(popCountNumber(44),results[2],'<code>popCountNumber(44)</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>popCountNumber(29)</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(popCountNumber(29),results[3],'<code>popCountNumber(29)</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>popCountNumber(85)</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(popCountNumber(85),results[4],'<code>popCountNumber(85)</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f83",
      "challengeType": 5,
      "releasedOn": "August 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function popCountNumber (n) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "var results=[",
            "[3,false,true],",
            "[4,true,false],",
            "[3,false,true],",
            "[4,true,false],",
            "[4,true,false]]"
          ]
        }
      }
    },
    {
      "title": "Power set",
      "description": [
        "A  <a href=\"http://rosettacode.org/wiki/set\">set</a>  is a collection (container) of certain values, without any particular order, and no repeated values.",
        "It corresponds with a finite set in mathematics.",
        "A set can be implemented as an associative array (partial mapping) in which the value of each key-value pair is ignored.",
        "Given a set S, the <a href=\"https://en.wikipedia.org/wiki/Power_set\">power set</a> (or powerset) of S, written P(S), or 2<sup>S</sup>, is the set of all subsets of S.",
        "Write a function that takes an array as parameter and returns the powerset as an array. Note: Sort the array before returning it."
      ],
      "solutions": [
        "function powerset (ary) {\n    var ps = [[]];\n    for (var i=0; i < ary.length; i++) {\n        for (var j = 0, len = ps.length; j < len; j++) {\n            ps.push(ps[j].concat(ary[i]));\n        }\n    }\n    ps.sort()\n    return ps;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>powerset</code> should be a function.'",
          "testString":
            "assert(typeof powerset=='function','<code>powerset</code> should be a function.');"
        },
        {
          "text":
            "'<code>powerset('+JSON.stringify(powersetTests[0])+')</code> should return a array.'",
          "testString":
            "assert(Array.isArray(powerset(powersetTests[0])),'<code>powerset('+JSON.stringify(powersetTests[0])+')</code> should return a array.');"
        },
        {
          "text":
            "'<code>powerset('+JSON.stringify(powersetTests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(powerset(powersetTests[0]),results[0],'<code>powerset('+JSON.stringify(powersetTests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>powerset('+JSON.stringify(powersetTests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(powerset(powersetTests[1]),results[1],'<code>powerset('+JSON.stringify(powersetTests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>powerset('+JSON.stringify(powersetTests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(powerset(powersetTests[2]),results[2],'<code>powerset('+JSON.stringify(powersetTests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>powerset('+JSON.stringify(powersetTests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(powerset(powersetTests[3]),results[3],'<code>powerset('+JSON.stringify(powersetTests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>powerset('+JSON.stringify(powersetTests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(powerset(powersetTests[4]),results[4],'<code>powerset('+JSON.stringify(powersetTests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f84",
      "challengeType": 5,
      "releasedOn": "August 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function powerset (ary) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "let powersetTests=[",
            "[1,2],",
            "[7,8],",
            "[1,2,3],",
            "[4,5,6],",
            "[1,2,3,4]]",
            "var results=[",
            "[[],[1],[1,2],[2]],",
            "[[],[7],[7,8],[8]],",
            "[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]],",
            "[[],[4],[4,5],[4,5,6],[4,6],[5],[5,6],[6]],",
            "[[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,4],[1,3],[1,3,4],[1,4],[2],[2,3],[2,3,4],[2,4],[3],[3,4],[4]]]"
          ]
        }
      }
    },
    {
      "title": "Price fraction",
      "description": [
        "A friend of mine runs a pharmacy.  He has a specialized function in his Dispensary application which receives a decimal value of currency and replaces it to a standard value.  This value is regulated by a government department.",
        "Given a floating point value between  0.00  and  1.00,  rescale according to the following table:",
        ">=  0.00  <  0.06  :=  0.10",
        ">=  0.06  <  0.11  :=  0.18",
        ">=  0.11  <  0.16  :=  0.26",
        ">=  0.16  <  0.21  :=  0.32",
        ">=  0.21  <  0.26  :=  0.38",
        ">=  0.26  <  0.31  :=  0.44",
        ">=  0.31  <  0.36  :=  0.50",
        ">=  0.36  <  0.41  :=  0.54",
        ">=  0.41  <  0.46  :=  0.58",
        ">=  0.46  <  0.51  :=  0.62",
        ">=  0.51  <  0.56  :=  0.66",
        ">=  0.56  <  0.61  :=  0.70",
        ">=  0.61  <  0.66  :=  0.74",
        ">=  0.66  <  0.71  :=  0.78",
        ">=  0.71  <  0.76  :=  0.82",
        ">=  0.76  <  0.81  :=  0.86",
        ">=  0.81  <  0.86  :=  0.90",
        ">=  0.86  <  0.91  :=  0.94",
        ">=  0.91  <  0.96  :=  0.98",
        ">=  0.96  <  1.01  :=  1.00"
      ],
      "solutions": [
        "function getScaleFactor (v) {\n  var values=['0.10','0.18','0.26','0.32','0.38','0.44','0.50','0.54', '0.58','0.62','0.66','0.70','0.74','0.78','0.82','0.86', '0.90','0.94','0.98','1.00']\n  return parseFloat(values[(v * 100 - 1) / 5 | 0]);\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>getScaleFactor</code> should be a function.'",
          "testString":
            "assert(typeof getScaleFactor=='function','<code>getScaleFactor</code> should be a function.');"
        },
        {
          "text": "'<code>getScaleFactor(0.01)</code> should return a number.'",
          "testString":
            "assert(typeof getScaleFactor(0.01) == 'number','<code>getScaleFactor(0.01)</code> should return a number.');"
        },
        {
          "text":
            "'<code>getScaleFactor(0.01)</code> should return <code>0.1</code>.'",
          "testString":
            "assert.equal(getScaleFactor(0.01),0.1,'<code>getScaleFactor(0.01)</code> should return <code>0.1</code>.');"
        },
        {
          "text":
            "'<code>getScaleFactor(0.41)</code> should return <code>0.58</code>.'",
          "testString":
            "assert.equal(getScaleFactor(0.41),0.58,'<code>getScaleFactor(0.41)</code> should return <code>0.58</code>.');"
        },
        {
          "text":
            "'<code>getScaleFactor(0.21)</code> should return <code>0.38</code>.'",
          "testString":
            "assert.equal(getScaleFactor(0.21),0.38,'<code>getScaleFactor(0.21)</code> should return <code>0.38</code>.');"
        },
        {
          "text":
            "'<code>getScaleFactor(0.96)</code> should return <code>1</code>.'",
          "testString":
            "assert.equal(getScaleFactor(0.96),1,'<code>getScaleFactor(0.96)</code> should return <code>1</code>.');"
        },
        {
          "text":
            "'<code>getScaleFactor(0.32)</code> should return <code>0.5</code>.'",
          "testString":
            "assert.equal(getScaleFactor(0.32),0.5,'<code>getScaleFactor(0.32)</code> should return <code>0.5</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f86",
      "challengeType": 5,
      "releasedOn": "August 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function getScaleFactor (v) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Primality by trial division",
      "description": [
        "Write a boolean function that tells whether a given integer is prime.",
        "Remember that  <b>1</b>  and all non-positive numbers are not prime.",
        "Use trial division.",
        "Even numbers over two may be eliminated right away.",
        "A loop from  <b>3</b>  to  <b>&radic; </b> will suffice,  but other loops are allowed."
      ],
      "solutions": [
        "function isPrime (n) {\n  if (n == 2 || n == 3 || n == 5 || n == 7) {\n    return true;\n  } else if ((n < 2) || (n % 2 == 0)) {\n    return false;\n  } else {\n    for (var i = 3; i <= Math.sqrt(n); i += 2) {\n      if (n % i == 0)\n        return false;\n    }\n    return true;\n  }\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>isPrime</code> should be a function.'",
          "testString":
            "assert(typeof isPrime=='function','<code>isPrime</code> should be a function.');"
        },
        {
          "text": "'<code>isPrime(2)</code> should return a boolean.'",
          "testString":
            "assert(typeof isPrime(2) == 'boolean','<code>isPrime(2)</code> should return a boolean.');"
        },
        {
          "text": "'<code>isPrime(2)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isPrime(2),true,'<code>isPrime(2)</code> should return <code>true</code>.');"
        },
        {
          "text": "'<code>isPrime(3)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isPrime(3),true,'<code>isPrime(3)</code> should return <code>true</code>.');"
        },
        {
          "text": "'<code>isPrime(4)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isPrime(4),false,'<code>isPrime(4)</code> should return <code>false</code>.');"
        },
        {
          "text": "'<code>isPrime(5)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isPrime(5),true,'<code>isPrime(5)</code> should return <code>true</code>.');"
        },
        {
          "text": "'<code>isPrime(6)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isPrime(6),false,'<code>isPrime(6)</code> should return <code>false</code>.');"
        },
        {
          "text": "'<code>isPrime(7)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isPrime(7),true,'<code>isPrime(7)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isPrime(72)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isPrime(72),false,'<code>isPrime(72)</code> should return <code>false</code>.');"
        },
        {
          "text": "'<code>isPrime(19)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isPrime(19),true,'<code>isPrime(19)</code> should return <code>true</code>.');"
        },
        {
          "text":
            "'<code>isPrime(36)</code> should return <code>false</code>.'",
          "testString":
            "assert.equal(isPrime(36),false,'<code>isPrime(36)</code> should return <code>false</code>.');"
        },
        {
          "text": "'<code>isPrime(97)</code> should return <code>true</code>.'",
          "testString":
            "assert.equal(isPrime(97),true,'<code>isPrime(97)</code> should return <code>true</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f87",
      "challengeType": 5,
      "releasedOn": "August 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function isPrime (n) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Prime decomposition",
      "description": [
        "The prime decomposition of a number is defined as a list of prime numbers which when all multiplied together, are equal to that number.",
        "12 = 2 &times; 2 &times; 3,  so its prime decomposition is  {2, 2, 3}",
        "Write a function which returns an <a href=\"http://rosettacode.org/wiki/Arrays\">array</a> which contains the prime decomposition of a given number  $n$  greater than  <b>1</b>."
      ],
      "solutions": [
        "function runFactorize (n) {\n  if (n <= 3)\n      return [n];\n\n  var ans = [];\n  var done = false;\n  while (!done)\n  {\n    if (n%2 === 0){\n        ans.push(2);\n        n /= 2;\n        continue;\n    }\n    if (n%3 === 0){\n        ans.push(3);\n        n /= 3;\n        continue;\n    }\n    if ( n === 1)\n      return ans;\n    var sr = Math.sqrt(n);\n    done = true;\n    // try to divide the checked number by all numbers till its square root.\n    for (var i=6; i<=sr; i+=6){\n        if (n%(i-1) === 0){ // is n divisible by i-1?\n            ans.push( (i-1) );\n            n /= (i-1);\n            done = false;\n            break;\n        }\n        if (n%(i+1) === 0){ // is n divisible by i+1?\n            ans.push( (i+1) );\n            n /= (i+1);\n            done = false;\n            break;\n        }\n    }\n  }\n  ans.push( n );\n  return ans;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>runFactorize</code> should be a function.'",
          "testString":
            "assert(typeof runFactorize=='function','<code>runFactorize</code> should be a function.');"
        },
        {
          "text": "'<code>runFactorize(1024)</code> should return a array.'",
          "testString":
            "assert(Array.isArray(runFactorize(1024)),'<code>runFactorize(1024)</code> should return a array.');"
        },
        {
          "text":
            "'<code>runFactorize(1024)</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(runFactorize(1024),results[0],'<code>runFactorize(1024)</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>runFactorize(2047)</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(runFactorize(2047),results[1],'<code>runFactorize(2047)</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>runFactorize(3684)</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(runFactorize(3684),results[2],'<code>runFactorize(3684)</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>runFactorize(8388607)</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(runFactorize(8388607),results[3],'<code>runFactorize(8388607)</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>runFactorize(536870911)</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(runFactorize(536870911),results[4],'<code>runFactorize(536870911)</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f88",
      "challengeType": 5,
      "releasedOn": "August 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function runFactorize (n) {", "  // Good luck!", "}"],
          "head": [],
          "tail": [
            "var results=[",
            "[2,2,2,2,2,2,2,2,2,2],",
            "[23,89],",
            "[2,2,3,307],",
            "[47,178481],",
            "[233,1103,2089]]"
          ]
        }
      }
    },
    {
      "title": "Primes - allocate descendants to their ancestors",
      "description": [
        "The concept, rather simple, is to add the decomposition into prime factors of a number to get its 'ancestors'.",
        "The problem is to calculate the total number of descendants for a given number.",
        "You only have to consider the prime factors < 100.",
        "A grand total of the descendants has to be printed at the end of the list.",
        "Example :",
        "46 = 2*23 --> 2+23 = 25, is the parent of 46.",
        "25 = 5*5  --> 5+5  = 10, is the parent of 25.",
        "10 = 2*5  --> 2+5  = 7,  is the parent of 10.",
        "7 is a prime factor and, as such, has no parent.46 has 3 ancestors (7, 10 and 25).",
        "46 has 557 descendants.",
        "[46] Level: 3",
        "Ancestors: 7, 10, 25",
        "Descendants: 557"
      ],
      "solutions": [
        "function descendants (n) {\n  function get_primes(max) {\n    if (max < 2)\n      return []\n    var lprimes = [2]\n    for (var x = 3, l = max + 1; x < l; x += 2) {\n      var f = true\n      for (var p of lprimes) {\n        if (x % p == 0) {\n          f = false;\n          break\n        }\n      }\n      if (f)\n        lprimes.push(x)\n    }\n    return lprimes\n  }\n  var descendants = new Array(n + 1)\n  for (var i = 0; i < descendants.length; i++)\n    descendants[i] = []\n\n  var ancestors = new Array(n + 1)\n  for (var i = 0; i < ancestors.length; i++)\n    ancestors[i] = []\n\n  var primes = get_primes(n)\n  for (var p of primes) {\n    descendants[p].push(p)\n    for (var s = 1; s < descendants.length - p; s++) {\n      for (var pr of descendants[s])\n        descendants[s + p].push(p * pr)\n    }\n  }\n\n  for (var p of primes.concat([4]))\n    descendants[p].pop()\n\n  return descendants[n].length\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>descendants</code> should be a function.'",
          "testString":
            "assert(typeof descendants=='function','<code>descendants</code> should be a function.');"
        },
        {
          "text": "'<code>descendants(7)</code> should return a number.'",
          "testString":
            "assert(typeof descendants(7) == 'number','<code>descendants(7)</code> should return a number.');"
        },
        {
          "text": "'<code>descendants(7)</code> should return <code>2</code>.'",
          "testString":
            "assert.equal(descendants(7),2,'<code>descendants(7)</code> should return <code>2</code>.');"
        },
        {
          "text":
            "'<code>descendants(10)</code> should return <code>5</code>.'",
          "testString":
            "assert.equal(descendants(10),5,'<code>descendants(10)</code> should return <code>5</code>.');"
        },
        {
          "text":
            "'<code>descendants(25)</code> should return <code>52</code>.'",
          "testString":
            "assert.equal(descendants(25),52,'<code>descendants(25)</code> should return <code>52</code>.');"
        },
        {
          "text":
            "'<code>descendants(33)</code> should return <code>140</code>.'",
          "testString":
            "assert.equal(descendants(33),140,'<code>descendants(33)</code> should return <code>140</code>.');"
        },
        {
          "text":
            "'<code>descendants(46)</code> should return <code>557</code>.'",
          "testString":
            "assert.equal(descendants(46),557,'<code>descendants(46)</code> should return <code>557</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f89",
      "challengeType": 5,
      "releasedOn": "August 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function descendants (n) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Primorial numbers",
      "description": [
        "Primorial numbers are those formed by multiplying successive prime numbers.",
        "The primorial number series is:",
        "primorial(0) = 1(by definition)",
        "primorial(1) = 2(2)",
        "primorial(2) = 6(2*3)",
        "primorial(3) = 30(2*3*5)",
        "primorial(4) = 210(2*3*5*7)",
        "primorial(5) = 2310(2*3*5*7*11)",
        "primorial(6) = 30030(2*3*5*7*11*13)",
        "To express this mathematically,  <b>primorial<sub><i>n</i></sub></b>  is the product of the first  <i>n</i>  (successive) primes:",
        "$primorial_n = \\prod_{k=1}^n prime_k$",
        "where  $prime_k$  is the  <i>k</i><sup><i>th</i></sup>  prime number.",
        "In some sense, generating primorial numbers is similar to factorials.",
        "As with factorials, primorial numbers get large quickly.",
        "Write a function that takes $n$ as parameter and returns the $n^{th}$ primorial number."
      ],
      "solutions": [
        "function primorial (n) {\n  function genSieve(limit) {\n    var composite = new Array(limit);\n    composite[0] = composite[1] = true;\n    var max = (Math.sqrt(limit) | 0);\n    for (var n = 2; n <= max; n++) {\n      if (!composite[n]) {\n        for (var k = n * n; k < limit; k += n) {\n          composite[k] = true;\n        };\n      }\n    };\n    return composite;\n  }\n  var sieveLimit = 1300000\n  var sieve = genSieve(sieveLimit)\n\n  if (n === 0)\n    return 1;\n  var result = 1;\n  for (var i = 0; i < sieveLimit && n > 0; i++) {\n    if (sieve[i])\n      continue;\n    result = result * i;\n    n--;\n  };\n  return result;\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>primorial</code> should be a function.'",
          "testString":
            "assert(typeof primorial=='function','<code>primorial</code> should be a function.');"
        },
        {
          "text": "'<code>primorial(1)</code> should return a number.'",
          "testString":
            "assert(typeof primorial(1) == 'number','<code>primorial(1)</code> should return a number.');"
        },
        {
          "text": "'<code>primorial(1)</code> should return <code>2</code>.'",
          "testString":
            "assert.equal(primorial(1),2,'<code>primorial(1)</code> should return <code>2</code>.');"
        },
        {
          "text": "'<code>primorial(2)</code> should return <code>6</code>.'",
          "testString":
            "assert.equal(primorial(2),6,'<code>primorial(2)</code> should return <code>6</code>.');"
        },
        {
          "text": "'<code>primorial(3)</code> should return <code>30</code>.'",
          "testString":
            "assert.equal(primorial(3),30,'<code>primorial(3)</code> should return <code>30</code>.');"
        },
        {
          "text": "'<code>primorial(4)</code> should return <code>210</code>.'",
          "testString":
            "assert.equal(primorial(4),210,'<code>primorial(4)</code> should return <code>210</code>.');"
        },
        {
          "text":
            "'<code>primorial(5)</code> should return <code>2310</code>.'",
          "testString":
            "assert.equal(primorial(5),2310,'<code>primorial(5)</code> should return <code>2310</code>.');"
        },
        {
          "text":
            "'<code>primorial(6)</code> should return <code>30030</code>.'",
          "testString":
            "assert.equal(primorial(6),30030,'<code>primorial(6)</code> should return <code>30030</code>.');"
        },
        {
          "text":
            "'<code>primorial(7)</code> should return <code>510510</code>.'",
          "testString":
            "assert.equal(primorial(7),510510,'<code>primorial(7)</code> should return <code>510510</code>.');"
        },
        {
          "text":
            "'<code>primorial(8)</code> should return <code>9699690</code>.'",
          "testString":
            "assert.equal(primorial(8),9699690,'<code>primorial(8)</code> should return <code>9699690</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f8a",
      "challengeType": 5,
      "releasedOn": "August 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function primorial (n) {", "  // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Problem of Apollonius",
      "description": [
        "Implement a solution to the Problem of Apollonius  (<a href=\"https://en.wikipedia.org/wiki/Problem_of_Apollonius\">description on Wikipedia</a>)  which is the problem of finding the circle that is tangent to three specified circles.  There is an <a href=\"https://en.wikipedia.org/wiki/Problem_of_Apollonius#Algebraic_solutions\">algebraic solution</a> which is pretty straightforward.",
        "Write a function that takes 3 arrays and 3 numbers as parameters. The 3 arrays represent the circles ([x,y,radius]). The three numbers represents whether the resultant circle should be internally (-1) or extenally tangent (1) to the respective circles. The function should return the resultant circle as an array in the form: [x,y,radius]."
      ],
      "solutions": [
        "function solveApollonius (c1, c2, c3, s1, s2, s3) {\n  var x1 = c1[0];\n  var y1 = c1[1];\n  var r1 = c1[2];\n  var x2 = c2[0];\n  var y2 = c2[1];\n  var r2 = c2[2];\n  var x3 = c3[0];\n  var y3 = c3[1];\n  var r3 = c3[2];\n  var v11 = 2 * x2 - 2 * x1;\n  var v12 = 2 * y2 - 2 * y1;\n  var v13 = x1 * x1 - x2 * x2 + y1 * y1 - y2 * y2 - r1 * r1 + r2 * r2;\n  var v14 = 2 * s2 * r2 - 2 * s1 * r1;\n  var v21 = 2 * x3 - 2 * x2;\n  var v22 = 2 * y3 - 2 * y2;\n  var v23 = x2 * x2 - x3 * x3 + y2 * y2 - y3 * y3 - r2 * r2 + r3 * r3;\n  var v24 = 2 * s3 * r3 - 2 * s2 * r2;\n  var w12 = v12 / v11;\n  var w13 = v13 / v11;\n  var w14 = v14 / v11;\n  var w22 = v22 / v21 - w12;\n  var w23 = v23 / v21 - w13;\n  var w24 = v24 / v21 - w14;\n  var P = -w23 / w22;\n  var Q = w24 / w22;\n  var M = -w12 * P - w13;\n  var N = w14 - w12 * Q;\n  var a = N * N + Q * Q - 1;\n  var b = 2 * M * N - 2 * N * x1 + 2 * P * Q - 2 * Q * y1 + 2 * s1 * r1;\n  var c = x1 * x1 + M * M - 2 * M * x1 + P * P + y1 * y1 - 2 * P * y1 - r1 * r1;\n  var D = b * b - 4 * a * c;\n  var rs = (-b - Math.sqrt(D)) / (2 * a);\n  var xs = M + N * rs;\n  var ys = P + Q * rs;\n\n  return [xs,ys,rs].map((n)=>Math.round(n*1000)/1000)\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>solveApollonius</code> should be a function.'",
          "testString":
            "assert(typeof solveApollonius=='function','<code>solveApollonius</code> should be a function.');"
        },
        {
          "text":
            "'<code>solveApollonius('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+','+JSON.stringify(tests[0][2])+',1,1,1)</code> should return a array.'",
          "testString":
            "assert(Array.isArray(solveApollonius(tests[0][0],tests[0][1],tests[0][2],1,1,1)),'<code>solveApollonius('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+','+JSON.stringify(tests[0][2])+',1,1,1)</code> should return a array.');"
        },
        {
          "text":
            "'<code>solveApollonius('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+','+JSON.stringify(tests[0][2])+',1,1,1)</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(solveApollonius(tests[0][0],tests[0][1],tests[0][2],1,1,1),results[0],'<code>solveApollonius('+JSON.stringify(tests[0][0])+','+JSON.stringify(tests[0][1])+','+JSON.stringify(tests[0][2])+',1,1,1)</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>solveApollonius('+JSON.stringify(tests[1][0])+','+JSON.stringify(tests[1][1])+','+JSON.stringify(tests[1][2])+',-1,-1,-1)</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(solveApollonius(tests[1][0],tests[1][1],tests[1][2],-1,-1,-1),results[1],'<code>solveApollonius('+JSON.stringify(tests[1][0])+','+JSON.stringify(tests[1][1])+','+JSON.stringify(tests[1][2])+',-1,-1,-1)</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>solveApollonius('+JSON.stringify(tests[2][0])+','+JSON.stringify(tests[2][1])+','+JSON.stringify(tests[2][2])+',-1,1,1)</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(solveApollonius(tests[2][0],tests[2][1],tests[2][2],-1,1,1),results[2],'<code>solveApollonius('+JSON.stringify(tests[2][0])+','+JSON.stringify(tests[2][1])+','+JSON.stringify(tests[2][2])+',-1,1,1)</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>solveApollonius('+JSON.stringify(tests[3][0])+','+JSON.stringify(tests[3][1])+','+JSON.stringify(tests[3][2])+',1,-1,-1)</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(solveApollonius(tests[3][0],tests[3][1],tests[3][2],1,-1,-1),results[3],'<code>solveApollonius('+JSON.stringify(tests[3][0])+','+JSON.stringify(tests[3][1])+','+JSON.stringify(tests[3][2])+',1,-1,-1)</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>solveApollonius('+JSON.stringify(tests[4][0])+','+JSON.stringify(tests[4][1])+','+JSON.stringify(tests[4][2])+',1,-1,1)</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(solveApollonius(tests[4][0],tests[4][1],tests[4][2],1,-1,1),results[4],'<code>solveApollonius('+JSON.stringify(tests[4][0])+','+JSON.stringify(tests[4][1])+','+JSON.stringify(tests[4][2])+',1,-1,1)</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        },
        {
          "text":
            "'<code>solveApollonius('+JSON.stringify(tests[5][0])+','+JSON.stringify(tests[5][1])+','+JSON.stringify(tests[5][2])+',-1,1,-1)</code> should return <code>'+JSON.stringify(results[5])+'</code>.'",
          "testString":
            "assert.deepEqual(solveApollonius(tests[5][0],tests[5][1],tests[5][2],-1,1,-1),results[5],'<code>solveApollonius('+JSON.stringify(tests[5][0])+','+JSON.stringify(tests[5][1])+','+JSON.stringify(tests[5][2])+',-1,1,-1)</code> should return <code>'+JSON.stringify(results[5])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f8d",
      "challengeType": 5,
      "releasedOn": "August 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function solveApollonius (c1, c2, c3, s1, s2, s3) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var tests=[",
            "[[0,0,1],[4,0,1],[2,4,2]],",
            "[[0,0,1],[4,0,1],[2,4,2]],",
            "[[1,0,1],[3,2,1],[10,4,2]],",
            "[[0,2,0],[3,0,1],[5,4,2]],",
            "[[0,0,3],[4,0,1],[6,4,2]],",
            "[[0,4,1],[4,0,1],[7,4,2]]]",
            "var results=[",
            "[2,2.1,3.9],",
            "[2,0.833,1.167],",
            "[7.652,1.088,5.74],",
            "[1.671,2.362,1.71],",
            "[5.1,0,-2.1],",
            "[2.88,1.46,2.84]]"
          ]
        }
      }
    },
    {
      "title": "Pythagorean triples",
      "description": [
        "A <a href=\"https://en.wikipedia.org/wiki/Pythagorean_triple\">Pythagorean triple</a> is defined as three positive integers $(a, b, c)$ where $a < b < c$, and $a^2+b^2=c^2.$",
        "They are called primitive triples if $a, b, c$ are co-prime, that is, if their pairwise greatest common divisors ${\\rm gcd}(a, b) = {\\rm gcd}(a, c) = {\\rm gcd}(b, c) = 1$.",
        "Because of their relationship through the Pythagorean theorem, a, b, and c are co-prime if a and b are co-prime (${\\rm gcd}(a, b) = 1$).",
        "Each triple forms the length of the sides of a right triangle, whose perimeter is $P=a+b+c$.",
        "The task is to determine how many Pythagorean triples there are with a perimeter no larger than a given value."
      ],
      "solutions": [
        "function pythagoreanTriplets (maxPerim) {\n  const pythTripleCount = (p, maxPerim) => {\n        const xs = enumFromTo(1, Math.floor(maxPerim / 2));\n\n        return  concatMap(x =>\n                concatMap(y =>\n                concatMap(z =>\n                    ((x + y + z <= maxPerim) &&\n                        (x * x + y * y === z * z) &&\n                        p(x, y, z)) ? [\n                        [x, y, z]\n                    ] : [],\n                xs.slice(y)), xs.slice(x)), xs\n            )\n            .length;\n    };\n\n    const concatMap = (f, xs) =>\n        xs.length > 0 ? [].concat.apply([], xs.map(f)) : [];\n\n    const enumFromTo = (m, n) =>\n        (typeof m !== 'number' ? (\n            enumFromToChar\n        ) : enumFromToInt)\n        .apply(null, [m, n]);\n\n    const enumFromToInt = (m, n) =>\n        n >= m ? Array.from({\n            length: Math.floor(n - m) + 1\n        }, (_, i) => m + i) : [];\n\n    const gcd = (x, y) => {\n        const _gcd = (a, b) => (b === 0 ? a : _gcd(b, a % b));\n        return _gcd(Math.abs(x), Math.abs(y));\n    };\n\n    return [pythTripleCount(x=>true,maxPerim),pythTripleCount((x, y, _) => gcd(x, y) === 1, maxPerim)]\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>pythagoreanTriplets</code> should be a function.'",
          "testString":
            "assert(typeof pythagoreanTriplets=='function','<code>pythagoreanTriplets</code> should be a function.');"
        },
        {
          "text":
            "'<code>pythagoreanTriplets(20)</code> should return a array.'",
          "testString":
            "assert(Array.isArray(pythagoreanTriplets(20)),'<code>pythagoreanTriplets(20)</code> should return a array.');"
        },
        {
          "text":
            "'<code>pythagoreanTriplets(20)</code> should return <code>'+JSON.stringify(results[0])+'</code>.'",
          "testString":
            "assert.deepEqual(pythagoreanTriplets(20),results[0],'<code>pythagoreanTriplets(20)</code> should return <code>'+JSON.stringify(results[0])+'</code>.');"
        },
        {
          "text":
            "'<code>pythagoreanTriplets(30)</code> should return <code>'+JSON.stringify(results[1])+'</code>.'",
          "testString":
            "assert.deepEqual(pythagoreanTriplets(30),results[1],'<code>pythagoreanTriplets(30)</code> should return <code>'+JSON.stringify(results[1])+'</code>.');"
        },
        {
          "text":
            "'<code>pythagoreanTriplets(50)</code> should return <code>'+JSON.stringify(results[2])+'</code>.'",
          "testString":
            "assert.deepEqual(pythagoreanTriplets(50),results[2],'<code>pythagoreanTriplets(50)</code> should return <code>'+JSON.stringify(results[2])+'</code>.');"
        },
        {
          "text":
            "'<code>pythagoreanTriplets(70)</code> should return <code>'+JSON.stringify(results[3])+'</code>.'",
          "testString":
            "assert.deepEqual(pythagoreanTriplets(70),results[3],'<code>pythagoreanTriplets(70)</code> should return <code>'+JSON.stringify(results[3])+'</code>.');"
        },
        {
          "text":
            "'<code>pythagoreanTriplets(100)</code> should return <code>'+JSON.stringify(results[4])+'</code>.'",
          "testString":
            "assert.deepEqual(pythagoreanTriplets(100),results[4],'<code>pythagoreanTriplets(100)</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f91",
      "challengeType": 5,
      "releasedOn": "August 22, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function pythagoreanTriplets (maxPerim) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "var results=[",
            "[1,1],",
            "[3,2],",
            "[6,3],",
            "[10,5],",
            "[17,7]]"
          ]
        }
      }
    },
    {
      "title": "QR decomposition",
      "description": [
        "Any rectangular $m \\times n$ matrix $\\mathit A$ can be decomposed to a product of an orthogonal matrix $\\mathit Q$ and an upper (right) triangular matrix $\\mathit R$, as described in <a href=\"https://en.wikipedia.org/wiki/QR decomposition\">QR decomposition</a>.",
        "<b>Task</b>",
        "Write a function that takes a matrix as a parameter and returns the Q and R matrix in the form [Q,R] by perfoming QR decomposition. Note that every element of Q and R elements should be rounded to 3 decimal places. The method of <a href=\"https://en.wikipedia.org/wiki/ Householder transformation\">Householder reflections</a> should be used:",
        "<b>Method</b>",
        "Multiplying a given vector $\\mathit a$, for example the first column of matrix $\\mathit A$, with the Householder matrix $\\mathit H$, which is given as",
        "$H = I - \\frac {2} {u^T u} u u^T$",
        "reflects $\\mathit a$ about a plane given by its normal vector $\\mathit u$. When the normal vector of the plane $\\mathit u$ is given as",
        "$u = a - \\|a\\|_2 \\; e_1$",
        "then the transformation reflects $\\mathit a$ onto the first standard basis vector",
        "$e_1 = [1 \\; 0 \\; 0 \\; ...]^T$",
        "which means that all entries but the first become zero. To avoid numerical cancellation errors, we should take the opposite sign of $a_1$:",
        "$u = a + \\textrm{sign}(a_1)\\|a\\|_2 \\; e_1$",
        "and normalize with respect to the first element:",
        "$v = \\frac{u}{u_1}$",
        "The equation for $H$ thus becomes:",
        "$H = I - \\frac {2} {v^T v} v v^T$",
        "or, in another form",
        "$H = I - \\beta v v^T$",
        "with",
        "$\\beta = \\frac {2} {v^T v}$",
        "Applying $\\mathit H$ on $\\mathit a$ then gives",
        "$H \\; a = -\\textrm{sign}(a_1) \\; \\|a\\|_2 \\; e_1$",
        "and applying $\\mathit H$ on the matrix $\\mathit A$ zeroes all subdiagonal elements of the first column:",
        "$H_1 \\; A = \\begin{pmatrix} r_{11} & r_{12} & r_{13} \\\\ 0    & *    & * \\\\ 0    & *    & * \\end{pmatrix}$",
        "In the second step, the second column of $\\mathit A$, we want to zero all elements but the first two, which means that we have to calculate $\\mathit H$ with the first column of the <i>submatrix</i> (denoted *), not on the whole second column of $\\mathit A$.",
        "To get $H_2$, we then embed the new $\\mathit H$ into an $m \\times n$ identity:",
        "$H_2 = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & H & \\\\ 0 &   & \\end{pmatrix}$",
        "This is how we can, column by column, remove all subdiagonal elements of $\\mathit A$ and thus transform it into $\\mathit R$.",
        "$H_n \\; ... \\; H_3 H_2 H_1 A = R$",
        "The product of all the Householder matrices $\\mathit H$, for every column, in reverse order, will then yield the orthogonal matrix $\\mathit Q$.",
        "$H_1 H_2 H_3 \\; ... \\; H_n = Q$",
        "The QR decomposition should then be used to solve linear least squares (<a href=\"http://rosettacode.org/wiki/Multiple regression\">Multiple regression</a>) problems $\\mathit A x = b$ by solving",
        "$ R \\; x = Q^T \\; b $",
        "When $\\mathit R$ is not square, i.e. $m > n$ we have to cut off the $\\mathit m - n$ zero padded bottom rows.",
        "$R = \\begin{pmatrix} R_1 \\\\ 0 \\end{pmatrix}$",
        "and the same for the RHS:",
        "$Q^T \\; b = \\begin{pmatrix} q_1 \\\\ q_2 \\end{pmatrix}$",
        "Finally, solve the square upper triangular system by back substitution:",
        "$R_1 \\; x = q_1$"
      ],
      "solutions": [
        "function QRDecomposition (A) {\n  function mat_t(m, n) {\n    this.m = m;\n    this.n = n;\n    this.v = new Array(m);\n    for (var i = 0; i < this.v.length; i++) {\n      this.v[i] = new Array(n);\n      this.v[i].fill(0)\n    }\n  }\n\n  function matrix_transpose(m) {\n    for (var i = 0; i < m.m; i++) {\n      for (var j = 0; j < i; j++) {\n        var t = m.v[i][j];\n        m.v[i][j] = m.v[j][i];\n        m.v[j][i] = t;\n      }\n    }\n    return m\n  }\n\n  function matrix_mul(x, y) {\n    if (x.n != y.m) return 0;\n    var r = new mat_t(x.m, y.n);\n    for (var i = 0; i < x.m; i++)\n      for (var j = 0; j < y.n; j++)\n        for (var k = 0; k < x.n; k++)\n          r.v[i][j] += x.v[i][k] * y.v[k][j];\n    return r;\n  }\n\n  function matrix_minor(x, d) {\n    var m = new mat_t(x.m, x.n);\n    for (var i = 0; i < d; i++)\n      m.v[i][i] = 1;\n    for (var i = d; i < x.m; i++)\n      for (var j = d; j < x.n; j++)\n        m.v[i][j] = x.v[i][j];\n    return m;\n  }\n\n  function vmadd(a, b, s, c, n) {\n    for (var i = 0; i < n; i++)\n      c[i] = a[i] + s * b[i];\n    return c;\n  }\n\n  function vmul(v, n) {\n    var x = new mat_t(n, n);\n    for (var i = 0; i < n; i++)\n      for (var j = 0; j < n; j++)\n        x.v[i][j] = -2 * v[i] * v[j];\n    for (var i = 0; i < n; i++)\n      x.v[i][i] += 1;\n\n    return x;\n  }\n\n  function vnorm(x, n) {\n    var sum = 0;\n    for (var i = 0; i < n; i++) sum += x[i] * x[i];\n    return Math.sqrt(sum);\n  }\n\n  function vdiv(x, d, y, n) {\n    for (var i = 0; i < n; i++) y[i] = x[i] / d;\n    return y;\n  }\n\n  function mcol(m, v, c) {\n    for (var i = 0; i < m.m; i++)\n      v[i] = m.v[i][c];\n    return v;\n  }\n\n  var m = new mat_t(A.length, A[0].length)\n  m.v = A\n  var q = new Array(m.m);\n  for (var i = 0; i < q.length; i++) {\n    q[i] = new mat_t(1, 1)\n  }\n  var z = m,\n    z1;\n  for (var k = 0; k < m.n && k < m.m - 1; k++) {\n    var e = new Array(m.m),\n      x = new Array(m.m),\n      a;\n    z1 = matrix_minor(z, k);\n    z = z1;\n\n    mcol(z, x, k);\n    a = vnorm(x, m.m);\n    if (m.v[k][k] > 0) a = -a;\n\n    for (var i = 0; i < m.m; i++)\n      e[i] = (i == k) ? 1 : 0;\n\n    vmadd(x, e, a, e, m.m);\n    vdiv(e, vnorm(e, m.m), e, m.m);\n    q[k] = vmul(e, m.m);\n    z1 = matrix_mul(q[k], z);\n    z = z1;\n  }\n\n  var Q = q[0];\n  var R = matrix_mul(q[0], m);\n  for (var i = 1; i < m.n && i < m.m - 1; i++) {\n    z1 = matrix_mul(q[i], Q);\n    Q = z1;\n  }\n  z = matrix_mul(Q, m);\n  R = z;\n  Q = matrix_transpose(Q);\n\n  const roundMat = (e => e.map(f => f.map(g => 0 + Math.round(g * 1000) / 1000)))\n\n  return [roundMat(Q.v), roundMat(R.v)]\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>QRDecomposition</code> should be a function.'",
          "testString":
            "assert(typeof QRDecomposition=='function','<code>QRDecomposition</code> should be a function.');"
        },
        {
          "text":
            "'<code>QRDecomposition([[3,8],[4,6]])</code> should return a array.'",
          "testString":
            "assert(Array.isArray(QRDecomposition([[3,8],[4,6]])),'<code>QRDecomposition([[3,8],[4,6]])</code> should return a array.');"
        },
        {
          "text":
            "'<code>QRDecomposition([[3,8],[4,6]])</code> should return <code>[[[0.6,0.8],[0.8,-0.6]],[[5,9.6],[0,2.8]]]</code>.'",
          "testString":
            "assert.deepEqual(QRDecomposition([[3,8],[4,6]]),[[[0.6,0.8],[0.8,-0.6]],[[5,9.6],[0,2.8]]],'<code>QRDecomposition([[3,8],[4,6]])</code> should return <code>[[[0.6,0.8],[0.8,-0.6]],[[5,9.6],[0,2.8]]]</code>.');"
        },
        {
          "text":
            "'<code>QRDecomposition([[6,1,1],[4,-2,5],[2,8,7]])</code> should return <code>[[[0.802,0.062,-0.594],[0.535,0.371,0.76],[0.267,-0.927,0.264]],[[7.483,1.871,5.345],[0,-8.093,-4.572],[0,0,5.053]]]</code>.'",
          "testString":
            "assert.deepEqual(QRDecomposition([[6,1,1],[4,-2,5],[2,8,7]]),[[[0.802,0.062,-0.594],[0.535,0.371,0.76],[0.267,-0.927,0.264]],[[7.483,1.871,5.345],[0,-8.093,-4.572],[0,0,5.053]]],'<code>QRDecomposition([[6,1,1],[4,-2,5],[2,8,7]])</code> should return <code>[[[0.802,0.062,-0.594],[0.535,0.371,0.76],[0.267,-0.927,0.264]],[[7.483,1.871,5.345],[0,-8.093,-4.572],[0,0,5.053]]]</code>.');"
        },
        {
          "text":
            "'<code>QRDecomposition([[2,-3,1],[2,0,-1],[1,4,5]])</code> should return <code>[[[0.667,0.516,-0.538],[0.667,-0.09,0.74],[0.333,-0.852,-0.404]],[[3,-0.667,1.667],[0,-4.955,-3.655],[0,0,-3.296]]]</code>.'",
          "testString":
            "assert.deepEqual(QRDecomposition([[2,-3,1],[2,0,-1],[1,4,5]]),[[[0.667,0.516,-0.538],[0.667,-0.09,0.74],[0.333,-0.852,-0.404]],[[3,-0.667,1.667],[0,-4.955,-3.655],[0,0,-3.296]]],'<code>QRDecomposition([[2,-3,1],[2,0,-1],[1,4,5]])</code> should return <code>[[[0.667,0.516,-0.538],[0.667,-0.09,0.74],[0.333,-0.852,-0.404]],[[3,-0.667,1.667],[0,-4.955,-3.655],[0,0,-3.296]]]</code>.');"
        },
        {
          "text":
            "'<code>QRDecomposition([[1,3,2],[-3,-1,-3],[2,3,1]])</code> should return <code>[[[0.267,-0.726,0.634],[-0.802,-0.532,-0.272],[0.535,-0.436,-0.724]],[[3.742,3.207,3.474],[0,-2.952,-0.29],[0,0,1.358]]]</code>.'",
          "testString":
            "assert.deepEqual(QRDecomposition([[1,3,2],[-3,-1,-3],[2,3,1]]),[[[0.267,-0.726,0.634],[-0.802,-0.532,-0.272],[0.535,-0.436,-0.724]],[[3.742,3.207,3.474],[0,-2.952,-0.29],[0,0,1.358]]],'<code>QRDecomposition([[1,3,2],[-3,-1,-3],[2,3,1]])</code> should return <code>[[[0.267,-0.726,0.634],[-0.802,-0.532,-0.272],[0.535,-0.436,-0.724]],[[3.742,3.207,3.474],[0,-2.952,-0.29],[0,0,1.358]]]</code>.');"
        },
        {
          "text":
            "'<code>QRDecomposition([[12,-51,4],[6,167,-68],[-4,24,-41],[-1,1,0],[2,0,3]])</code> should return <code>[[[0.846,-0.391,0.343,0.082,0.078],[0.423,0.904,-0.029,0.026,0.045],[-0.282,0.17,0.933,-0.047,-0.137],[-0.071,0.014,-0.001,0.98,-0.184],[0.141,-0.017,-0.106,-0.171,-0.969]],[[14.177,20.667,-13.402],[0,175.043,-70.08],[0,0,-35.202],[0,0,0],[0,0,0]]]</code>.'",
          "testString":
            "assert.deepEqual(QRDecomposition([[12,-51,4],[6,167,-68],[-4,24,-41],[-1,1,0],[2,0,3]]),[[[0.846,-0.391,0.343,0.082,0.078],[0.423,0.904,-0.029,0.026,0.045],[-0.282,0.17,0.933,-0.047,-0.137],[-0.071,0.014,-0.001,0.98,-0.184],[0.141,-0.017,-0.106,-0.171,-0.969]],[[14.177,20.667,-13.402],[0,175.043,-70.08],[0,0,-35.202],[0,0,0],[0,0,0]]],'<code>QRDecomposition([[12,-51,4],[6,167,-68],[-4,24,-41],[-1,1,0],[2,0,3]])</code> should return <code>[[[0.846,-0.391,0.343,0.082,0.078],[0.423,0.904,-0.029,0.026,0.045],[-0.282,0.17,0.933,-0.047,-0.137],[-0.071,0.014,-0.001,0.98,-0.184],[0.141,-0.017,-0.106,-0.171,-0.969]],[[14.177,20.667,-13.402],[0,175.043,-70.08],[0,0,-35.202],[0,0,0],[0,0,0]]]</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f92",
      "challengeType": 5,
      "releasedOn": "September 1, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function QRDecomposition (A) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Quaternion type",
      "description": [
        "<a href=\"https://en.wikipedia.org/wiki/Quaternion\">Quaternions</a>  are an extension of the idea of  <a href=\"http://rosettacode.org/wiki/Arithmetic/Complex\">complex numbers</a>.",
        "A complex number has a real and complex part,  sometimes written as   <code> a + bi, </code>",
        "where   <code> a </code>   and   <code> b </code>   stand for real numbers, and   <code> i </code>   stands for the square root of minus 1.",
        "An example of a complex number might be   <code> -3 + 2i, </code>",
        "where the real part,   <code> a </code>   is   <code> <b>-3.0</b> </code>   and the complex part,   <code> b </code>   is   <code> <b>+2.0</b>. </code>",
        "A quaternion has one real part and <i>three</i> imaginary parts,   <code> i, </code>    <code> j, </code>   and   <code> k. </code>",
        "A quaternion might be written as   <code> a + bi + cj + dk. </code>",
        "In the quaternion numbering system:",
        "<code> i∙i = j∙j = k∙k = i∙j∙k = -1, </code>     or more simply,",
        "<code> ii = jj = kk = ijk  = -1. </code>",
        "The order of multiplication is important, as, in general, for two quaternions:",
        "<code> q<sub>1</sub> </code>   and   <code> q<sub>2</sub>: </code>     <code> q<sub>1</sub>q<sub>2</sub> &ne; q<sub>2</sub>q<sub>1</sub>. </code>",
        "An example of a quaternion might be   <code> 1 +2i +3j +4k </code>",
        "There is a list form of notation where just the numbers are shown and the imaginary multipliers   <code>i, </code>    <code> j, </code>   and   <code> k </code>   are assumed by position.",
        "So the example above would be written as   <code> (1, 2, 3, 4) </code>",
        "Create functions  (or classes)  to perform simple maths with quaternions including computing:",
        "<ol><li>The norm of a quaternion:   <code> $ = \\sqrt{ a^2 + b^2 + c^2 + d^2 } $ </code>  </li>",
        "<li>The negative of a quaternion:   <code> = (-a, -b, -c, -d)</code>  </li>",
        "<li>The conjugate of a quaternion:   <code> = ( a, -b, -c, -d)</code>  </li>",
        "<li>Addition of a real number   <code> r </code>   and   <code> a </code>   quaternion   <code> q: </code>    <code> r + q = q + r = (a+r, b, c, d) </code> </li>",
        "<li>Addition of two quaternions:   <code> q<sub>1</sub> + q<sub>2</sub> = (a<sub>1</sub>+a<sub>2</sub>, b<sub>1</sub>+b<sub>2</sub>, c<sub>1</sub>+c<sub>2</sub>, d<sub>1</sub>+d<sub>2</sub>) </code> </li>",
        "<li>Multiplication of a real number and a quaternion:   <code> qr = rq = (ar, br, cr, dr) </code> </li>",
        "<li>Multiplication of two quaternions   <code> q<sub>1</sub> </code>   and  <code>q<sub>2</sub> </code>   is given by:   <code> ( a<sub>1</sub>a<sub>2</sub> − b<sub>1</sub>b<sub>2</sub> − c<sub>1</sub>c<sub>2</sub> − d<sub>1</sub>d<sub>2</sub>, </code>  <code>  a<sub>1</sub>b<sub>2</sub> + b<sub>1</sub>a<sub>2</sub> + c<sub>1</sub>d<sub>2</sub> − d<sub>1</sub>c<sub>2</sub>, </code>  <code>  a<sub>1</sub>c<sub>2</sub> − b<sub>1</sub>d<sub>2</sub> + c<sub>1</sub>a<sub>2</sub> + d<sub>1</sub>b<sub>2</sub>, </code>  <code>  a<sub>1</sub>d<sub>2</sub> + b<sub>1</sub>c<sub>2</sub> − c<sub>1</sub>b<sub>2</sub> + d<sub>1</sub>a<sub>2</sub> ) </code> </li>",
        "For the sake of this task, we represent a quaternion as an array with 4 elements."
      ],
      "solutions": [
        "function norm (quat) {\n  return Math.round(Math.sqrt(quat.map((x) => x * x).reduce((x, y) => x + y))*1000)/1000;\n}\n\nfunction negate (quat) {\n  return quat.map(x => -x);\n}\n\nfunction conjugate (quat) {\n  return [quat[0]].concat(quat.slice(1).map(x => -x));\n}\n\nfunction add (quat, x) {\n  if (\"number\" === typeof x) {\n    return [quat[0] + x].concat(quat.slice(1));\n  } else {\n    return quat.map((v, i) => v + x[i]);\n  }\n}\n\nfunction mult (quat, r) {\n  if (\"number\" === typeof r) {\n    return quat.map(e => e * r);\n  } else {\n    return [quat[0] * r[0] - quat[1] * r[1] - quat[2] * r[2] - quat[3] * r[3],\n      quat[0] * r[1] + quat[1] * r[0] + quat[2] * r[3] - quat[3] * r[2],\n      quat[0] * r[2] - quat[1] * r[3] + quat[2] * r[0] + quat[3] * r[1],\n      quat[0] * r[3] + quat[1] * r[2] - quat[2] * r[1] + quat[3] * r[0]\n    ];\n  }\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>norm</code> should be a function.'",
          "testString":
            "assert(typeof norm=='function','<code>norm</code> should be a function.');"
        },
        {
          "text": "'<code>norm([1,2,3,4])</code> should return a number.'",
          "testString":
            "assert(typeof norm([1,2,3,4]) == 'number','<code>norm([1,2,3,4])</code> should return a number.');"
        },
        {
          "text":
            "'<code>norm([1,2,3,4])</code> should return <code>5.477</code>.'",
          "testString":
            "assert.equal(norm([1,2,3,4]),5.477,'<code>norm([1,2,3,4])</code> should return <code>5.477</code>.');"
        },
        {
          "text": "'<code>negate</code> should be a function.'",
          "testString":
            "assert(typeof negate=='function','<code>negate</code> should be a function.');"
        },
        {
          "text": "'<code>negate([1,2,3,4])</code> should return a array.'",
          "testString":
            "assert(Array.isArray(negate([1,2,3,4])),'<code>negate([1,2,3,4])</code> should return a array.');"
        },
        {
          "text":
            "'<code>negate([1,2,3,4])</code> should return <code>[-1,-2,-3,-4]</code>.'",
          "testString":
            "assert.deepEqual(negate([1,2,3,4]),[-1,-2,-3,-4],'<code>negate([1,2,3,4])</code> should return <code>[-1,-2,-3,-4]</code>.');"
        },
        {
          "text": "'<code>conjugate</code> should be a function.'",
          "testString":
            "assert(typeof conjugate=='function','<code>conjugate</code> should be a function.');"
        },
        {
          "text": "'<code>conjugate([1,2,3,4])</code> should return a array.'",
          "testString":
            "assert(Array.isArray(conjugate([1,2,3,4])),'<code>conjugate([1,2,3,4])</code> should return a array.');"
        },
        {
          "text":
            "'<code>conjugate([1,2,3,4])</code> should return <code>[1,-2,-3,-4]</code>.'",
          "testString":
            "assert.deepEqual(conjugate([1,2,3,4]),[1,-2,-3,-4],'<code>conjugate([1,2,3,4])</code> should return <code>[1,-2,-3,-4]</code>.');"
        },
        {
          "text": "'<code>add</code> should be a function.'",
          "testString":
            "assert(typeof add=='function','<code>add</code> should be a function.');"
        },
        {
          "text": "'<code>add([1,2,3,4],7)</code> should return a array.'",
          "testString":
            "assert(Array.isArray(add([1,2,3,4],7)),'<code>add([1,2,3,4],7)</code> should return a array.');"
        },
        {
          "text":
            "'<code>add([1,2,3,4],7)</code> should return <code>[8,2,3,4]</code>.'",
          "testString":
            "assert.deepEqual(add([1,2,3,4],7),[8,2,3,4],'<code>add([1,2,3,4],7)</code> should return <code>[8,2,3,4]</code>.');"
        },
        {
          "text": "'<code>add</code> should be a function.'",
          "testString":
            "assert(typeof add=='function','<code>add</code> should be a function.');"
        },
        {
          "text":
            "'<code>add([2,3,4,5],[3,4,5,6])</code> should return a array.'",
          "testString":
            "assert(Array.isArray(add([2,3,4,5],[3,4,5,6])),'<code>add([2,3,4,5],[3,4,5,6])</code> should return a array.');"
        },
        {
          "text":
            "'<code>add([2,3,4,5],[3,4,5,6])</code> should return <code>[5,7,9,11]</code>.'",
          "testString":
            "assert.deepEqual(add([2,3,4,5],[3,4,5,6]),[5,7,9,11],'<code>add([2,3,4,5],[3,4,5,6])</code> should return <code>[5,7,9,11]</code>.');"
        },
        {
          "text": "'<code>mult</code> should be a function.'",
          "testString":
            "assert(typeof mult=='function','<code>mult</code> should be a function.');"
        },
        {
          "text": "'<code>mult([1,2,3,4],7)</code> should return a array.'",
          "testString":
            "assert(Array.isArray(mult([1,2,3,4],7)),'<code>mult([1,2,3,4],7)</code> should return a array.');"
        },
        {
          "text":
            "'<code>mult([1,2,3,4],7)</code> should return <code>[7,14,21,28]</code>.'",
          "testString":
            "assert.deepEqual(mult([1,2,3,4],7),[7,14,21,28],'<code>mult([1,2,3,4],7)</code> should return <code>[7,14,21,28]</code>.');"
        },
        {
          "text": "'<code>mult</code> should be a function.'",
          "testString":
            "assert(typeof mult=='function','<code>mult</code> should be a function.');"
        },
        {
          "text":
            "'<code>mult([2,3,4,5],[3,4,5,6])</code> should return a array.'",
          "testString":
            "assert(Array.isArray(mult([2,3,4,5],[3,4,5,6])),'<code>mult([2,3,4,5],[3,4,5,6])</code> should return a array.');"
        },
        {
          "text":
            "'<code>mult([2,3,4,5],[3,4,5,6])</code> should return <code>[-56,16,24,26]</code>.'",
          "testString":
            "assert.deepEqual(mult([2,3,4,5],[3,4,5,6]),[-56,16,24,26],'<code>mult([2,3,4,5],[3,4,5,6])</code> should return <code>[-56,16,24,26]</code>.');"
        },
        {
          "text": "'<code>mult</code> should be a function.'",
          "testString":
            "assert(typeof mult=='function','<code>mult</code> should be a function.');"
        },
        {
          "text":
            "'<code>mult([3,4,5,6],[2,3,4,5])</code> should return a array.'",
          "testString":
            "assert(Array.isArray(mult([3,4,5,6],[2,3,4,5])),'<code>mult([3,4,5,6],[2,3,4,5])</code> should return a array.');"
        },
        {
          "text":
            "'<code>mult([3,4,5,6],[2,3,4,5])</code> should return <code>[-56,18,20,28]</code>.'",
          "testString":
            "assert.deepEqual(mult([3,4,5,6],[2,3,4,5]),[-56,18,20,28],'<code>mult([3,4,5,6],[2,3,4,5])</code> should return <code>[-56,18,20,28]</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f93",
      "challengeType": 5,
      "releasedOn": "September 1, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function norm (quat) {",
            "  // Good luck!",
            "}",
            "",
            "function negate (quat) {",
            "  // Good luck!",
            "}",
            "",
            "function conjugate (quat) {",
            "  // Good luck!",
            "}",
            "",
            "function add (quat, x) {",
            "  // Good luck!",
            "}",
            "",
            "function mult (quat, r) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Quickselect algorithm",
      "description": [
        "Write a function that takes an array and a number as parameters and returns the position of the number in the sorted array using the <a href=\"https://en.wikipedia.org/wiki/Quickselect\">quickselect algorithm</a>. Note: the position returned should be zero-based."
      ],
      "solutions": [
        "function quickselect (arr, index) {\n  function swap(firstIndex, secondIndex) {\n    var temp = arr[firstIndex];\n    arr[firstIndex] = arr[secondIndex];\n    arr[secondIndex] = temp;\n  }\n\n  function getRandomInt(min, max) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    //The maximum is exclusive and the minimum is inclusive\n    return Math.floor(Math.random() * (max - min)) + min;\n  }\n\n  function partition(from, to) {\n    var pivotIndex = getRandomInt(from, to),\n      pivot = arr[pivotIndex];\n    swap(pivotIndex, to);\n    pivotIndex = from;\n\n    for (var i = from; i <= to; i++) {\n      if (arr[i] < pivot) {\n        swap(pivotIndex, i);\n        pivotIndex++;\n      }\n    }\n    swap(pivotIndex, to);\n\n    return pivotIndex;\n  }\n\n  function quickselectRecursive(from, to, statistic) {\n    var pivotIndex = partition(from, to);\n    if (pivotIndex === statistic) {\n      return arr[pivotIndex];\n    } else if (pivotIndex < statistic) {\n      return quickselectRecursive(pivotIndex, to, statistic);\n    } else if (pivotIndex > statistic) {\n      return quickselectRecursive(from, pivotIndex, statistic);\n    }\n  };\n  return quickselectRecursive(0, arr.length - 1, index)\n}\n"
      ],
      "tests": [
        {
          "text": "'<code>quickselect</code> should be a function.'",
          "testString":
            "assert(typeof quickselect=='function','<code>quickselect</code> should be a function.');"
        },
        {
          "text":
            "'<code>quickselect([9,8,7,6,5,0,1,2,3,4],0)</code> should return a number.'",
          "testString":
            "assert(typeof quickselect([9,8,7,6,5,0,1,2,3,4],0) == 'number','<code>quickselect([9,8,7,6,5,0,1,2,3,4],0)</code> should return a number.');"
        },
        {
          "text":
            "'<code>quickselect([9,8,7,6,5,0,1,2,3,4],0)</code> should return <code>0</code>.'",
          "testString":
            "assert.equal(quickselect([9,8,7,6,5,0,1,2,3,4],0),0,'<code>quickselect([9,8,7,6,5,0,1,2,3,4],0)</code> should return <code>0</code>.');"
        },
        {
          "text":
            "'<code>quickselect([9,8,27,16,5,30,1,2,3,4],1)</code> should return <code>2</code>.'",
          "testString":
            "assert.equal(quickselect([9,8,27,16,5,30,1,2,3,4],1),2,'<code>quickselect([9,8,27,16,5,30,1,2,3,4],1)</code> should return <code>2</code>.');"
        },
        {
          "text":
            "'<code>quickselect([66,57,10,41,82,3,34],2)</code> should return <code>34</code>.'",
          "testString":
            "assert.equal(quickselect([66,57,10,41,82,3,34],2),34,'<code>quickselect([66,57,10,41,82,3,34],2)</code> should return <code>34</code>.');"
        },
        {
          "text":
            "'<code>quickselect([9,58,7,6,5,4],3)</code> should return <code>7</code>.'",
          "testString":
            "assert.equal(quickselect([9,58,7,6,5,4],3),7,'<code>quickselect([9,58,7,6,5,4],3)</code> should return <code>7</code>.');"
        },
        {
          "text":
            "'<code>quickselect([97,68,57,56,5,40,83,94],3)</code> should return <code>57</code>.'",
          "testString":
            "assert.equal(quickselect([97,68,57,56,5,40,83,94],3),57,'<code>quickselect([97,68,57,56,5,40,83,94],3)</code> should return <code>57</code>.');"
        }
      ],
      "id": "5a23c84252665b21eecc7f96",
      "challengeType": 5,
      "releasedOn": "September 1, 2018",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function quickselect (arr, index) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Sailors, coconuts and a monkey problem",
      "description": [
        " <p>",
        "   Five sailors are shipwrecked on an island and",
        "   collect a large pile of coconuts during the day.",
        " </p>",
        " <p>That night the first sailor wakes up and decides",
        "   to take his first share early  so tries to divide the pile of coconuts equally",
        "   into five piles but finds that there is one coconut left over, so he tosses it",
        "   to a monkey and then hides \"his\" one of the five equally sized piles of",
        "   coconuts and pushes the other four piles together to form a single visible pile",
        "   of coconuts again and goes to bed.",
        " </p>",
        " <p>",
        "   To cut a long story short, each of the sailors in",
        "   turn gets up once during the night and performs the same actions of dividing",
        "   the coconut pile into five, finding that one coconut is left over and giving",
        "   that single remainder coconut to the monkey.",
        " </p>",
        " <p>",
        "   In the morning (after the surreptitious and",
        "   separate action of each of the five sailors during the night), the remaining",
        "   coconuts are divided into five equal piles for each of the sailors, whereupon",
        "   it is found that the pile of coconuts divides equally amongst the sailors with",
        "   no remainder. (Nothing for the monkey in the morning.)",
        " </p>",
        "",
        " The task:",
        "",
        "",
        "     Create a function that returns the",
        "     the minimum possible size",
        "     of the initial pile of coconuts collected during the day for N",
        "     sailors.",
        "",
        "",
        " Note:",
        "",
        "",
        "     Of course the tale is told in a",
        "     world where the collection of any amount of coconuts in a day and multiple",
        "     divisions of the pile, etc can occur in time fitting the story line, so as",
        "     not to affect the mathematics.",
        "",
        "",
        "",
        " C.f:",
        "",
        "   <a",
        "       href=\"https://www.youtube.com/watch?v=U9qU20VmvaU\" title=\"link: https://www.youtube.com/watch?v=U9qU20VmvaU\">",
        "       Monkeys and Coconuts - Numberphile</a> (Video) Analytical solution.",
        "",
        "",
        "     <a",
        "       href=\"http://oeis.org/A002021\" title=\"link: http://oeis.org/A002021\">A002021 Pile of coconuts problem</a> The On-Line",
        "     Encyclopedia of Integer Sequences. (Although some of its references may use",
        "     the alternate form of the tale).",
        "",
        "",
        ""
      ],
      "solutions": [
        "// noprotect\nfunction splitCoconuts(intSailors) {\n  let intNuts = intSailors;\n  let result = splitCoconutsHelper(intNuts, intSailors);\n  while (!result) {\n    intNuts += 1;\n    result = splitCoconutsHelper(intNuts, intSailors);\n  }\n\n  return intNuts;\n}\n\nfunction splitCoconutsHelper(intNuts, intSailors, intDepth) {\n  const nDepth = intDepth !== undefined ? intDepth : intSailors;\n  const portion = Math.floor(intNuts / intSailors);\n  const remain = intNuts % intSailors;\n\n  if (portion <= 0 || remain !== (nDepth ? 1 : 0)) {\n    return null;\n  }\n\n  if (nDepth) {\n    return splitCoconutsHelper(\n      intNuts - portion - remain, intSailors, nDepth - 1\n    );\n  }\n\n  return intNuts;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>splitCoconuts</code> is a function.",
          "testString":
            "assert(typeof splitCoconuts === 'function', '<code>splitCoconuts</code> is a function.');"
        },
        {
          "text": "<code>splitCoconuts(5)</code> should return 3121.",
          "testString":
            "assert(splitCoconuts(5) === 3121, '<code>splitCoconuts(5)</code> should return 3121.');"
        },
        {
          "text": "<code>splitCoconuts(6)</code> should return 233275.",
          "testString":
            "assert(splitCoconuts(6) === 233275, '<code>splitCoconuts(6)</code> should return 233275.');"
        },
        {
          "text": "<code>splitCoconuts(7)</code> should return 823537.",
          "testString":
            "assert(splitCoconuts(7) === 823537, '<code>splitCoconuts(7)</code> should return 823537.');"
        }
      ],
      "id": "59da22823d04c95919d46269",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "// noprotect",
            "function splitCoconuts(intSailors) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "SEDOLs",
      "null": [],
      "description": [
        "    Task:",
        "",
        "  <p>",
        "    For each number list of 6-digit ",
        "    <a href=\"https://en.wikipedia.org/wiki/SEDOL\" title=\"wp: SEDOL\">SEDOL</a>s,",
        "    calculate and append the checksum digit.",
        "  </p>",
        "",
        "  <p>",
        "    That is, given the input string on the left, your function should return the",
        "    corresponding string on the right:",
        "  </p>",
        "",
        "    <pre>",
        "     710889 => 7108899",
        "     B0YBKJ => B0YBKJ7",
        "     406566 => 4065663",
        "     B0YBLH => B0YBLH2",
        "     228276 => 2282765",
        "     B0YBKL => B0YBKL9",
        "     557910 => 5579107",
        "     B0YBKR => B0YBKR5",
        "     585284 => 5852842",
        "     B0YBKT => B0YBKT7",
        "     B00030 => B000300",
        "    </pre>",
        "",
        "  <p>",
        "    Check also that each input is correctly formed, especially",
        "    with respect to valid characters allowed in a SEDOL string. Your function",
        "    should return <code>null</code> on invalid input.",
        "  </p>"
      ],
      "solutions": [
        "function sedol(input) {\n  const checkDigit = sedolCheckDigit(input);\n  if (checkDigit !== null) {\n    return input + checkDigit;\n  }\n  return null;\n}\n\nconst weight = [1, 3, 1, 7, 3, 9, 1];\nfunction sedolCheckDigit(char6) {\n  if (char6.search(/^[0-9BCDFGHJKLMNPQRSTVWXYZ]{6}$/) === -1) {\n    return null;\n  }\n\n  let sum = 0;\n  for (let i = 0; i < char6.length; i++) {\n    sum += weight[i] * parseInt(char6.charAt(i), 36);\n  }\n  const check = (10 - (sum % 10)) % 10;\n  return check.toString();\n}\n"
      ],
      "tests": [
        {
          "text": "<code>sedol</code> is a function.",
          "testString":
            "assert(typeof sedol === 'function', '<code>sedol</code> is a function.');"
        },
        {
          "text": "<code>sedol('a')</code> should return null.\")",
          "testString":
            "assert(sedol('a') === null, \"<code>sedol('a')</code> should return null.\");"
        },
        {
          "text": "<code>sedol('710889')</code> should return '7108899'.\")",
          "testString":
            "assert(sedol('710889') === '7108899', \"<code>sedol('710889')</code> should return '7108899'.\");"
        },
        {
          "text": "<code>sedol('BOATER')</code> should return null.\")",
          "testString":
            "assert(sedol('BOATER') === null, \"<code>sedol('BOATER')</code> should return null.\");"
        },
        {
          "text": "<code>sedol('228276')</code> should return '2282765'.\")",
          "testString":
            "assert(sedol('228276') === '2282765', \"<code>sedol('228276')</code> should return '2282765'.\");"
        }
      ],
      "id": "59d9c6bc214c613ba73ff012",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function sedol (input) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "S-Expressions",
      "description": [
        "<p>",
        "<a href=\"https://en.wikipedia.org/wiki/S-Expression\" title=\"wp: S-Expression\">S-Expressions</a> are one convenient way to parse and store data.",
        "</p>",
        "Task:",
        "<p>",
        "    Write a simple reader/parser for S-Expressions that handles quoted and unquoted strings, integers and floats.",
        "</p>",
        "<p>",
        "The function should read a single but nested S-Expression from a string and",
        "return it as a (nested) array.",
        "</p>",
        "<p>",
        "    Newlines and other whitespace may be ignored unless contained within a quoted string.",
        "</p>",
        "<p>“<tt>()</tt>”  inside quoted strings are not interpreted, but treated as part of the string.",
        "</p>",
        "<p>",
        "Handling escaped quotes inside a string is optional;  thus “<tt>(foo\"bar)</tt>” maybe treated as a string “<tt>foo\"bar</tt>”, or as an error.",
        "</p>",
        "<p>",
        "For this, the reader need not recognize “<tt>\\</tt>” for escaping, but should, in addition, recognize numbers if the language has appropriate datatypes.",
        "</p>",
        "<p>",
        "Note that with the exception of “<tt>()\"</tt>” (“<tt>\\</tt>” if escaping is supported) and whitespace there are no special characters. Anything else is allowed without quotes.",
        "</p>",
        "<p>The reader should be able to read the following input</p>",
        "<p>",
        "<pre>",
        "    ((data \"quoted data\" 123 4.5)",
        "    (data (!@# (4.5) \"(more\" \"data)\")))",
        "</pre>",
        "</p>",
        "<p>",
        "and turn it into a native datastructure. (see the",
        "<a href=\"http://rosettacode.org/wiki/#Pike\" title=\"#Pike\">Pike</a>, ",
        "<a href=\"http://rosettacode.org/wiki/#Python\" title=\"#Python\">Python</a> and",
        "<a href=\"http://rosettacode.org/wiki/#Ruby\" title=\"#Ruby\">Ruby</a> implementations",
        "for examples of native data structures.)",
        "</p>"
      ],
      "solutions": [
        "function parseSexpr(str) {\n  const t = str.match(/\\s*(\"[^\"]*\"|\\(|\\)|\"|[^\\s()\"]+)/g);\n  for (var o, c = 0, i = t.length - 1; i >= 0; i--) {\n    var n,\n      ti = t[i].trim();\n    if (ti == '\"') return;\n    else if (ti == '(') t[i] = '[', c += 1;\n    else if (ti == ')') t[i] = ']', c -= 1;\n    else if ((n = +ti) == ti) t[i] = n;\n    else t[i] = `'${ti.replace('\\'', '\\\\\\'')}'`;\n    if (i > 0 && ti != ']' && t[i - 1].trim() != '(') t.splice(i, 0, ',');\n    if (!c) if (!o) o = true; else return;\n  }\n  return c ? undefined : eval(t.join(''));\n}\n"
      ],
      "tests": [
        {
          "text": "<code>parseSexpr</code> is a function.",
          "testString":
            "assert(typeof parseSexpr === 'function', '<code>parseSexpr</code> is a function.');"
        },
        {
          "text":
            "<code>parseSexpr('(data1 data2 data3)')</code> should return ['data1', 'data2', 'data3']\")",
          "testString":
            "assert.deepEqual(parseSexpr(simpleSExpr), simpleSolution, \"<code>parseSexpr('(data1 data2 data3)')</code> should return ['data1', 'data2', 'data3']\");"
        },
        {
          "text":
            "<code>parseSexpr('(data1 data2 data3)')</code> should return an array with 3 elements\")",
          "testString":
            "assert.deepEqual(parseSexpr(basicSExpr), basicSolution, \"<code>parseSexpr('(data1 data2 data3)')</code> should return an array with 3 elements\");"
        }
      ],
      "id": "59667989bf71cf555dd5d2ff",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function parseSexpr(str) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const simpleSExpr = '(data1 data2 data3)';",
            "const simpleSolution = ['data1', 'data2', 'data3'];",
            "",
            "const basicSExpr = '((data \"quoted data\" 123 4.5) (data (!@# (4.5) \"(more\" \"data)\")))';",
            "const basicSolution = [[\"data\",\"\\\"quoted data\\\"\",123,4.5],[\"data\",[\"!@#\",[4.5],\"\\\"(more\\\"\",\"\\\"data)\\\"\"]]];"
          ]
        }
      }
    },
    {
      "title": "Taxicab numbers",
      "description": [
        "A &nbsp; <a href=\"https://en.wikipedia.org/wiki/Hardy–Ramanujan number\" title=\"wp: Hardy–Ramanujan number\">taxicab number</a>",
        "&nbsp; (the definition that is being used here) &nbsp; is a positive integer that can be expressed as the sum of two positive cubes in more than one way.",
        "The first taxicab number is &nbsp; 1729, &nbsp; which is:",
        "1<sup>3</sup> &nbsp; + &nbsp; 12<sup>3</sup> &nbsp; &nbsp; &nbsp; and",
        "9<sup>3</sup> &nbsp; + &nbsp; 10<sup>3</sup>.",
        "Taxicab numbers are also known as:",
        "  * &nbsp; taxi numbers",
        "  * &nbsp; taxi-cab numbers",
        "  * &nbsp; taxi cab numbers",
        "  * &nbsp; Hardy-Ramanujan numbers",
        "Task:",
        "Write a function that returns the lowest N taxicab numbers.",
        "For each of the taxicab numbers, show the number as well as it's constituent cubes.",
        "See also:",
        "[http://oeis.org/A001235 A001235 taxicab numbers] on The On-Line Encyclopedia of Integer Sequences.",
        "  <a href=\"http://mathworld.wolfram.com/Hardy-RamanujanNumber.html\">Hardy-Ramanujan Number</a> on MathWorld.",
        "  <a href=\"http://mathworld.wolfram.com/TaxicabNumber.html\">taxicab number</a> on MathWorld.",
        "  <a href=\"https://en.wikipedia.org/wiki/Taxicab_number\">taxicab number</a> on Wikipedia."
      ],
      "solutions": [
        "function taxicabNumbers(nNumbers) {\n  const cubeN = [];\n  const s3s = {};\n\n  const e = 100;\n  for (let n = 1; n < e; n += 1) {\n    cubeN[n] = n * n * n;\n  }\n\n  for (let a = 1; a < e - 1; a += 1) {\n    const a3 = cubeN[a];\n    for (let b = a; b < e; b += 1) {\n      const b3 = cubeN[b];\n      const s3 = a3 + b3;\n\n      let abs = s3s[s3];\n      if (!abs) {\n        s3s[s3] = abs = [];\n      }\n      abs.push([a, b]);\n    }\n  }\n\n  let i = 0;\n  const res = [];\n  Object.keys(s3s).forEach(s3 => {\n    const abs = s3s[s3];\n    if (abs.length >= 2) { // No two cube pairs found\n      i += 1;\n      if (i <= nNumbers) {\n        res.push(s3);\n      }\n    }\n  });\n  return res.map(item => parseInt(item, 10));\n}\n"
      ],
      "tests": [
        {
          "text": "<code>taxicabNumbers </code> is a function.",
          "testString":
            "assert(typeof taxicabNumbers === 'function', '<code>taxicabNumbers </code> is a function.');"
        },
        {
          "text": "<code>taxicabNumbers </code> should return an array.",
          "testString":
            "assert(typeof taxicabNumbers(2) === 'object', '<code>taxicabNumbers </code> should return an array.');"
        },
        {
          "text":
            "<code>taxicabNumbers </code> should return an array of numbers.",
          "testString":
            "assert(typeof taxicabNumbers(100)[0] === 'number', '<code>taxicabNumbers </code> should return an array of numbers.');"
        },
        {
          "text":
            "<code>taxicabNumbers(4) </code> must return [1729, 4104, 13832, 20683].",
          "testString":
            "assert.deepEqual(taxicabNumbers(4), res4, '<code>taxicabNumbers(4) </code> must return [1729, 4104, 13832, 20683].');"
        },
        {
          "text":
            "taxicabNumbers(25) should return [1729, 4104, 13832, 20683, 32832, 39312, 40033, 46683, 64232, 65728, 110656, 110808, 134379, 149389, 165464, 171288, 195841, 216027, 216125, 262656, 314496, 320264, 327763, 373464, 402597]",
          "testString":
            "assert.deepEqual(taxicabNumbers(25), res25, 'taxicabNumbers(25) should return [1729, 4104, 13832, 20683, 32832, 39312, 40033, 46683, 64232, 65728, 110656, 110808, 134379, 149389, 165464, 171288, 195841, 216027, 216125, 262656, 314496, 320264, 327763, 373464, 402597]');"
        },
        {
          "text":
            "taxicabNumbers(39) resulting numbers from 20 - 29 should be [314496,320264,327763,373464,402597,439101,443889,513000,513856].",
          "testString":
            "assert.deepEqual(taxicabNumbers(39).slice(20, 29), res39From20To29, 'taxicabNumbers(39) resulting numbers from 20 - 29 should be [314496,320264,327763,373464,402597,439101,443889,513000,513856].');"
        }
      ],
      "id": "594ecc0d9a8cf816e3340187",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function taxicabNumbers (n) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const res4 = [1729, 4104, 13832, 20683];",
            "const res25 = [",
            "  1729, 4104, 13832, 20683, 32832, 39312, 40033, 46683, 64232, 65728, 110656,",
            "  110808, 134379, 149389, 165464, 171288, 195841, 216027, 216125, 262656, 314496, 320264, 327763,",
            "  373464, 402597",
            "];",
            "",
            "const res39From20To29 = [314496, 320264, 327763, 373464, 402597, 439101, 443889, 513000, 513856];"
          ]
        }
      }
    },
    {
      "title": "Tokenize a string with escaping",
      "description": [
        "<p>",
        "Write a function or program that can split a string at each non-escaped occurrence of a separator character.",
        "</p>",
        "<p>",
        "It should accept three input parameters:",
        "</p>",
        "  The <b>string</b>",
        "  The <b>separator character</b>",
        "  The <b>escape character</b>",
        "<p>It should output a list of strings.</p>",
        "<p>Rules for splitting:</p>",
        "  The fields that were separated by the separators, become the elements of the output list.",
        "  Empty fields should be preserved, even at the start and end.",
        "<p>Rules for escaping:</p>",
        "  \"Escaped\" means preceded by an occurrence of the escape character that is not already escaped itself.",
        "  When the escape character precedes a character that has no special meaning, it still counts as an escape (but does not do anything special).",
        "  Each occurrences of the escape character that was used to escape something, should not become part of the output.",
        "<p>Demonstrate that your function satisfies the following test-case:",
        "  Given string <pre>one^|uno||three^^^^|four^^^|^cuatro|</pre> and using",
        "  <pre>|</pre> as a separator and <pre>^</pre> as escape character, your",
        "  function should output the following array:",
        "</p>",
        "  <pre>",
        "  ['one|uno', '', 'three^^', 'four^|quatro', '']",
        "  </pre>"
      ],
      "solutions": [
        "// tokenize :: String -> Character -> Character -> [String]\nfunction tokenize(str, charDelim, charEsc) {\n  const dctParse = str.split('')\n    .reduce((a, x) => {\n      const blnEsc = a.esc;\n      const blnBreak = !blnEsc && x === charDelim;\n      const blnEscChar = !blnEsc && x === charEsc;\n\n      return {\n        esc: blnEscChar,\n        token: blnBreak ? '' : (\n          a.token + (blnEscChar ? '' : x)\n        ),\n        list: a.list.concat(blnBreak ? a.token : [])\n      };\n    }, {\n      esc: false,\n      token: '',\n      list: []\n    });\n\n  return dctParse.list.concat(\n    dctParse.token\n  );\n}\n"
      ],
      "tests": [
        {
          "text": "<code>tokenize</code> is a function.",
          "testString":
            "assert(typeof tokenize === 'function', '<code>tokenize</code> is a function.');"
        },
        {
          "text": "<code>tokenize</code> should return an array.",
          "testString":
            "assert(typeof tokenize('a', 'b', 'c') === 'object', '<code>tokenize</code> should return an array.');"
        },
        {
          "text":
            "<code>tokenize('one^|uno||three^^^^|four^^^|^cuatro|', '|', '^') </code> should return ['one|uno', '', 'three^^', 'four^|cuatro', '']\")",
          "testString":
            "assert.deepEqual(tokenize(testStr1, '|', '^'), res1, \"<code>tokenize('one^|uno||three^^^^|four^^^|^cuatro|', '|', '^') </code> should return ['one|uno', '', 'three^^', 'four^|cuatro', '']\");"
        },
        {
          "text":
            "<code>tokenize('a@&bcd&ef&&@@hi', '&', '@')</code> should return <code>['a&bcd', 'ef', '', '@hi']</code>",
          "testString":
            "assert.deepEqual(tokenize(testStr2, '&', '@'), res2, '<code>tokenize(\"a@&bcd&ef&&@@hi\", \"&\", \"@\")</code> should return <code>[\"a&bcd\", \"ef\", \"\", \"@hi\"]</code>');"
        }
      ],
      "id": "594faaab4e2a8626833e9c3d",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function tokenize(str, esc, sep) {",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const testStr1 = 'one^|uno||three^^^^|four^^^|^cuatro|';",
            "const res1 = ['one|uno', '', 'three^^', 'four^|cuatro', ''];",
            "",
            "// TODO add more tests",
            "const testStr2 = 'a@&bcd&ef&&@@hi';",
            "const res2 = ['a&bcd', 'ef', '', '@hi'];"
          ]
        }
      }
    },
    {
      "title": "Topological sort",
      "description": [
        "<p>",
        "Given a mapping between items, and items they depend on, a ",
        "<a href=\"https://en.wikipedia.org/wiki/Topological sorting\" title=\"wp: Topological sorting\">topological sort</a> orders ",
        "items so that no item precedes an item it depends upon.",
        "</p>",
        "<p>",
        "The compiling of a library in the ",
        "<a href=\"https://en.wikipedia.org/wiki/VHDL\" title=\"wp: VHDL\">VHDL</a> language",
        "has the constraint that a library must be compiled after any library it depends on.",
        "</p>",
        "Task:",
        "<p>",
        "Write a function that will return a valid compile order of VHDL libraries from their dependencies.",
        "</p>",
        "  Assume library names are single words. ",
        "  Items mentioned as only dependents have no dependents of their own, but their order of compiling must be given.",
        "  Any self dependencies should be ignored. ",
        "  Any un-orderable dependencies should be ignored.",
        "<p>Use the following data as an example:</p>",
        "<pre>",
        "LIBRARY          LIBRARY DEPENDENCIES",
        "=======          ====================",
        "des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee",
        "dw01             ieee dw01 dware gtech",
        "dw02             ieee dw02 dware",
        "dw03             std synopsys dware dw03 dw02 dw01 ieee gtech",
        "dw04             dw04 ieee dw01 dware gtech",
        "dw05             dw05 ieee dware",
        "dw06             dw06 ieee dware",
        "dw07             ieee dware",
        "dware            ieee dware",
        "gtech            ieee gtech",
        "ramlib           std ieee",
        "std_cell_lib     ieee std_cell_lib",
        "synopsys",
        "</pre>",
        "<p>",
        "<small>Note: the above data would be un-orderable if, for example, <code>dw04</code> is added to the list of dependencies of <code>dw01</code>.</small>",
        "</p>",
        "C.f.:",
        "",
        "    <a href=\"http://rosettacode.org/wiki/Topological sort/Extracted top item\" title=\"Topological sort/Extracted top item\">Topological sort/Extracted top item</a>.",
        "",
        "<p>There are two popular algorithms for topological sorting:</p>",
        "<p>",
        "  Kahn's 1962 topological sort, and depth-first search:",
        "  <a href=\"https://en.wikipedia.org/wiki/Topological sorting\" title=\"wp: Topological sorting\">topological sort</a>",
        "</p>",
        "<p>",
        "  Jason Sachs:",
        "  <a href=\"http://www.embeddedrelated.com/showarticle/799.php\" title=\"link: http://www.embeddedrelated.com/showarticle/799.php\">",
        "  \"Ten little algorithms, part 4: topological sort\"",
        "  </a>.",
        "</p>"
      ],
      "solutions": [
        "function topologicalSort(libs) {\n  // A map of the input data, with the keys as the packages, and the values as\n  // and array of packages on which it depends.\n  const D = libs\n    .split('\\n')\n    .map(e => e.split(' ').filter(ep => ep !== ''))\n    .reduce((p, c) =>\n      p.set(c[0], c.filter((e, i) => (i > 0 && e !== c[0] ? e : null))), new Map());\n  [].concat(...D.values()).forEach(e => {\n    D.set(e, D.get(e) || []);\n  });\n\n  // The above map rotated so that it represents a DAG of the form\n  // Map {\n  //    A => [ A, B, C],\n  //    B => [C],\n  //    C => []\n  // }\n  // where each key represents a node, and the array contains the edges.\n  const G = [...D.keys()].reduce((p, c) =>\n    p.set(\n      c,\n      [...D.keys()].filter(e => D.get(e).includes(c))),\n    new Map()\n  );\n\n  // An array of leaf nodes; nodes with 0 in degrees.\n  const Q = [...D.keys()].filter(e => D.get(e).length === 0);\n\n  // The result array.\n  const S = [];\n  while (Q.length) {\n    const u = Q.pop();\n    S.push(u);\n    G.get(u).forEach(v => {\n      D.set(v, D.get(v).filter(e => e !== u));\n      if (D.get(v).length === 0) {\n        Q.push(v);\n      }\n    });\n  }\n\n  return S;\n}\n"
      ],
      "tests": [
        {
          "text": "<code>topologicalSort</code> is a function.",
          "testString":
            "assert(typeof topologicalSort === 'function', '<code>topologicalSort</code> is a function.');"
        },
        {
          "text":
            "<code>topologicalSort</code> must return correct library order..",
          "testString":
            "assert.deepEqual(topologicalSort(libsSimple), ['bbb', 'aaa'], '<code>topologicalSort</code> must return correct library order..');"
        },
        {
          "text":
            "<code>topologicalSort</code> must return correct library order..",
          "testString":
            "assert.deepEqual(topologicalSort(libsVHDL), solutionVHDL, '<code>topologicalSort</code> must return correct library order..');"
        },
        {
          "text":
            "<code>topologicalSort</code> must return correct library order..",
          "testString":
            "assert.deepEqual(topologicalSort(libsCustom), solutionCustom, '<code>topologicalSort</code> must return correct library order..');"
        },
        {
          "text":
            "<code>topologicalSort</code> must ignore unorderable dependencies..",
          "testString":
            "assert.deepEqual(topologicalSort(libsUnorderable), solutionUnorderable, '<code>topologicalSort</code> must ignore unorderable dependencies..');"
        }
      ],
      "id": "594fa2746886f41f7d8bf225",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function topologicalSort(libs) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const libsSimple =",
            "  `aaa bbb",
            "  bbb`;",
            "",
            "const libsVHDL =",
            "  `des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee",
            "  dw01             ieee dw01 dware gtech",
            "  dw02             ieee dw02 dware",
            "  dw03             std synopsys dware dw03 dw02 dw01 ieee gtech",
            "  dw04             dw04 ieee dw01 dware gtech",
            "  dw05             dw05 ieee dware",
            "  dw06             dw06 ieee dware",
            "  dw07             ieee dware",
            "  dware            ieee dware",
            "  gtech            ieee gtech",
            "  ramlib           std ieee",
            "  std_cell_lib     ieee std_cell_lib",
            "  synopsys`;",
            "",
            "const solutionVHDL = [",
            "  'ieee', 'std_cell_lib', 'gtech', 'dware', 'dw07', 'dw06',",
            "  'dw05', 'dw02', 'dw01', 'dw04', 'std', 'ramlib', 'synopsys',",
            "  'dw03', 'des_system_lib'",
            "];",
            "",
            "const libsCustom =",
            "  `a b c d",
            "  b c d",
            "  d c",
            "  c base",
            "  base`;",
            "const solutionCustom = ['base', 'c', 'd', 'b', 'a'];",
            "",
            "const libsUnorderable =",
            "  `TestLib Base MainLib",
            "  MainLib TestLib",
            "  Base`;",
            "",
            "const solutionUnorderable = ['Base'];"
          ]
        }
      }
    },
    {
      "title": "Top rank per group",
      "description": [
        "Task:",
        "<p>Find the top N ranked data in each group, where N  is provided as a parameter. Name of the rank and the group are also provided as parameter.</p>",
        "Given the following data:",
        "<pre>",
        "[",
        "  { name: 'Tyler Bennett', id: 'E10297', salary: 32000, dept: 'D101' },",
        "  { name: 'John Rappl', id: 'E21437', salary: 47000, dept: 'D050' },",
        "  { name: 'George Woltman', id: 'E00127', salary: 53500, dept: 'D101' },",
        "  { name: 'Adam Smith', id: 'E63535', salary: 18000, dept: 'D202' },",
        "  { name: 'Claire Buckman', id: 'E39876', salary: 27800, dept: 'D202' },",
        "  { name: 'David McClellan', id: 'E04242', salary: 41500, dept: 'D101' },",
        "  { name: 'Rich Holcomb', id: 'E01234', salary: 49500, dept: 'D202' },",
        "  { name: 'Nathan Adams', id: 'E41298', salary: 21900, dept: 'D050' },",
        "  { name: 'Richard Potter', id: 'E43128', salary: 15900, dept: 'D101' },",
        "  { name: 'David Motsinger', id: 'E27002', salary: 19250, dept: 'D202' },",
        "  { name: 'Tim Sampair', id: 'E03033', salary: 27000, dept: 'D101' },",
        "  { name: 'Kim Arlich', id: 'E10001', salary: 57000, dept: 'D190' },",
        "  { name: 'Timothy Grove', id: 'E16398', salary: 29900, dept: 'D190' }",
        "];",
        "</pre>",
        "one could rank top 10 employees in each department by calling",
        "<code>topRankPerGroup(10, data, 'dept', 'salary')</code>",
        "Given the following data:",
        "<pre>",
        "[",
        "  { name: 'Friday 13th', genre: 'horror', rating: 9.9 },",
        "  { name: \"Nightmare on Elm's Street\", genre: 'horror', rating: 5.7 },",
        "  { name: 'Titanic', genre: 'drama', rating: 7.3 },",
        "  { name: 'Maze Runner', genre: 'scifi', rating: 7.1 },",
        "  { name: 'Blade runner', genre: 'scifi', rating: 8.9 }",
        "];",
        "</pre>",
        "one could rank the top-rated movie in each genre by calling",
        "<code>topRankPerGroup(1, data, 'genre', 'rating')</code>"
      ],
      "solutions": [
        "const collectDept = function (arrOfObj, groupName) {\n  const collect = arrOfObj.reduce((rtnObj, obj) => {\n    if (rtnObj[obj[groupName]] === undefined) {\n      rtnObj[obj[groupName]] = [];\n    }\n    rtnObj[obj[groupName]].push(obj);\n    return rtnObj;\n  }, {} // initial value to reduce\n  );\n\n  return Object.keys(collect).sort().map(key => collect[key]);\n};\n\nconst sortRank = function (arrOfRankArrs, rankName) {\n  return arrOfRankArrs.map(item => item.sort((a, b) => {\n    if (a[rankName] > b[rankName]) { return -1; }\n    if (a[rankName] < b[rankName]) { return 1; }\n    return 0;\n  }));\n};\n\nfunction topRankPerGroup(n, data, groupName, rankName) {\n  if (n < 0) { return; }\n  return sortRank(collectDept(data, groupName),\n    rankName).map(list => list.slice(0, n));\n}\n"
      ],
      "tests": [
        {
          "text": "<code>topRankPerGroup</code> is a function.",
          "testString":
            "assert(typeof topRankPerGroup === 'function', '<code>topRankPerGroup</code> is a function.');"
        },
        {
          "text":
            "<code>topRankPerGroup</code> returns undefined on negative n values.",
          "testString":
            "assert(typeof topRankPerGroup(-1, []) === 'undefined', '<code>topRankPerGroup</code> returns undefined on negative n values.');"
        },
        {
          "text": "First department must be D050",
          "testString":
            "assert.equal(res1[0][0].dept, 'D050', 'First department must be D050');"
        },
        {
          "text": "First department must be D050",
          "testString":
            "assert.equal(res1[0][1].salary, 21900, 'First department must be D050');"
        },
        {
          "text": "The last department must be D202",
          "testString":
            "assert.equal(res1[3][3].dept, 'D202', 'The last department must be D202');"
        },
        {
          "text":
            "<code>topRankPerGroup(1, ...)</code> must return only top ranking result per group.",
          "testString":
            "assert.equal(res2[2].length, 1, '<code>topRankPerGroup(1, ...)</code> must return only top ranking result per group.');"
        },
        {
          "text":
            "<code>topRankPerGroup(1, ...)</code> must return only top ranking result per group.",
          "testString":
            "assert.equal(res3[2][1].name, 'Maze Runner', '<code>topRankPerGroup(1, ...)</code> must return only top ranking result per group.');"
        }
      ],
      "id": "595011cba5a81735713873bd",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function topRankPerGroup(n, data, groupName, rankName) {",
            "  // Good luck!",
            "  return true;",
            "}"
          ],
          "head": [],
          "tail": [
            "const testData1 = [",
            "  { name: 'Tyler Bennett', id: 'E10297', salary: 32000, dept: 'D101' },",
            "  { name: 'John Rappl', id: 'E21437', salary: 47000, dept: 'D050' },",
            "  { name: 'George Woltman', id: 'E00127', salary: 53500, dept: 'D101' },",
            "  { name: 'Adam Smith', id: 'E63535', salary: 18000, dept: 'D202' },",
            "  { name: 'Claire Buckman', id: 'E39876', salary: 27800, dept: 'D202' },",
            "  { name: 'David McClellan', id: 'E04242', salary: 41500, dept: 'D101' },",
            "  { name: 'Rich Holcomb', id: 'E01234', salary: 49500, dept: 'D202' },",
            "  { name: 'Nathan Adams', id: 'E41298', salary: 21900, dept: 'D050' },",
            "  { name: 'Richard Potter', id: 'E43128', salary: 15900, dept: 'D101' },",
            "  { name: 'David Motsinger', id: 'E27002', salary: 19250, dept: 'D202' },",
            "  { name: 'Tim Sampair', id: 'E03033', salary: 27000, dept: 'D101' },",
            "  { name: 'Kim Arlich', id: 'E10001', salary: 57000, dept: 'D190' },",
            "  { name: 'Timothy Grove', id: 'E16398', salary: 29900, dept: 'D190' }",
            "];",
            "",
            "const res1 = topRankPerGroup(10, testData1, 'dept', 'salary');",
            "",
            "const testData2 = [",
            "  { name: 'Friday 13th', genre: 'horror', rating: 9.9 },",
            "  { name: \"Nightmare on Elm's Street\", genre: 'horror', rating: 5.7 },",
            "  { name: 'Titanic', genre: 'drama', rating: 7.3 },",
            "  { name: 'Maze Runner', genre: 'scifi', rating: 7.1 },",
            "  { name: 'Blade runner', genre: 'scifi', rating: 8.9 }",
            "];",
            "",
            "const res2 = topRankPerGroup(1, testData2, 'genre', 'rating');",
            "const res3 = topRankPerGroup(2, testData2, 'genre', 'rating');",
            "",
            "//console.log(JSON.stringify(topRankPerGroup(10, testData1)));"
          ]
        }
      }
    },
    {
      "title": "Towers of Hanoi",
      "description": [
        "    Task:",
        "<p>Solve the <a href=\"https://en.wikipedia.org/wiki/Towers_of_Hanoi\" title=\"wp: Towers_of_Hanoi\">Towers of Hanoi</a>  problem.</p>",
        "<p>",
        "Your solution should accept the number of discs as the first parameters, and",
        "three string used to identify each of the three stacks of discs, for example",
        "<code>towerOfHanoi(4, 'A', 'B', 'C')</code>. The function should return an",
        "array of arrays containing the list of moves, source -> destination. For",
        "example, the array <code>[['A', 'C'], ['B', 'A']]</code> indicates that the",
        "1st move was to move a disc from stack A to C, and the 2nd move was to move a",
        "disc from stack B to A.",
        "</p>"
      ],
      "solutions": [
        "function towerOfHanoi(n, a, b, c) {\n  const res = [];\n  towerOfHanoiHelper(n, a, c, b, res);\n  return res;\n}\n\nfunction towerOfHanoiHelper(n, a, b, c, res) {\n  if (n > 0) {\n    towerOfHanoiHelper(n - 1, a, c, b, res);\n    res.push([a, c]);\n    towerOfHanoiHelper(n - 1, b, a, c, res);\n  }\n}\n"
      ],
      "tests": [
        {
          "text": "<code>towerOfHanoi</code> is a function.",
          "testString":
            "assert(typeof towerOfHanoi === 'function', '<code>towerOfHanoi</code> is a function.');"
        },
        {
          "text": "<code>towerOfHanoi(3, ...)</code> should return 7 moves.",
          "testString":
            "assert(res3.length === 7, '<code>towerOfHanoi(3, ...)</code> should return 7 moves.');"
        },
        {
          "text":
            "<code>towerOfHanoi(3, 'A', 'B', 'C')</code> should return [['A','B'],['A','C'],['B','C'],['A','B'],['C','A'],['C','B'],['A','B']].\")",
          "testString":
            "assert.deepEqual(towerOfHanoi(3, 'A', 'B', 'C'), res3Moves, \"<code>towerOfHanoi(3, 'A', 'B', 'C')</code> should return [['A','B'],['A','C'],['B','C'],['A','B'],['C','A'],['C','B'],['A','B']].\");"
        },
        {
          "text":
            "<code>towerOfHanoi(5, \"X\", \"Y\", \"Z\")</code> 10th move should be Y -> X.",
          "testString":
            "assert.deepEqual(res5[9], ['Y', 'X'], '<code>towerOfHanoi(5, \"X\", \"Y\", \"Z\")</code> 10th move should be Y -> X.');"
        },
        {
          "text":
            "<code>towerOfHanoi(7, 'A', 'B', 'C')</code> first ten moves are [['A','B'],['A','C'],['B','C'],['A','B'],['C','A'],['C','B'],['A','B'],['A','C'],['B','C'],['B','A']].\")",
          "testString":
            "assert.deepEqual(towerOfHanoi(7, 'A', 'B', 'C').slice(0, 10), res7First10Moves, \"<code>towerOfHanoi(7, 'A', 'B', 'C')</code> first ten moves are [['A','B'],['A','C'],['B','C'],['A','B'],['C','A'],['C','B'],['A','B'],['A','C'],['B','C'],['B','A']].\");"
        }
      ],
      "id": "5951ed8945deab770972ae56",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function towerOfHanoi (n, a, b, c) {",
            "  // Good luck!",
            "  return [[]];",
            "}"
          ],
          "head": [],
          "tail": [
            "const res3 = towerOfHanoi(3, 'A', 'B', 'C');",
            "const res3Moves = [['A', 'B'], ['A', 'C'], ['B', 'C'], ['A', 'B'], ['C', 'A'], ['C', 'B'], ['A', 'B']];",
            "const res5 = towerOfHanoi(5, 'X', 'Y', 'Z');",
            "const res7First10Moves = [['A', 'B'], ['A', 'C'], ['B', 'C'], ['A', 'B'], ['C', 'A'], ['C', 'B'], ['A', 'B'], ['A', 'C'], ['B', 'C'], ['B', 'A']];"
          ]
        }
      }
    },
    {
      "title": "Vector cross product",
      "description": [
        "A vector is defined as having three dimensions as being represented by an ordered collection of three numbers: &nbsp; (X, Y, Z).",
        "<p>",
        "Task:",
        "",
        "    Write a function that takes two vectors (arrays) as input and computes their cross product.",
        "",
        "Your function should return <code>null</code> on",
        "invalid inputs (ie vectors of different lengths).",
        "</p>"
      ],
      "solutions": [
        "function crossProduct(a, b) {\n  if (!a || !b) {\n    return null;\n  }\n\n  // Check lengths\n  if (a.length !== 3 || b.length !== 3) {\n    return null;\n  }\n\n  return [\n    (a[1] * b[2]) - (a[2] * b[1]),\n    (a[2] * b[0]) - (a[0] * b[2]),\n    (a[0] * b[1]) - (a[1] * b[0])\n  ];\n}\n"
      ],
      "tests": [
        {
          "text": "dotProduct must be a function",
          "testString":
            "assert.equal(typeof crossProduct, 'function', 'dotProduct must be a function');"
        },
        {
          "text": "dotProduct() must return null",
          "testString":
            "assert.equal(crossProduct(), null, 'dotProduct() must return null');"
        },
        {
          "text": "crossProduct([1, 2, 3], [4, 5, 6]) must return [-3, 6, -3].",
          "testString":
            "assert.deepEqual(res12, exp12, 'crossProduct([1, 2, 3], [4, 5, 6]) must return [-3, 6, -3].');"
        }
      ],
      "id": "594810f028c0303b75339ad2",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function crossProduct() {", "    // Good luck!", "}"],
          "head": [],
          "tail": [
            "const tv1 = [1, 2, 3];",
            "const tv2 = [4, 5, 6];",
            "const res12 = crossProduct(tv1, tv2);",
            "const exp12 = [-3, 6, -3];"
          ]
        }
      }
    },
    {
      "title": "Vector dot product",
      "description": [
        "<p>",
        "A vector is defined as having three dimensions as being represented by an ordered collection of three numbers: &nbsp; (X, Y, Z).",
        "</p>",
        "<p>",
        "Task:",
        "",
        "    Write a function that takes any numbers of vectors (arrays) as input and computes their dot product.",
        "",
        "Your function should return <code>null</code> on",
        "invalid inputs (ie vectors of different lengths).",
        "</p>"
      ],
      "solutions": [
        "function dotProduct(...vectors) {\n  if (!vectors || !vectors.length) {\n    return null;\n  }\n  if (!vectors[0] || !vectors[0].length) {\n    return null;\n  }\n  const vectorLen = vectors[0].length;\n  const numVectors = vectors.length;\n\n  // If all vectors not same length, return null\n  for (let i = 0; i < numVectors; i++) {\n    if (vectors[i].length !== vectorLen) {\n      return null;  // return undefined\n    }\n  }\n\n  let prod = 0;\n  let sum = 0;\n  let j = vectorLen;\n  let i = numVectors;\n  // Sum terms\n  while (j--) {\n    i = numVectors;\n    prod = 1;\n\n    while (i--) {\n      prod *= vectors[i][j];\n    }\n    sum += prod;\n  }\n  return sum;\n}\n"
      ],
      "tests": [
        {
          "text": "dotProduct must be a function",
          "testString":
            "assert.equal(typeof dotProduct, 'function', 'dotProduct must be a function');"
        },
        {
          "text": "dotProduct() must return null",
          "testString":
            "assert.equal(dotProduct(), null, 'dotProduct() must return null');"
        },
        {
          "text": "dotProduct([[1], [1]]) must return 1.",
          "testString":
            "assert.equal(dotProduct([1], [1]), 1, 'dotProduct([[1], [1]]) must return 1.');"
        },
        {
          "text": "dotProduct([[1], [1, 2]]) must return null.",
          "testString":
            "assert.equal(dotProduct([1], [1, 2]), null, 'dotProduct([[1], [1, 2]]) must return null.');"
        },
        {
          "text": "dotProduct([1, 3, -5], [4, -2, -1]) must return 3.",
          "testString":
            "assert.equal(dotProduct([1, 3, -5], [4, -2, -1]), 3, 'dotProduct([1, 3, -5], [4, -2, -1]) must return 3.');"
        },
        {
          "text": "<code>dotProduct(...nVectors)</code> should return 156000",
          "testString":
            "assert.equal(dotProduct([ 0, 1, 2, 3, 4 ], [ 0, 2, 4, 6, 8 ], [ 0, 3, 6, 9, 12 ], [ 0, 4, 8, 12, 16 ], [ 0, 5, 10, 15, 20 ]), 156000, '<code>dotProduct(...nVectors)</code> should return 156000');"
        }
      ],
      "id": "594810f028c0303b75339ad3",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function dotProduct() {", "    // Good luck!", "}"],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "title": "Word wrap",
      "description": [
        "<p>",
        "Even today, with proportional fonts and complex layouts, there are still",
        "cases where you need to wrap text at a specified",
        "column.  The basic task is to wrap a paragraph of text in a simple way.",
        "Example text:",
        "</p>",
        "<pre>",
        "Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX algorithm.",
        "If your language provides this, you get easy extra credit,",
        "but you ''must reference documentation'' indicating that the algorithm",
        "is something better than a simple minimimum length algorithm.",
        "</pre>",
        "<p>",
        "Task:",
        "",
        "    Write a function that can wrap this text to any number of characters.",
        "",
        "As an example, the text wrapped to 80 characters should look like the following:",
        "</p>",
        "<pre>",
        "Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX",
        "algorithm. If your language provides this, you get easy extra credit, but you",
        "must reference documentation indicating that the algorithm is something better",
        "than a simple minimimum length algorithm.",
        "</pre>"
      ],
      "solutions": [
        "function wrap (text, limit) {\n  const noNewlines = text.replace('\\n', '');\n  if (noNewlines.length > limit) {\n    // find the last space within limit\n    const edge = noNewlines.slice(0, limit).lastIndexOf(' ');\n    if (edge > 0) {\n      const line = noNewlines.slice(0, edge);\n      const remainder = noNewlines.slice(edge + 1);\n      return line + '\\n' + wrap(remainder, limit);\n    }\n  }\n  return text;\n}\n"
      ],
      "tests": [
        {
          "text": "wrap must be a function.",
          "testString":
            "assert.equal(typeof wrap, 'function', 'wrap must be a function.');"
        },
        {
          "text": "wrap must return a string.",
          "testString":
            "assert.equal(typeof wrap('abc', 10), 'string', 'wrap must return a string.');"
        },
        {
          "text": "wrap(80) must return 4 lines.",
          "testString":
            "assert(wrapped80.split('\\n').length === 4, 'wrap(80) must return 4 lines.');"
        },
        {
          "text":
            "Your <code>wrap</code> function should return our expected text",
          "testString":
            "assert.equal(wrapped80.split('\\n')[0], firstRow80, 'Your <code>wrap</code> function should return our expected text');"
        },
        {
          "text": "wrap(42) must return 7 lines.",
          "testString":
            "assert(wrapped42.split('\\n').length === 7, 'wrap(42) must return 7 lines.');"
        },
        {
          "text":
            "Your <code>wrap</code> function should return our expected text",
          "testString":
            "assert.equal(wrapped42.split('\\n')[0], firstRow42, 'Your <code>wrap</code> function should return our expected text');"
        }
      ],
      "id": "594810f028c0303b75339ad4",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function wrap (text, limit) {", "  return text;", "}"],
          "head": [],
          "tail": [
            "const text =",
            "`Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX algorithm.",
            "If your language provides this, you get easy extra credit,",
            "but you ''must reference documentation'' indicating that the algorithm",
            "is something better than a simple minimimum length algorithm.`;",
            "",
            "const wrapped80 = wrap(text, 80);",
            "const wrapped42 = wrap(text, 42);",
            "",
            "const firstRow80 =",
            "    'Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX';",
            "",
            "const firstRow42 = 'Wrap text using a more sophisticated';"
          ]
        }
      }
    },
    {
      "title": "Y combinator",
      "description": [
        "<p>",
        "In strict ",
        "<a href=\"https://en.wikipedia.org/wiki/Functional programming\" title=\"wp: functional programming\">functional programming</a> and",
        "the <a href=\"https://en.wikipedia.org/wiki/lambda calculus\" title=\"wp: lambda calculus\">lambda calculus</a>, ",
        "functions (lambda expressions) don't have state and are only allowed to refer to arguments of enclosing functions. ",
        "This rules out the usual definition of a recursive function wherein a function is associated with the state of a variable and this variable's state is used in the body of the function.",
        "</p>",
        "<p>",
        "The <a href=\"http://mvanier.livejournal.com/2897.html\">Y combinator</a> is itself a stateless function that,",
        "when applied to another stateless function, returns a recursive version of the function. The Y combinator is",
        "the simplest of the class of such functions, called ",
        "<a href=\"https://en.wikipedia.org/wiki/Fixed-point combinator\" title=\"wp: fixed-point combinator\">fixed-point combinators</a>.",
        "</p>",
        "Task:",
        "",
        "    Define the stateless Y combinator function and use it to compute",
        "    <a href=\"https://en.wikipedia.org/wiki/Factorial\" title=\"wp: factorial\">factorial</a>.",
        "",
        "<code>factorial(N)</code> function is already given to you.",
        "See also <a href=\"http://vimeo.com/45140590\">Jim Weirich: Adventures in Functional Programming</a>."
      ],
      "solutions": ["var Y = f => (x => x(x))(y => f(x => y(y)(x)));\n"],
      "tests": [
        {
          "text": "Y must return a function",
          "testString":
            "assert.equal(typeof Y(f => n => n), 'function', 'Y must return a function');"
        },
        {
          "text": "factorial(1) must return 1.",
          "testString":
            "assert.equal(factorial(1), 1, 'factorial(1) must return 1.');"
        },
        {
          "text": "factorial(2) must return 2.",
          "testString":
            "assert.equal(factorial(2), 2, 'factorial(2) must return 2.');"
        },
        {
          "text": "factorial(3) must return 6.",
          "testString":
            "assert.equal(factorial(3), 6, 'factorial(3) must return 6.');"
        },
        {
          "text": "factorial(4) must return 24.",
          "testString":
            "assert.equal(factorial(4), 24, 'factorial(4) must return 24.');"
        },
        {
          "text": "factorial(10) must return 3628800.",
          "testString":
            "assert.equal(factorial(10), 3628800, 'factorial(10) must return 3628800.');"
        }
      ],
      "id": "594810f028c0303b75339ad5",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Y(f) {",
            "  return function() {",
            "  // Good luck!",
            "  };",
            "}",
            "",
            "var factorial = Y(function(f) {",
            "  return function (n) {",
            "    return n > 1 ? n * f(n - 1) : 1;",
            "  };",
            "});"
          ],
          "head": [],
          "tail": ["var factorial = Y(f => n => (n > 1 ? n * f(n - 1) : 1));"]
        }
      }
    },
    {
      "title": "Zeckendorf number representation",
      "description": [
        "<p>",
        "Just as numbers can be represented in a",
        "positional notation as sums of multiples of the powers of ten (decimal)",
        "or two (binary); all the positive integers can be represented as the sum",
        "of one or zero times the distinct members of the Fibonacci series.",
        "</p>",
        "<p>",
        "Recall that the first six distinct Fibonacci",
        "numbers are:  <code>1, 2, 3, 5, 8, 13</code>. The decimal number eleven can",
        "be written as <code>0*13 + 1*8 + 0*5 + 1*3 + 0*2 + 0*1</code> or",
        "<code>010100</code> in positional notation where the columns represent",
        "multiplication by a particular member of the sequence. Leading zeroes are",
        "dropped so that 11 decimal becomes <code>10100</code>.",
        "</p>",
        "<p>",
        "10100 is not the only way to make 11 from the Fibonacci numbers however",
        "<code>0*13 + 1*8 + 0*5 + 0*3 + 1*2 + 1*1</code> or 010011 would also",
        "represent decimal 11. For a true Zeckendorf number there is the added",
        "restriction that ''no two consecutive Fibonacci numbers can be used''",
        "which leads to the former unique solution.",
        "</p>",
        "<p>",
        " Task:",
        " Write a function that generates and returns an array of first N Zeckendorf numbers in order.",
        "</p>"
      ],
      "solutions": [
        "// zeckendorf :: Int -> String\nfunction zeckendorf(n) {\n  const f = (m, x) => (m < x ? [m, 0] : [m - x, 1]);\n  return (n === 0 ? ([0]) :\n    mapAccumL(f, n, reverse(\n      tail(fibUntil(n))\n    ))[1]).join('');\n}\n\n// fibUntil :: Int -> [Int]\nlet fibUntil = n => {\n  const xs = [];\n  until(\n      ([a]) => a > n,\n      ([a, b]) => (xs.push(a), [b, a + b]), [1, 1]\n  );\n  return xs;\n};\n\nlet mapAccumL = (f, acc, xs) => (\n  xs.reduce((a, x) => {\n    const pair = f(a[0], x);\n\n    return [pair[0], a[1].concat(pair[1])];\n  }, [acc, []])\n);\n\nlet until = (p, f, x) => {\n  let v = x;\n  while (!p(v)) v = f(v);\n  return v;\n};\n\nconst tail = xs => (\n   xs.length ? xs.slice(1) : undefined\n);\n\nconst reverse = xs => xs.slice(0).reverse();\n"
      ],
      "tests": [
        {
          "text": "zeckendorf must be function",
          "testString":
            "assert.equal(typeof zeckendorf, 'function', 'zeckendorf must be function');"
        },
        {
          "text":
            "Your <code>zeckendorf</code> function should return the correct answer",
          "testString":
            "assert.deepEqual(answer, solution20, 'Your <code>zeckendorf</code> function should return the correct answer');"
        }
      ],
      "id": "594810f028c0303b75339ad6",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": ["function zeckendorf(n) {", "  // good luck!", "}"],
          "head": [],
          "tail": [
            "const range = (m, n) => (",
            "  Array.from({",
            "    length: Math.floor(n - m) + 1",
            "  }, (_, i) => m + i)",
            ");",
            "",
            "const solution20 = [",
            "  '1', '10', '100', '101', '1000', '1001', '1010', '10000', '10001',",
            "  '10010', '10100', '10101', '100000', '100001', '100010', '100100', '100101',",
            "  '101000', '101001', '101010'",
            "];",
            "",
            "const answer = range(1, 20).map(zeckendorf);"
          ]
        }
      }
    },
    {
      "title": "Zhang-Suen thinning algorithm",
      "description": [
        "This is an algorithm used to thin a black and white i.e. one bit per pixel images.",
        "For example, with an input image of:",
        "<pre>",
        " #################                   #############",
        " ##################               ################",
        " ###################            ##################",
        " ########     #######          ###################",
        "   ######     #######         #######       ######",
        "   ######     #######        #######",
        "   #################         #######",
        "   ################          #######",
        "   #################         #######",
        "   ######     #######        #######",
        "   ######     #######        #######",
        "   ######     #######         #######       ######",
        " ########     #######          ###################",
        " ########     ####### ######    ################## ######",
        " ########     ####### ######      ################ ######",
        " ########     ####### ######         ############# ######",
        "                                                           </pre>",
        "It produces the thinned output:",
        "<pre>",
        "",
        "    # ##########                       #######",
        "     ##        #                   ####       #",
        "     #          #                 ##",
        "     #          #                #",
        "     #          #                #",
        "     #          #                #",
        "     ############               #",
        "     #          #               #",
        "     #          #                #",
        "     #          #                #",
        "     #          #                #",
        "     #                            ##",
        "     #                             ############",
        "                       ###                          ###",
        "",
        "                                                           </pre>",
        "<h2>Algorithm</h2>",
        "Assume black pixels are one and white pixels zero, and that the input image is a rectangular N by M array of ones and zeroes.",
        "The algorithm operates on all black pixels P1 that can have eight neighbours. The neighbours are, in order, arranged as:",
        "<table border=\"1\">",
        "  <tr><td>P9</td><td>P2</td><td>P3</td></tr>",
        "  <tr><td>P8</td><td><b>P1</b></td><td>P4</td></tr>",
        "  <tr><td>P7</td><td>P6</td><td>P5</td></tr>",
        "</table>",
        "Obviously the boundary pixels of the image cannot have the full eight neighbours.",
        "",
        "    Define $A(P1)$ = the number of transitions from white to black, (0 -> 1) in the sequence P2,P3,P4,P5,P6,P7,P8,P9,P2. (Note the extra P2 at the end - it is circular).",
        "",
        "",
        "    Define $B(P1)$ = the number of black pixel neighbours of P1. ( = sum(P2 .. P9) )",
        "",
        "<h3>Step 1:</h3>",
        "All pixels are tested and pixels satisfying all the following conditions (simultaneously) are just noted at this stage.",
        "  (0) The pixel is black and has eight neighbours",
        "  (1) $2 <= B(P1) <= 6$",
        "  (2) $A(P1) = 1$",
        "  (3) At least one of P2 and P4 and P6 is white",
        "  (4) At least one of P4 and P6 and P8 is white",
        "After iterating over the image and collecting all the pixels satisfying all step 1 conditions, all these condition satisfying pixels are set to white.",
        "<h3>Step 2:</h3>",
        "All pixels are again tested and pixels satisfying all the following conditions are just noted at this stage.",
        "  (0) The pixel is black and has eight neighbours",
        "  (1) $2 <= B(P1) <= 6$",
        "  (2) $A(P1) = 1$",
        "  (3) At least one of P2 and P4 and '''P8''' is white",
        "  (4) At least one of '''P2''' and P6 and P8 is white",
        "After iterating over the image and collecting all the pixels satisfying all step 2 conditions, all these condition satisfying pixels are again set to white.",
        "Iteration:",
        "If any pixels were set in this round of either step 1 or step 2 then all steps are repeated until no image pixels are so changed.",
        "<p>",
        "Task:",
        "Write a routine to perform Zhang-Suen thinning on an image matrix of ones and zeroes.",
        "</p>"
      ],
      "solutions": [
        "function Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nconst ZhangSuen = (function () {\n  function ZhangSuen() {\n  }\n\n  ZhangSuen.nbrs = [[0, -1], [1, -1], [1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1]];\n\n  ZhangSuen.nbrGroups = [[[0, 2, 4], [2, 4, 6]], [[0, 2, 6], [0, 4, 6]]];\n\n  ZhangSuen.toWhite = [];\n\n  ZhangSuen.main = function (image) {\n    ZhangSuen.grid = new Array(image);\n    for (let r = 0; r < image.length; r++) {\n      ZhangSuen.grid[r] = image[r].split('');\n    }\n    ZhangSuen.thinImage();\n    return ZhangSuen.getResult();\n  };\n\n  ZhangSuen.thinImage = function () {\n    let firstStep = false;\n    let hasChanged;\n    do {\n      hasChanged = false;\n      firstStep = !firstStep;\n      for (let r = 1; r < ZhangSuen.grid.length - 1; r++) {\n        for (let c = 1; c < ZhangSuen.grid[0].length - 1; c++) {\n          if (ZhangSuen.grid[r][c] !== '#') {\n            continue;\n          }\n          const nn = ZhangSuen.numNeighbors(r, c);\n          if (nn < 2 || nn > 6) {\n            continue;\n          }\n          if (ZhangSuen.numTransitions(r, c) !== 1) {\n            continue;\n          }\n          if (!ZhangSuen.atLeastOneIsWhite(r, c, firstStep ? 0 : 1)) {\n            continue;\n          }\n          ZhangSuen.toWhite.push(new Point(c, r));\n          hasChanged = true;\n        }\n      }\n      for (let i = 0; i < ZhangSuen.toWhite.length; i++) {\n        const p = ZhangSuen.toWhite[i];\n        ZhangSuen.grid[p.y][p.x] = ' ';\n      }\n      ZhangSuen.toWhite = [];\n    } while ((firstStep || hasChanged));\n  };\n\n  ZhangSuen.numNeighbors = function (r, c) {\n    let count = 0;\n    for (let i = 0; i < ZhangSuen.nbrs.length - 1; i++) {\n      if (ZhangSuen.grid[r + ZhangSuen.nbrs[i][1]][c + ZhangSuen.nbrs[i][0]] === '#') {\n        count++;\n      }\n    }\n    return count;\n  };\n\n  ZhangSuen.numTransitions = function (r, c) {\n    let count = 0;\n    for (let i = 0; i < ZhangSuen.nbrs.length - 1; i++) {\n      if (ZhangSuen.grid[r + ZhangSuen.nbrs[i][1]][c + ZhangSuen.nbrs[i][0]] === ' ') {\n        if (ZhangSuen.grid[r + ZhangSuen.nbrs[i + 1][1]][c + ZhangSuen.nbrs[i + 1][0]] === '#') {\n          count++;\n        }\n      }\n    }\n    return count;\n  };\n\n  ZhangSuen.atLeastOneIsWhite = function (r, c, step) {\n    let count = 0;\n    const group = ZhangSuen.nbrGroups[step];\n    for (let i = 0; i < 2; i++) {\n      for (let j = 0; j < group[i].length; j++) {\n        const nbr = ZhangSuen.nbrs[group[i][j]];\n        if (ZhangSuen.grid[r + nbr[1]][c + nbr[0]] === ' ') {\n          count++;\n          break;\n        }\n      }\n    }\n    return count > 1;\n  };\n\n  ZhangSuen.getResult = function () {\n    const result = [];\n    for (let i = 0; i < ZhangSuen.grid.length; i++) {\n      const row = ZhangSuen.grid[i].join('');\n      result.push(row);\n    }\n    return result;\n  };\n  return ZhangSuen;\n}());\n\nfunction thinImage(image) {\n  return ZhangSuen.main(image);\n}\n"
      ],
      "tests": [
        {
          "text": "<code>thinImage</code> must be a function",
          "testString":
            "assert.equal(typeof thinImage, 'function', '<code>thinImage</code> must be a function');"
        },
        {
          "text": "<code>thinImage</code> must return an array",
          "testString":
            "assert(Array.isArray(result), '<code>thinImage</code> must return an array');"
        },
        {
          "text": "<code>thinImage</code> must return an array of strings",
          "testString":
            "assert.equal(typeof result[0], 'string', '<code>thinImage</code> must return an array of strings');"
        },
        {
          "text": "<code>thinImage</code> must return an array of strings",
          "testString":
            "assert.deepEqual(result, expected, '<code>thinImage</code> must return an array of strings');"
        }
      ],
      "id": "594810f028c0303b75339ad7",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "const testImage = [",
            "  '                                                          ',",
            "  ' #################                   #############        ',",
            "  ' ##################               ################        ',",
            "  ' ###################            ##################        ',",
            "  ' ########     #######          ###################        ',",
            "  '   ######     #######         #######       ######        ',",
            "  '   ######     #######        #######                      ',",
            "  '   #################         #######                      ',",
            "  '   ################          #######                      ',",
            "  '   #################         #######                      ',",
            "  '   ######     #######        #######                      ',",
            "  '   ######     #######        #######                      ',",
            "  '   ######     #######         #######       ######        ',",
            "  ' ########     #######          ###################        ',",
            "  ' ########     ####### ######    ################## ###### ',",
            "  ' ########     ####### ######      ################ ###### ',",
            "  ' ########     ####### ######         ############# ###### ',",
            "  '                                                          '];",
            "",
            "function thinImage(image) {",
            "  // Good luck!",
            "}"
          ],
          "head": [],
          "tail": [
            "const imageForTests = [",
            "  '                                                          ',",
            "  ' #################                   #############        ',",
            "  ' ##################               ################        ',",
            "  ' ###################            ##################        ',",
            "  ' ########     #######          ###################        ',",
            "  '   ######     #######         #######       ######        ',",
            "  '   ######     #######        #######                      ',",
            "  '   #################         #######                      ',",
            "  '   ################          #######                      ',",
            "  '   #################         #######                      ',",
            "  '   ######     #######        #######                      ',",
            "  '   ######     #######        #######                      ',",
            "  '   ######     #######         #######       ######        ',",
            "  ' ########     #######          ###################        ',",
            "  ' ########     ####### ######    ################## ###### ',",
            "  ' ########     ####### ######      ################ ###### ',",
            "  ' ########     ####### ######         ############# ###### ',",
            "  '                                                          '];",
            "const expected = [",
            "  '                                                          ',",
            "  '                                                          ',",
            "  '    # ##########                       #######            ',",
            "  '     ##        #                   ####       #           ',",
            "  '     #          #                 ##                      ',",
            "  '     #          #                #                        ',",
            "  '     #          #                #                        ',",
            "  '     #          #                #                        ',",
            "  '     ############               #                         ',",
            "  '     #          #               #                         ',",
            "  '     #          #                #                        ',",
            "  '     #          #                #                        ',",
            "  '     #          #                #                        ',",
            "  '     #                            ##                      ',",
            "  '     #                             ############           ',",
            "  '                       ###                          ###   ',",
            "  '                                                          ',",
            "  '                                                          '",
            "];",
            "const result = thinImage(imageForTests);"
          ]
        }
      }
    },
    {
      "title": "Zig-zag matrix",
      "description": [
        "A &nbsp; ''zig-zag'' &nbsp; array is a square arrangement of the first &nbsp;",
        "$N^2$ &nbsp; integers, &nbsp; where the",
        "numbers increase sequentially as you zig-zag along the array's &nbsp;",
        "<a href=\"https://en.wiktionary.org/wiki/antidiagonal\">anti-diagonals</a>.",
        "For example, given &nbsp; '''5''', &nbsp; produce this array:",
        "<pre>",
        " 0  1  5  6 14",
        " 2  4  7 13 15",
        " 3  8 12 16 21",
        " 9 11 17 20 22",
        "10 18 19 23 24",
        "</pre>",
        "Write a function that takes the size of the zig-zag matrix, and returns the",
        "corresponding matrix as two-dimensional array."
      ],
      "solutions": [
        "function ZigZagMatrix(n) {\n  const mtx = [];\n  for (let i = 0; i < n; i++) {\n    mtx[i] = [];\n  }\n\n  let i = 1;\n  let j = 1;\n  for (let e = 0; e < n * n; e++) {\n    mtx[i - 1][j - 1] = e;\n    if ((i + j) % 2 === 0) {\n      // Even stripes\n      if (j < n) j++;\n      else i += 2;\n      if (i > 1) i--;\n    } else {\n      // Odd stripes\n      if (i < n) i++;\n      else j += 2;\n      if (j > 1) j--;\n    }\n  }\n  return mtx;\n}\n"
      ],
      "tests": [
        {
          "text": "ZigZagMatrix must be a function",
          "testString":
            "assert.equal(typeof ZigZagMatrix, 'function', 'ZigZagMatrix must be a function');"
        },
        {
          "text": "ZigZagMatrix should return array",
          "testString":
            "assert.equal(typeof ZigZagMatrix(1), 'object', 'ZigZagMatrix should return array');"
        },
        {
          "text": "ZigZagMatrix should return an array of nestes arrays",
          "testString":
            "assert.equal(typeof ZigZagMatrix(1)[0], 'object', 'ZigZagMatrix should return an array of nestes arrays');"
        },
        {
          "text": "ZigZagMatrix(1) should return [[0]]",
          "testString":
            "assert.deepEqual(ZigZagMatrix(1), zm1, 'ZigZagMatrix(1) should return [[0]]');"
        },
        {
          "text": "ZigZagMatrix(2) should return [[0, 1], [2, 3]]",
          "testString":
            "assert.deepEqual(ZigZagMatrix(2), zm2, 'ZigZagMatrix(2) should return [[0, 1], [2, 3]]');"
        },
        {
          "text": "ZigZagMatrix(5) must return specified matrix",
          "testString":
            "assert.deepEqual(ZigZagMatrix(5), zm5, 'ZigZagMatrix(5) must return specified matrix');"
        }
      ],
      "id": "594810f028c0303b75339ad8",
      "challengeType": 5,
      "releasedOn": "December 27, 2017",
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function ZigZagMatrix(n) {",
            "  // Good luck!",
            "  return [[], []];",
            "}"
          ],
          "head": [],
          "tail": [
            "const zm1 = [[0]];",
            "const zm2 = [[0, 1], [2, 3]];",
            "const zm5 = [",
            "  [0, 1, 5, 6, 14],",
            "  [2, 4, 7, 13, 15],",
            "  [3, 8, 12, 16, 21],",
            "  [9, 11, 17, 20, 22],",
            "  [10, 18, 19, 23, 24]",
            "];"
          ]
        }
      }
    }
  ]
}
